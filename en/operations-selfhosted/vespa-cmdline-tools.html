---
# Copyright Vespa.ai. All rights reserved.
title: "Vespa Command-line Tools"
redirect_from:
- /documentation/reference/vespa-cmdline-tools.html
- /en/reference/vespa-cmdline-tools.html
---

<p>
This is the reference for the Vespa command-line tools.
</p>

{% include note.html content='The tools listed on this page are primarily used
for operating and debugging a <em>self-hosted</em> Vespa instance. For most
use-cases we recommend the <a href="../vespa-cli.html">Vespa CLI</a> which
should work against most Vespa applications regardless of how they are deployed.' %}


<!--h2 id="vespa-config-ctl">vespa-config-ctl</h2-->
<!--h2 id="vespa-config-loadtester">vespa-config-loadtester</h2-->


<h2 id="vespa-configproxy-cmd">vespa-configproxy-cmd</h2>
<p>
<em>vespa-configproxy-cmd</em> is a status and control tool for the
<a href="/en/operations-selfhosted/config-proxy.html">config proxy</a>.
The config proxy runs on all nodes as a proxy for one or more
<a href="/en/operations-selfhosted/configuration-server.html">config servers</a>.
It connects to the config proxy on localhost by default.
</p>
<p>
  Run it without arguments to dump a list of active configIds - format specification:
</p>
<p>
  <code>&lt;config definition name&gt;,&lt;config id&gt;,&lt;config generation&gt;,&lt;MD5 checksum&gt;,&lt;xxHash checksum&gt;</code>
</p>
<p>
Synopsis: <code>vespa-configproxy-cmd [args]</code>
</p><p>
Example:
</p>
<pre>
$ vespa-configproxy-cmd -m sources
</pre>
<p>
  Find a more comprehensive example in
  <a href="/en/operations-selfhosted/config-proxy.html#inspecting-config">inspecting config</a>.
</p>
<table class="table">
  <thead>
  <tr>
    <th>Option</th>
    <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
      <th>-m</th>
      <td>
        method, available methods are:
        <table class="table">
          <thead></thead><tbody>
            <tr>
              <th>cache</th>
              <td>
                Output the config proxy cache content (overview)
              </td>
            </tr><tr>
              <th>gc</th>
              <td>
                <!-- ToDo -->
              </td>
            </tr><tr>
              <th>dumpcache</th>
              <td>
                <!-- ToDo -->
              </td>
            </tr><tr>
              <th>statistics</th>
              <td>
                <!-- ToDo -->
              </td>
            </tr><tr>
              <th>heap</th>
              <td>
                <!-- ToDo -->
              </td>
            </tr><tr>
              <th>getConfig</th>
              <td>
                Get config (see <a href="#vespa-get-config">vespa-get-config</a>)
              </td>
            </tr><tr>
              <th>getmode</th>
              <td>
                Outputs the current mode of the config proxy
              </td>
            </tr><tr>
              <th>setmode</th>
              <td>
                Use <em>default</em> or <em>memorycache</em> -
                <a href="/en/operations-selfhosted/config-proxy.html">example</a>
              </td><!-- ToDo need a list here - are more options supported? -->
            </tr><tr>
              <th>invalidatecache</th>
              <td>
                Clears the current cache in config proxy
              </td>
            </tr><tr>
              <th>cachefull</th>
              <td>
                Output the config proxy cache content (including config payload)
              </td>
            </tr><tr>
              <th>sources</th>
              <td>
                Output the config proxy's upstream config sources
              </td>
            </tr><tr>
              <th>updatesources</th>
              <td>
                Updates the config proxy's upstream config sources to the supplied ones
              </td>
            </tr>
          </tbody>
        </table>
      </td>
    </tr><tr>
      <th>-p</th>
      <td>
        port number, optional
      </td>
    </tr><tr>
      <th>-s</th>
      <td>
        hostname, optional
      </td>
    </tr><tr>
      <th>-h</th>
      <td>
        help text and usage
      </td>
    </tr>
  </tbody>
</table>



<h2 id="vespa-configserver-remove-state">vespa-configserver-remove-state</h2>
<p>
<em>vespa-configserver-remove-state</em> removes config server state on the host.
</p><p>
Synopsis: <code>vespa-configserver-remove-state [-force]</code>
</p>
<table class="table">
  <thead>
  <tr>
    <th>Option</th>
    <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
      <th>-force</th>
      <td>Do not ask for confirmation before removal</td>
    </tr>
  </tbody>
</table>



<h2 id="vespa-config-status">vespa-config-status</h2>
<p>
<em>vespa-config-status</em> can run on any machine in a Vespa cluster
and outputs a list of all running services which is running with an outdated application package.
It can be invoked without any arguments, or with optional arguments.
</p><p>
Synopsis: <code>vespa-config-status [-v] [-c host] [-c host:port]  [-f host0,...,hostN]</code>
</p><p>
Example:
</p>
<pre>
$ vespa-config-status
</pre>
<table class="table">
  <thead>
  <tr>
    <th>Option</th>
    <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
      <th>-v</th>
      <td>Verbose - show all services, even if they are up to date</td>
    </tr><tr>
      <th>-c arg</th>
      <td>Get Vespa cluster configuration from the config server specified by host and port.
        Use <em>host</em> or <em>host:port</em> for config server</td>
    </tr><tr>
      <th>-f</th>
      <td>Filter to only query config status for the given comma-separated set of hosts</td>
    </tr>
  </tbody>
</table>



<!--h2 id="vespa-config-verification">vespa-config-verification</h2-->
<!--h2 id="vespa-create-idx-from-dat">vespa-create-idx-from-dat</h2-->



<h2 id="vespa-deploy">vespa-deploy</h2>
<p>
<em>vespa-deploy</em> is a standalone tool to deploy an application package.
Prefer the <a href="/en/vespa-cli.html#deployment">Vespa CLI</a> instead.
Under the hood deployment uses the the <a href="/en/reference/deploy-rest-api-v2.html">deploy REST API</a>,
which you can also use directly.
Refer to the <a href="/en/reference/application-packages-reference.html#deploy">deploy reference</a> for details.
</p><p>
Synopsis: <code>vespa-deploy [-h] [-v] [-n] [-f] [-t timeout] [-c hostname] [-p port] prepare|activate|upload|fetch|help [args]</code>
</p><p>
Example:
</p>
<pre>
$ vespa-deploy prepare [application-path|zip-file] &amp;&amp; vespa-deploy activate
</pre>
<pre>
$ vespa-deploy prepare app.zip &amp;&amp; vespa-deploy activate
</pre>
<table class="table">
  <thead>
  <tr>
    <th>Command</th>
    <th>Description</th>
  </tr>
  </thead><tbody>
    <tr>
      <th>prepare</th>
      <td>
        <em>vespa-deploy prepare</em> combines the
        <a href="/en/reference/deploy-rest-api-v2.html#create-session">upload</a> and
        <a href="/en/reference/deploy-rest-api-v2.html#prepare-session">prepare</a> steps.
      </td>
    </tr><tr>
      <th>activate</th>
      <td>
        <em>vespa-deploy activate</em> invokes the
        <a href="/en/reference/deploy-rest-api-v2.html#activate-session">activate</a> step.
      </td>
    </tr><tr>
      <th>upload</th>
      <td>
        <em>vespa-deploy upload</em> uploads an application package
      </td>
    </tr><tr>
      <th>fetch</th>
      <td>
        <em>vespa-deploy fetch</em> fetches an application package.
        Useful to get the active configuration for an instance.
      </td>
    </tr><tr>
      <th>help</th>
      <td>
        Same as <strong>-h</strong>
      </td>
    </tr>
  </tbody>
</table>
<table class="table">
  <thead>
  <tr>
    <th>Option</th>
    <th>Description</th>
  </tr>
  </thead><tbody>
    <tr>
      <th>-h</th>
      <td>
        Show help text
      </td>
    </tr><tr>
      <th>-v</th>
      <td>
        Verbose
      </td>
    </tr><tr>
      <th>-n</th>
      <td>
        Dry-run deployment
      </td>
    </tr><tr>
      <th>-f</th>
      <td>
        Force - ignore validation errors
      </td>
    </tr><tr>
      <th>-t</th>
      <td>
        Timeout
      </td>
    </tr><tr>
      <th>-c</th>
      <td>
        Config server hostname
      </td>
    </tr><tr>
      <th>-p</th>
      <td>
        Config server port
      </td>
    </tr>
  </tbody>
</table>



<h2 id="vespa-destination">vespa-destination</h2>
<p>
<em>vespa-destination</em> is a simple receiver for messagebus messages.
It outputs messages received on stdout.
Also see <a href="#vespa-visit-target">vespa-visit-target</a>.
</p><p>
Synopsis: <code>vespa-destination [options]</code>
</p><p>
Example:
</p>
<pre>
$ vespa-destination --name msg_sink
</pre>
<table class="table">
  <thead>
  <tr>
    <th>Option</th>
    <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
      <th>--instant</th>
      <td>Reply in message thread</td>
    </tr><tr>
      <th>--name arg</th>
      <td>Slobrok name to register</td>
    </tr><tr>
      <th>--maxqueuetime arg</th>
      <td>Adjust the in queue size to have a maximum queue wait period of this many ms
        (default -1 = unlimited)</td>
    </tr><tr>
      <th>--silent #nummsg</th>
      <td>Do not dump anything, but progress every #nummsg</td>
    </tr><tr>
      <th>--sleeptime arg</th>
      <td>The number of milliseconds to sleep per message, to simulate processing time</td>
    </tr><tr>
      <th>--threads arg</th>
      <td>The number of threads to process the incoming data</td>
    </tr><tr>
      <th>--verbose</th>
      <td>Dump the contents of certain messages to stdout</td>
    </tr>
  </tbody>
</table>



<!--h2 id="vespa-doclocator">vespa-doclocator</h2-->
<!--h2 id="vespa-documentstore-benchmark">vespa-documentstore-benchmark</h2-->
<!--h2 id="vespa-documentstore-inspect">vespa-documentstore-inspect</h2-->
<!--h2 id="vespa-eval-expr">vespa-eval-expr</h2-->
<!--h2 id="vespa-expand-config.pl">vespa-expand-config.pl</h2-->
<!--h2 id="vespa-external-providerproxy-conformancetest">vespa-external-providerproxy-conformancetest</h2-->


<!-- ToDo: remove? -->
<h2 id="vespa-fbench-filter-file">vespa-fbench-filter-file</h2>
<pre>
usage: vespa-fbench-filter-file [-a] [-h] [-m maxLineSize]

Read concatenated fastserver logs from stdin and write
extracted query urls to stdout.

 -a       : all parameters to the original query urls are preserved.
            If the -a switch is not given, only 'query' and 'type'
            parameters are kept in the extracted query urls.
 -h       : print this usage information.
 -m &lt;num&gt; : max line size for input/output lines.
            Can not be less than the default [10240]
</pre>


<!-- ToDo: remove? -->
<h2 id="vespa-fbench-geturl">vespa-fbench-geturl</h2>
<p></p>
<pre>
usage: vespa-fbench-geturl &lt;host&gt; &lt;port&gt; &lt;url&gt;
</pre>


<!-- ToDo: remove? -->
<h2 id="vespa-fbench-split-file">vespa-fbench-split-file</h2>
<p></p>
<pre>
usage: vespa-fbench-split-file [-p pattern] [-m maxLineSize] &lt;numparts&gt; [&lt;file&gt;]

Reads from &lt;file&gt; (stdin if &lt;file&gt; is not given) and
randomly distributes each line between &lt;numpart&gt; output
files. The names of the output files are generated by
combining the &lt;pattern&gt; with sequential numbers using
the sprintf function.

 -p pattern : output name pattern ['query%03d.txt']
 -m &lt;num&gt;   : max line size for input/output lines.
              Can not be less than the default [10240]
 &lt;numparts&gt; : number of output files to generate.
</pre>



<h2 id="vespa-feeder">vespa-feeder</h2>
<p>
<em>vespa-feeder</em> is a feeding client that parses
<a href="/en/reference/document-json-format.html">JSON</a> input
as Vespa document operations and sends to a Vespa application.
It parses the content of the input sequentially, and feeds each operation in order.
However, since many operations will be pending at any time,
and because the processing time of an operation varies,
there is no guarantee as to which order operations reach the content nodes.
As this can be important when it comes to operations that apply to the same document id,
there is logic in place to not send an operation for a document id to which there is already a pending operation.
</p><p>
<em>vespa-feeder</em> prints a report at end of feed.
To print this report once a minute, use <em>--verbose</em>:
</p>
<pre>
Messages sent to vespa (route default) :
----------------------------------------
PutDocument: ok: 999997 msgs/sec: 411.38 failed: 0 <span class="pre-hilite">ignored: 0</span> latency(min, max, avg): 2, 4360, 99
</pre>
<p>
<em>ignored</em> reports the number of documents that could not be
routed to any <a href="/en/reference/services-content.html">content clusters</a> because they did not match any of the
<a href="/en/reference/services-content.html#documents">configured document types</a> or selections - examples are:
</p>
<ul>
  <li>
    A document type is removed from the application
    and the feed file contains documents with this type
  </li><li>
    One or more selection expressions restrict the documents the cluster accepts,
    and the feed file contains documents that are excluded.
    An example is feeding <a href="/en/documents.html#document-expiry">expired documents</a> -
    a selection for documents that are less than 30 days old
    and the feed file contains documents that are 30+ days old
  </li>
</ul>
<p>
Synopsis: <code>vespa-feeder [--abortondataerror true|false] [--abortonsenderror true|false] [--file arg] [--maxpending arg] [--maxpendingsize arg] [--maxfeedrate arg] [mode standard|benchmark] [--noretry] [--retrydelay arg] [--route arg] [--timeout arg] [--trace arg] [--validate] [--dumpDocuments filename] [--numthreads arg] [create-if-non-existent] [-v,--verbose] filename</code>
</p><p>
Example:
</p>
<pre>
$ vespa-feeder file.json
</pre>
<table class="table">
  <thead>
  <tr>
    <th>Option</th>
    <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
      <th>--abortondataerror arg</th>
      <td>
        Abort if the input has errors (true|false) - default true.
        Set to <em>false</em> in case the input has errors (e.g. invalid characters).
        <em>vespa-feeder</em> notifies on parsing errors at the end of the feed, but it will not abort
      </td>
    </tr><tr>
      <th>--abortonsenderror arg</th>
      <td>
        Abort if an error occurred while sending operations to Vespa (true|false) - default true
      </td>
    </tr><tr>
      <th>--file arg</th>
      <td>
        Input files to read. These can also be passed as arguments without the option prefix.
        If none is given, this tool parses identifiers from stdin
      </td>
    </tr><tr>
      <th>--maxpending arg</th>
      <td>
        Maximum number of pending operations. This disables dynamic throttling, use with care
        <!-- ToDo link to dynamic throttling doc -->
      </td>
    </tr><tr>
      <th>--maxpendingsize arg</th>
      <td>
        Maximum size (in bytes) of pending operations
      </td>
    </tr><tr>
      <th>--maxfeedrate arg</th>
      <td>
        Limits the feed rate to the given number (operations/second)
      </td>
    </tr><tr>
      <th>--mode</th>
      <td>
        The mode to run vespa-feeder in (standard|benchmark) - default standard
      </td>
    </tr><tr>
      <th>--noretry</th>
      <td>
        Disables retries of recoverable failures
      </td>
    </tr><tr>
      <th>--retrydelay arg</th>
      <td>
        The time (in seconds) to wait between retries of a failed operation. Default 1
      </td>
    </tr><tr>
      <th>--route arg</th>
      <td>
        The <a href="/en/operations-selfhosted/routing.html">route</a> to send the data to. Default the the <em>default</em> route
      </td>
    </tr><tr>
      <th>--timeout arg</th>
      <td>
        Time (in seconds) allowed for sending operations. Default 180
      </td>
    </tr><tr>
      <th>--trace arg</th>
      <td>
        Trace level of network traffic. Default 0
      </td>
    </tr><tr>
      <th>--validate</th>
      <td>
        Run validation tool on input files - do not feed
      </td>
    </tr><tr>
        <th>--dumpDocuments &lt;filename&gt;</th>
      <td>
        File where documents in the put are serialized
      </td>
    </tr><tr>
        <th>--numthreads arg</th>
      <td>
        How many threads to use for sending. Default 1
      </td>
    </tr><tr>
        <th>--create-if-non-existent</th>
      <td>
        Enable setting of create-if-non-existent to true on all document updates in the given feed
      </td>
    </tr><tr>
        <th>-v, --verbose</th>
      <td>
        Enable verbose output of progress
      </td>
    </tr>
  </tbody>
</table>



<!--h2 id="vespa-fileheader-inspect">vespa-fileheader-inspect</h2-->
<!--h2 id="vespa-fsadump">vespa-fsadump</h2-->
<!--h2 id="vespa-fsainfo">vespa-fsainfo</h2-->
<!--h2 id="vespa-gbdt-converter">vespa-gbdt-converter</h2-->
<!--h2 id="vespa-gen-testdocs">vespa-gen-testdocs</h2-->



<h2 id="vespa-get">vespa-get</h2>
<p>
<em>vespa-get</em> retrieves documents from a Vespa content cluster, and prints to <em>stdout</em>.
<em>vespa-get</em> retrieves documents identified by the document ids passed as command line arguments.
If no document ids are passed through the command line interface,
ids will be read from <em>stdin</em> - separated by line breaks.
</p><p>
Synopsis: <code>vespa-get &lt;options&gt; [documentid...]</code>
</p>
<table class="table">
  <thead>
  <tr>
    <th>Option</th>
    <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
      <th>-a,--trace <em>tracelevel</em></th>
      <td>Trace level to use (default 0)</td>
    </tr><tr>
      <th>-c,--configid <em>configid</em></th><!-- ToDo link to config id -->
      <td>Use the specified config id for messagebus configuration</td>
    </tr><tr>
      <th>-f,--fieldset <em>fieldset</em></th>
      <td>
        Retrieve the specified fields only
        (see <a href="/en/documents.html#fieldsets">Document field sets</a>).
        Default: <code>[document]</code>
      </td>
    </tr><tr>
      <th>-h,--help</th>
      <td>Show this syntax page</td>
    </tr><tr>
      <th>-i,--printids</th>
      <td>Show only identifiers of retrieved documents</td>
    </tr><tr>
      <th>-j,--jsonoutput</th>
      <td>JSON output (default)</td>
    </tr><tr>
      <th>-l,--loadtype <em>loadtype</em></th><!-- ToDo link to loadtypes -->
      <td>Load type (default "")</td>
    </tr><tr>
      <th>-n,--noretry</th>
      <td>Do not retry operation on transient errors, as is default</td>
    </tr><tr>
      <th>-r,--route <em>route</em></th>
      <td>Send request to the given messagebus route</td>
    </tr><tr>
      <th>-s,--showdocsize</th>
      <td>Show binary size of document</td>
    </tr><tr>
      <th>--shorttensors</th>
      <td>Output using <a href="/en/reference/document-json-format.html#tensor">tensor short form</a></td>
    </tr><tr>
      <th>-t,--timeout <em>timeout</em></th>
      <td>Set timeout for the request in seconds (default 0)</td>
    </tr><tr>
      <th>-u,--cluster <em>cluster</em></th>
      <td>Send request to the given content cluster</td>
    </tr>
  </tbody>
</table>



<h2 id="vespa-get-cluster-state">vespa-get-cluster-state</h2>
<p>
Get cluster state - refer to <a href="/en/content/content-nodes.html">content nodes</a>.
</p><p>
Synopsis: <code>vespa-get-cluster-state [options]</code>
</p>
<table class="table">
  <thead>
  <tr>
    <th>Option</th>
    <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
      <th>-h, --help</th>
      <td>
        Show help
      </td>
    </tr><tr>
      <th>-v</th>
      <td>
        More verbose output
      </td>
    </tr><tr>
      <th>-s</th>
      <td>
        Less verbose output
      </td>
    </tr><tr>
      <th>--show-hidden</th>
      <td>
        Also show hidden undocumented debug options
      </td>
    </tr><tr>
      <th>-c, --cluster</th>
      <td>
        Cluster name of cluster to query.
        If unspecified, and vespa is installed on current node,
        information will be attempted auto-extracted
      </td>
    </tr><tr>
      <th>-f, --force</th>
      <td>
        Force execution
      </td>
    </tr><tr>
      <th>--config-server</th>
      <td>
        Host name of config server to query
      </td>
    </tr><tr>
      <th>--config-server-port</th>
      <td>
        Port to connect to config server on
       </td>
    </tr><tr>
      <th>--config-request-timeout</th>
      <td>
        Timeout of config request
      </td>
    </tr>
  </tbody>
</table>



<h2 id="vespa-get-config">vespa-get-config</h2>
<p>
<em>vespa-get-config</em> is a command line tool to get configuration
from a <a href="/en/operations-selfhosted/configuration-server.html">config server</a>
or <a href="/en/operations-selfhosted/config-proxy.html">config proxy</a>.
By default, it connects to the config proxy on localhost, fetches config from its cache
and prints the config payload on stdout.
Configuration is addressed using name and <a href="/en/contributing/configapi-dev.html#config-id">configId</a>.
If configId is omitted, the global and default data for that name is returned.
The default port number is 19090, the config proxy's port - use 19070 to access a  config server.
Also check <a href="/en/operations-selfhosted/files-processes-and-ports.html">ports</a>.
</p>

<p>
Synopsis: <code>vespa-get-config -n defName -i configId &lt;option&gt; [args]</code>
</p><p>
Example:
</p>
<pre>
$ vespa-get-config -n container.statistics -i search/cluster.search
</pre>
<p>
  Find a more comprehensive example in
  <a href="/en/operations-selfhosted/config-proxy.html#inspecting-config">inspecting config</a>.
</p>
<table class="table">
  <thead>
  <tr>
    <th>Option</th>
    <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
      <th>-n</th>
      <td>
        config definition name, including namespace (on the form &lt;namespace&gt;.&lt;name&gt;)
      </td>
    </tr><tr>
      <th>-i</th>
      <td>
        config id, optional
      </td>
    </tr><tr>
      <th>-a</th>
      <td>
        config def schema file, optional (if you want to use another schema than known for the config server)
      </td>
    </tr><tr>
      <th>-m</th>
      <td>
        defMd5, optional
      </td>
    </tr><tr>
      <th>-c</th>
      <td>
        configMd5, optional
      </td>
    </tr><tr>
      <th>-t</th>
      <td>
        server timeout, in seconds, default value 3, optional
      </td>
    </tr><tr>
      <th>-w</th>
      <td>
        timeout, default value 10, optional
      </td>
    </tr><tr>
      <th>-s</th>
      <td>
        server hostname, default localhost, optional
      </td>
    </tr><tr>
      <th>-p</th>
      <td>
        port, default 19090, optional
      </td>
    </tr><tr>
      <th>-d</th>
      <td>
        debug mode, optional
      </td>
    </tr><tr>
      <th>-h</th>
      <td>
        help text and usage
      </td>
    </tr>
  </tbody>
</table>



<h2 id="vespa-get-node-state">vespa-get-node-state</h2>
<p>
Get the state of one or more storage services from the fleet controller -
refer to <a href="/en/content/content-nodes.html">content nodes</a>:
</p>
<table class="table">
  <thead>
  <tr>
    <th>State</th>
    <th>Description</th>
  </tr>
  </thead>
  <tbody>
<tr>
  <th>Unit state</th>
  <td>The state of the node seen from the cluster controller.</td>
</tr><tr>
  <th>User state</th>
  <td>The state the administrator want the node to be in, default "up".
    Can be set by using <a href="#vespa-set-node-state">vespa-set-node-state</a>
    or by the cluster controller</td>
</tr><tr>
  <th style="white-space:nowrap;">Generated state</th>
  <td>The state of a given node in the current cluster state.
    This is the state all the other nodes know about.
    This state is a product of the other two states
    and cluster controller logic to keep the cluster stable.</td>
</tr>
  </tbody>
</table>
<p>
Synopsis: <code>vespa-get-node-state [options]</code>
</p>
<table class="table">
  <thead>
  <tr>
    <th>Option</th>
    <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
      <th>-h, --help</th>
      <td>
        Show help
      </td>
    </tr><tr>
      <th>-v</th>
      <td>
        More verbose output
      </td>
    </tr><tr>
      <th>-s</th>
      <td>
        Less verbose output
      </td>
    </tr><tr>
      <th>--show-hidden</th>
      <td>
        Also show hidden undocumented debug options
      </td>
    </tr><tr>
      <th>-c, --cluster</th>
      <td>
        Cluster name of cluster to query.
        If unspecified, and vespa is installed on current node,
        information will be attempted auto-extracted
      </td>
    </tr><tr>
      <th>-f, --force</th>
      <td>
        Force execution
      </td>
    </tr><tr>
      <th>-t, --type</th>
      <td>
        Node type - can either be 'storage' or 'distributor'.
        If not specified, the operation will use state for both types
      </td>
    </tr><tr>
      <th>-i, --index</th>
      <td>
        Node index. If not specified,
        all nodes found running on this host will be used
      </td>
    </tr><tr>
      <th>--config-server</th>
      <td>
        Host name of config server to query
      </td>
    </tr><tr>
      <th>--config-server-port</th>
      <td>
        Port to connect to config server on
       </td>
    </tr><tr>
      <th>--config-request-timeout</th>
      <td>
        Timeout of config request
      </td>
    </tr>
  </tbody>
</table>


<h2 id="vespa-index-inspect">vespa-index-inspect</h2>
<p>
Use <em>vespa-index-inspect</em> to inspect indexed data on a content node.
To troubleshoot <a href="/en/query-rewriting.html">query rewriting</a>
and <a href="/en/linguistics.html">linguistic transformations</a>
use this <a href="/en/text-matching.html#index-and-attribute">guide</a> instead.
</p><p>
It shows posting list information (per token or all/range), or dumps the indexed tokens:
</p>
<pre>
vespa-index-inspect showpostings [--indexdir indexDir] --field field word

vespa-index-inspect showpostings [--indexdir indexDir] [--field field] --transpose \
  [--docidlimit docIdLimit] [--mindocid mindocid]

vespa-index-inspect dumpwords [--indexdir indexDir] --field field \
  [--minnumdocs minnumdocs] [--verbose] [--wordnum]
</pre>
<p>
Synopsis:<code>vespa-index-inspect showpostings|dumpwords [--indexdir path] [--field fieldname] [--transpose] [--minnumdocs count] [--docidlimit docIdLimit] [--mindocid mindocid] [--verbose] [--wordnum] [word]</code>
</p><p>
Example (make sure to flush the index before using):
</p>
<pre>
$ <a href="#vespa-proton-cmd">vespa-proton-cmd</a> --local triggerFlush &amp;&amp; \
  vespa-index-inspect dumpwords \
  --indexdir /opt/vespa/var/db/vespa/search/cluster.music/n0/documents/music/0.ready/index/index.flush.1 \
  --field artist
bad	2
so	1
</pre>
<table class="table">
  <thead>
  <tr>
    <th>Option</th>
    <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
      <th>--indexdir <em>path</em></th>
      <td>Index location</td>
    </tr><tr>
      <th>--field <em>fieldname</em></th>
      <td>Field to analyze</td>
    </tr><tr>
      <th>--transpose</th>
      <td>Dump all tokens</td>
    </tr><tr>
      <th>--minnumdocs <em>count</em></th>
      <td>Minimum number of documents to analyze</td>
    </tr><tr>
      <th>--docidlimit <em>docid</em></th>
      <td>Dump up to this doc id</td>
    </tr><tr>
      <th>--mindocid <em>docid</em></th>
      <td>Start from this docid</td>
    </tr><tr>
      <th>--wordnum</th>
      <td>Also dump token numbers</td>
    </tr><tr>
      <th>--verbose</th>
      <td>Verbose output</td>
    </tr>
  </tbody>
</table>


<h2 id="vespa-attribute-inspect">vespa-attribute-inspect</h2>
<p>
Use <em>vespa-attribute-inspect</em> to inspect the content of an attribute field on a content node.
To troubleshoot <a href="/en/query-rewriting.html">query rewriting</a>
and <a href="/en/linguistics.html">linguistic transformations</a>
use this <a href="/en/text-matching.html#index-and-attribute">guide</a> instead.
</p><p>
Synopsis: <code>vespa-attribute-inspect [-p attribute] [-a] [-s attribute] &lt;attribute&gt;</code>
</p><p>
Example (make sure to flush the attribute before using):
</p>
<pre>
$ <a href="#vespa-proton-cmd">vespa-proton-cmd</a> --local triggerFlush &amp;&amp; \
  vespa-attribute-inspect -p /opt/vespa/var/db/vespa/search/cluster.music/n0/documents/music/0.ready/attribute/year/snapshot-10/year &amp;&amp; \
  cat /opt/vespa/var/db/vespa/search/cluster.music/n0/documents/music/0.ready/attribute/year/snapshot-10/year.out
</pre>
<table class="table">
  <thead>
  <tr>
    <th>Option</th>
    <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
      <th>-p</th>
      <td>print content to &lt;attribute&gt;.out</td>
    </tr><tr>
      <th>-s</th>
      <td>save attribute to &lt;attribute&gt;.save.dat</td>
    </tr>
  </tbody>
</table>


<h2 id="vespa-jvm-dumper">vespa-jvm-dumper</h2>
<p>
  Dump JVM heap, thread stacks and other debugging information from a Java-based Vespa service.
</p>
<p>
  Invoke binary without arguments to print help and list the services running on this node.
</p>
<pre>
$ vespa-jvm-dumper
</pre>
<p>
  Produce JVM debugging information by invoking binary with config id of target service and output directory.
</p>
<pre>
$ vespa-jvm-dumper default/container.1 /opt/vespa/tmp/jvm-dump
</pre>

<!--h2 id="vespa-log-conv">vespa-log-conv</h2-->



<h2 id="vespa-logctl">vespa-logctl</h2>
<p>
Print or modify log levels for a VESPA service, stored in
<em>$VESPA_HOME/var/db/vespa/logcontrol/service.logcontrol</em>.
Refer to <a href="/en/reference/logs.html#controlling-log-levels">controlling log levels</a> for details.
<em>component-specification</em> specifies which subcomponents of the service should be controlled.
If empty, all components are controlled:
</p>
<ul>
  <li><code>x.</code> : Matches only component x</li>
  <li><code>x</code>  : Matches component x and all its sub-components</li>
</ul>
<p>
Synopsis (show log levels): <code>vespa-logctl [OPTION] &lt;service&gt;[:component-specification]</code>
</p><p>
Synopsis (set log levels): <code>vespa-logctl [OPTION] &lt;service&gt;[:component-specification] &lt;level-mods&gt;</code>
</p><p>
<em>level-mods</em> are defined as :
  &lt;level&gt;=&lt;on|off&gt;[,&lt;level&gt;=&lt;on|off&gt;]...
</p><p>
<em>level</em> is one of:
<code>all</code>, <code>fatal</code>, <code>error</code>, <code>warning</code>,
<code>info</code>, <code>event</code>, <code>config</code>, <code>debug</code>, <code>spam</code>
</p><p>
Example: For service <code>container</code>, set <code>com.yahoo.search.searchchain</code>
and all subcomponents of <code>com.yahoo.search.searchchain</code> to enable all except spam and debug:
</p>
<pre>
$ vespa-logctl container:com.yahoo.search.searchchain all=on,spam=off,debug=off
</pre>
<table class="table">
  <thead>
  <tr>
    <th>Option</th>
    <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
      <th>-c</th>
      <td>Create the control file if it does not exist (implies -n)</td>
    </tr><tr>
      <th>-a</th>
      <td>Update all .logcontrol files</td>
    </tr><tr>
      <th>-r</th>
      <td>Reset to default levels</td>
    </tr><tr>
      <th>-n</th>
      <td>Create the component entry if it does not exist</td>
    </tr><tr>
      <th>-f <em>file</em></th>
      <td>Use &lt;file&gt; as the log control file</td>
    </tr><tr>
      <th>-d <em>dir</em></th>
      <td>Look in &lt;dir&gt; for log control files</td>
    </tr>
  </tbody>
</table>



<h2 id="vespa-logfmt">vespa-logfmt</h2>
<p>
<code>vespa-logfmt</code> reads Vespa log files, selects messages,
and writes a formatted version of these messages to standard output.
If no file argument is given, vespa-logfmt will read the last Vespa log
file <code>$VESPA_HOME/logs/vespa/vespa.log</code>
(this also works with the <code>-f</code> option).
Otherwise, reads only the files given as arguments.
To read standard input, supply a single dash ’-’ as a file argument.
Refer to the <a href="/en/reference/logs.html">logs reference</a>.
</p><p>
Synopsis: <code>
vespa-logfmt [-l levellist ] [-s fieldlist ] [-p pid ] [-S service ] [-H host ]
[-c regex ] [-m regex ] [-f ] [-N ] [-t ] [-ts ] [file &hellip;]</code>
</p><p>
Examples:
</p><p>
Display only messages with log level "event", printing a
human-readable time (without any fractional seconds),
the service generating the event and the event message:
</p>
<pre>
$ vespa-logfmt -l event -s fmttime,service,message
...
[2017-09-05 06:16:16] config-sentinel  stopped/1 name="sbin/vespa-config-sentinel -c hosts/vespa-container (pid 1558)" pid=1558 exitcode=1
[2017-09-05 06:16:16] config-sentinel  starting/1 name="sbin/vespa-config-sentinel -c hosts/vespa-container (pid 1564)"
[2017-09-05 06:16:16] config-sentinel  started/1 name="config-sentinel"
[2017-09-05 06:17:00] configserver     count/1 name=configserver.failedRequests value=0
[2017-09-05 06:17:00] configserver     count/1 name=procTime value=0
[2017-09-05 06:17:00] configserver     count/1 name=configserver.requests value=0
</pre>
<p>
Display messages with log levels that are <em>not</em> any of
<em>info, debug,</em> or <em>event,</em> printing the time in seconds
and microseconds, the log level, the component name, and the message text:
</p>
<pre>
$ vespa-logfmt -l all-info,-debug -s level -s time,usecs,component,message -t -l -event
...
1504592294.738000 WARNING : configproxy.com No config found for name=sentinel,namespace=cloud.config,configId=hosts/vespa-container within timeout, will retry
1504592296.388000 WARNING : configproxy.com Request callback failed: APPLICATION_NOT_LOADED. Connection spec: tcp/localhost:19070, error message: Failed request (No application exists) from Connection { Socket[addr=/127.0.0.1,port=37806,localport=19070] }
1504592307.949461 WARNING : config-sentinel Connection to tcp/localhost:19090 failed or timed out
1504592307.949587 WARNING : config-sentinel FRT Connection tcp/localhost:19090 suspended until 2017-09-05 06:19:07 GMT
</pre>
<table class="table">
  <thead>
  <tr>
    <th>Option</th>
    <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
      <th style="white-space:nowrap;">-l <em>levellist</em> (--level=<em>levellist</em>)</th>
      <td>
        Filter messages by log level. By default, only messages of
        level <em>fatal, error, warning</em>, and <em>info</em> will be
        included, while messages of level <em>config, event, debug</em>,
        and <em>spam</em> will be ignored. This option allows you to replace
        or modify the list of log levels to be included.
        <em>levellist</em> is a comma separated list of level names.
        <ul>
          <li>The name <em>all</em> may be used to add all known levels</li>
          <li>You may use + or - in front of terms to add or remove from the
            current (or default) list of levels instead of replacing it</li>
          <li>Adding term</li>
        </ul>
      </td>
    </tr><tr>
      <th>-s <em>fieldlist</em></th>
      <td>Select which fields of log messages to show.
        The output field order is fixed.
        When using this option, only the named fields will be printed.
        The default fields are as
        [<strong>-s fmttime,msecs,level,service,component,message</strong>].
        The fieldlist is a comma separated list of field names.
        The name <em>all</em> may be used to add all possible fields.
        Prepending a minus sign will turn off display of the named field.
        Starting the list with a plus sign will add and remove fields
        from the current (or default) list of fields instead of replacing it.
        Using this option several times works as if the given <em>fieldlist</em> arguments
        had been concatenated into one comma-separated list. Fields:
        <table class="table">
          <thead></thead><tbody>
            <tr>
              <th>time</th>
              <td>
                Print the time in seconds since the epoch.
                Ignored if <em>fmttime</em> is shown
              </td>
            </tr><tr>
              <th>fmttime</th>
              <td>
                Print the time in human-readable [YYYY-MM-DD HH:mm:ss] format.
                Note that the time is printed in the local timezone;
                to get GMT output, use <code>env TZ=GMT vespa-logfmt</code>
              </td>
            </tr><tr>
              <th>msecs</th>
              <td>
                Add milliseconds after the seconds in <em>time</em> and
                <em>fmttime</em> output. Ignored if <em>usecs</em> is in effect
              </td>
            </tr><tr>
              <th>usecs</th>
              <td>
                Add microseconds after the seconds in <em>time</em> and <em>fmttime</em> output
              </td>
            </tr><tr>
              <th>host</th>
              <td>
                Print the hostname field
              </td>
            </tr><tr>
              <th>level</th>
              <td>
                Print the level field (upper-cased)
              </td>
            </tr><tr>
              <th>pid</th>
              <td>
                Print the pid field
              </td>
            </tr><tr>
              <th>service</th>
              <td>
                Print the service field
              </td>
            </tr><tr>
              <th>component</th>
              <td>
                Print the component field
              </td>
            </tr><tr>
              <th>message</th>
              <td>
                Print the message text field. You probably always want to add this
              </td>
            </tr>
          </tbody>
        </table>
      </td>
    </tr><tr>
      <th>-p <em>pid</em></th>
      <td>
        Select messages where the pid field matches the <em>pid</em> string
      </td>
    </tr><tr>
      <th>-S <em>service</em></th>
      <td>
        Select messages where the service field matches the <em>service</em> string
      </td>
    </tr><tr>
      <th>-H <em>host</em></th>
      <td>
        Select messages where the hostname field matches the <em>host</em> string
      </td>
    </tr><tr>
      <th>-c <em>regex</em></th>
      <td>
        Select messages where the component field matches the <em>regex</em>,
        using <em>perlre</em> regular expression matching
      </td>
    </tr><tr>
      <th>-m <em>regex</em></th>
      <td>
        Select messages where the message text field matches the <em>regex</em>,
        using <em>perlre</em> regular expression matching
      </td>
    </tr><tr>
      <th>-f</th>
      <td>
        Invoke tail -F to follow input file
      </td>
    </tr><tr>
      <th>-N</th>
      <td>
        De-quote quoted newlines in the message text field to an actual newline plus tab
      </td>
    </tr><tr>
      <th>-t</th>
      <td>
        Format the component field (if shown) as a fixed-width string, truncating if necessary
      </td>
    </tr><tr>
      <th>-ts</th>
      <td>
        Format the service field (if shown) as a fixed-width string, truncating if necessary
      </td>
    </tr>
    </tr><tr>
      <th>-i, --internal</th>
      <td>
        Only include log entries emitted by the Vespa platform, i.e., exclude log entries from custom components
      </td>
    </tr>
  </tbody>
</table>



<!--h2 id="vespa-log-replay">vespa-log-replay</h2-->
<!--h2 id="vespa-malloc-parse-memorydump.pl">vespa-malloc-parse-memorydump.pl</h2-->



<h2 id="vespa-model-inspect">vespa-model-inspect</h2>
<p>
<em>vespa-model-inspect</em> is a tool for inspecting the topology and services of a Vespa system.
Hosts, services, clusters, ports, URLs and config ids can be inspected.
It can run on any machine in a Vespa cluster that is running a Vespa configuration server.
</p><p>
Synopsis: <code>vespa-model-inspect [-c host | host:port] [-t tag] [-h] [-u] [-v] command</code>
</p>
<table class="table">
  <thead>
  <tr>
    <th>Command</th>
    <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
      <th>hosts</th>
      <td>
        Show hostnames of all hosts in the Vespa system
      </td>
    </tr><tr>
      <th>services</th>
      <td>
        Show a list of all service types in the Vespa system
      </td>
    </tr><tr>
      <th>clusters</th>
      <td>
        Show a list of all named clusters in the Vespa system
      </td>
    </tr><tr>
      <th>configids</th>
      <td>
        Show a list of all config ids in the Vespa system
      </td>
    </tr><tr>
      <th>filter:ports</th>
      <td>
        List ports matching filter options
      </td>
    </tr><tr>
      <th>host <em>hostname</em></th>
      <td>
        Show host details: What services are running, and what ports have they allocated
      </td>
    </tr><tr>
      <th>service <em>servicetype</em></th>
      <td>
        Show service details: What instances of the service are running,
        on what hosts, and what ports have they allocated
      </td>
    </tr><tr>
      <th>cluster <em>clustername</em></th>
      <td>
        Show all services in the cluster, with details on hostname and allocated ports
      </td>
    </tr><tr>
      <th>configid <em>configid</em></th>
      <td>
        Show all services using this configid
      </td>
    </tr><tr>
      <th>get-index-of <em>servicetype</em> <em>host</em></th>
      <td>
        Show all indexes for instances of the service type on the given host
      </td>
    </tr>
  </tbody>
</table>
<table class="table">
  <thead>
  <tr>
    <th>Option</th>
    <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
      <th style="white-space:nowrap;">-c <em>host</em> | <em>host:port</em></th>
      <td>
        Specify host and port (or just host) to use for getting the config that this tool displays.
        Default is to use the configserver.
        You might want to use localhost:19090 if you are on a host with
        a running Vespa system without a config server
      </td>
    </tr><tr>
      <th>-h</th>
      <td>
        Show usage
      </td>
    </tr><tr>
      <th>-t <em>tag</em></th>
      <td>
        to filter on a port tag
      </td>
    </tr><tr>
      <th>-u</th>
      <td>
        Show URLs for services
      </td>
    </tr><tr>
      <th>-v</th>
      <td>
        Verbose mode
      </td>
    </tr>
  </tbody>
</table>
<p>Examples:</p>
<pre>
$ vespa-model-inspect hosts
mynode.mydomain.com

$ vespa-model-inspect services
config-sentinel
configproxy
configserver
container
container-clustercontroller
distributor
docprocservice
filedistributorservice
logd
logserver
searchnode
slobrok
storagenode

$ vespa-model-inspect -u service distributor
distributor @ myhost.mydomain.com : content
myapp/distributor/4
    tcp/myhost1.mydomain.com:19112 (MESSAGING)
    tcp/myhost1.mydomain.com:19113 (STATUS RPC)
    http://myhost1.mydomain.com:19114/ (STATE STATUS HTTP)
distributor @ myhost2.mydomain.com : content
myapp/distributor/5
    tcp/myhost2.mydomain.com:19112 (MESSAGING)
    tcp/myhost2.mydomain.com:19113 (STATUS RPC)
    http://myhost2.mydomain.com:19114/ (STATE STATUS HTTP)
distributor @ myhost3.mydomain.com : content
</pre>



<!--h2 id="vespa-ping-configproxy">vespa-ping-configproxy</h2-->



<h2 id="vespa-print-default">vespa-print-default</h2>
<p>
  Internal script used by other scripts to find hostname, config server addresses / ports, version and more.
  Not intended for end-user usage.
</p>



<h2 id="vespa-proton-cmd">vespa-proton-cmd</h2>
<p>
  Use <em>vespa-proton-cmd</em> to send commands to <a href="/en/proton.html">proton</a>.
</p>
<p>
  Synopsis: <code>vespa-proton-cmd HOSTSPEC COMMAND [ARGS]</code>
</p>
<p>
  The <em>hostspec</em> argument is one of <code>port|spec|--local|--id=name</code>.
  Use <a href="#vespa-model-inspect">vespa-model-inspect</a> to locate the search node ADMIN RPC port:
</p>
<pre>
$ vespa-model-inspect service searchnode
searchnode @ /mynode.myhost.com : search
music/search/cluster.music/0
    tcp/mynode.myhost.com:19108 (STATUS ADMIN RTC RPC)
    tcp/mynode.myhost.com:19109 (FS4)
    tcp/mynode.myhost.com:19110 (TEST HACK SRMP)
    tcp/mynode.myhost.com:19111 (ENGINES-PROVIDER RPC)
    tcp/mynode.myhost.com:19112 (STATE HEALTH JSON HTTP)
</pre>
<p>Example:</p>
<pre>
$ vespa-proton-cmd 19108 triggerFlush
  OK: flush trigger enabled
</pre>
<p>
  Unless the <strong>-h</strong> or <strong>--help</strong> option is used,
  one of these commands must be present:
</p>
<table class="table">
  <thead>
  <tr>
    <th>Command</th>
    <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
      <th>getProtonStatus</th>
      <td>
        Get the current proton state and its components.
      </td>
    </tr><tr>
      <th>getState</th>
      <td>
        Get the current proton state.
      </td>
    </tr><tr>
      <th>triggerFlush</th>
      <td>
        Trigger <a href="/en/proton.html#proton-maintenance-jobs">flush</a> as soon as possible for all document types.
      </td>
    </tr><tr>
      <th>prepareRestart</th>
      <td>
        Estimates the cost of <a href="/en/proton.html#transaction-log">transaction log</a> replay,
        and flushes data structures if that will speed up a subsequent start.
        If this is not called before stopping proton, there is no estimation and no flush.
      </td>
    </tr>
  </tbody>
</table>





<!--h2 id="vespa-ranking-expression-analyzer">vespa-ranking-expression-analyzer</h2-->



<h2 id="vespa-remove-index">vespa-remove-index</h2>
<p>
<em>vespa-remove-index</em> is a command line tool to remove index data on a Vespa search node,
by wiping out selected files and subdirectories found in <em>$VESPA_HOME/var/db/vespa/</em>.
This process is irreversible and the indexes deleted can not be recovered.
</p><p>
Stop <em>services</em> before running it - example:
</p>
<pre>
$ vespa-stop-services &amp;&amp; vespa-remove-index -force &amp;&amp; vespa-start-services
</pre>
<p>
Synopsis:<code>vespa-remove-index [-force] [-cluster name]</code>
</p><p>
Example:
</p>
<pre>
$ vespa-remove-index
[info] For cluster music distribution key 0 you have:
[info] 156 kilobytes of data in var/db/vespa/search/cluster.music/n0
Really to remove this vespa index? Type "yes" if you are sure ==> yes
[info] removing data:  rm -rf var/db/vespa/search/cluster.music/n0
[info] removed.
</pre>
<table class="table">
  <thead>
  <tr>
    <th>Option</th>
    <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
      <th>-force</th>
      <td>
        Do not require verification from the user before really removing index data
      </td>
    </tr><tr>
      <th>-cluster <em>name</em></th>
      <td>
        Only remove data for given cluster name
      </td>
    </tr>
  </tbody>
</table>



<h2 id="vespa-route">vespa-route</h2>
<p>
<em>vespa-route</em> is a tool to inspect Vespa routing configurations.
If file is set, it will be parsed as a feed
and the output will look similar to when using <a href="/en/reference/document-v1-api-reference.html">/document/v1/</a>
with trace enabled.
</p><p>
Synopsis: <code>vespa-route [options] [file]</code>
</p><p>
Example:
</p>
<pre>
$ vespa-route
There are 5 route(s):
    1. default
    2. music
    3. music-direct
    4. music-index
    5. storage/cluster.music

There are 2 hop(s):
    1. docproc/cluster.music.indexing/chain.indexing
    2. indexing
</pre>
<table class="table">
  <thead>
  <tr>
    <th>Option</th>
    <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
      <th>--documentmanagerconfigid &lt;id&gt;</th>
      <td>
        Sets the config id that supplies document configuration
      </td>
    </tr><tr>
      <th>--dump</th>
      <td>
        Prints the complete content of the routing table
      </td>
    </tr><tr>
      <th>--help</th>
      <td>
        Prints this help</td>
    </tr><tr>
      <th>--hop &lt;name&gt;</th>
      <td>
        Prints detailed information about hop &lt;name&gt;
      </td>
    </tr><tr>
      <th>--hops</th>
      <td>
        Prints a list of all available hops</td>
    </tr><tr>
      <th>--identity &lt;id&gt;</th>
      <td>
        Sets the identity of message bus</td>
    </tr><tr>
      <th>--listenport &lt;num&gt;</th>
      <td>
        Sets the port message bus will listen to</td>
    </tr><tr>
      <th>--oosserverpattern &lt;id&gt;</th>
      <td>
        Sets the out-of-service server pattern for message bus
      </td>
    </tr><tr>
      <th>--protocol &lt;name&gt;</th>
      <td>
        Sets the name of the protocol whose routing to inspect</td>
    </tr><tr>
      <th>--route &lt;name&gt;</th>
      <td>
        Prints detailed information about route &lt;name&gt;</td>
    </tr><tr>
      <th>--routes</th>
      <td>
        Prints a list of all available routes</td>
    </tr><tr>
      <th>--routingconfigid &lt;id&gt;</th>
      <td>
        Sets the config id that supplies the routing tables</td>
    </tr><tr>
      <th>--services</th>
      <td>
        Prints a list of all available services</td>
    </tr><tr>
      <th>--slobrokconfigid &lt;id&gt;</th>
      <td>
        Sets the config id that supplies the slobrok server list</td>
    </tr><tr>
      <th>--trace &lt;num&gt;</th>
      <td>
        Sets the trace level to use when visualizing route
      </td>
    </tr><tr>
      <th>--verify</th>
      <td>
        All hops and routes are verified when routing
      </td>
    </tr>
  </tbody>
</table>



<!--h2 id="vespa-rpc-info">vespa-rpc-info</h2-->



<!--h2 id="vespa-rpc-invoke">vespa-rpc-invoke</h2-->



<!--h2 id="vespa-rpc-proxy">vespa-rpc-proxy</h2-->



<h2 id="vespa-sentinel-cmd">vespa-sentinel-cmd</h2>
<p>
  Use <em>vespa-sentinel-cmd</em> to list, start and stop services -
  refer to <a href="/en/operations-selfhosted/config-sentinel.html">config sentinel</a> for examples.
  It can also check for connectivity between nodes.
</p>
{% include important.html content="
See <a href='/en/operations-selfhosted/admin-procedures.html#vespa-start-stop-restart'>start / stop / restart</a>
for how to stop all services on a node, optimizing for restart time -
use this for tasks like software upgrade." %}
<p>
  Synopsis: <code>vespa-sentinel-cmd [-h] list|start &lt;service&gt;|restart &lt;service&gt;|stop &lt;service&gt;|connectivity</code>
</p>
<table class="table">
  <thead>
  <tr>
    <th>Option</th>
    <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
      <th>-h</th><td>Help text</td>
    </tr>
  </tbody>
</table>
<table class="table">
  <thead>
  <tr>
    <th>Command</th>
    <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
      <th>list</th>
      <td>
        Lists the services running on this node and their status:
        <table class="table">
          <thead></thead><tbody>
        <tr>
          <th style="white-space: nowrap">service name</th><td></td>
        </tr>
        <tr>
          <th>state</th>
          <td>
            <ul>
              <li>RUNNING: Service is running</li>
              <li>FINISHED: Service has been stopped</li>
              <li>FAILED: Service has crashed and failed to restart</li>
              <li>TERMINATING: Service is stopping</li>
            </ul>
          </td>
        </tr>
        <tr>
          <th>mode</th>
          <td>
            <ul>
              <li>MANUAL: Service has to be started and stopped manually</li>
              <li>AUTO: Service will restart automatically if it stops</li>
            </ul>
          </td>
        </tr>
        <tr>
          <th>pid</th>
          <td>Pid of the process (main thread)</td>
        </tr>
        <tr>
          <th>exitstatus</th>
          <td>
            Exit code last time service stopped.
          </td>
        </tr>
        <tr>
          <th>id</th>
          <td><a href="/en/contributing/configapi-dev.html#config-id">Config ID</a> of the service</td>
        </tr>
        </tbody>
        </table>
      </td>
    </tr>
    <tr>
      <th style="white-space: nowrap">restart [name]</th>
      <td>
        Restarts the service with the given name.
        The name is the first string in the service list given by <code>list</code>
      </td>
    </tr>
    <tr>
      <th>stop [name]</th>
      <td>Stops the service with the given name</td>
    </tr>
    <tr>
      <th>start [name]</th>
      <td>
        Starts the service with the given name
      </td>
    </tr>
    <tr>
      <th>connectivity</th>
      <td>
        Use to troubleshoot startup issues / network configuration / ACLs / iptables:
<pre>
$ vespa-sentinel-cmd connectivity
vespa-sentinel-cmd 'connectivity' OK.
node0.vespanet -> ok
node1.vespanet -> ok
node2.vespanet -> ok
</pre>
      </td>
    </tr>
  </tbody>
</table>



<h2 id="vespa-set-node-state">vespa-set-node-state</h2>
<p>
Set the <a href="/en/reference/cluster-v2.html#state-user">user state</a> of a node.
This will set the generated state to the user state
if the user state is "better" than the generated state that would have been created
if the user state was up.
For instance, a node that is in <code>up</code> state can be forced into <code>down</code> state,
while a node that is currently <code>down</code> can not be forced into <code>retired</code> state,
but can be forced into maintenance state.
</p><p>
Synopsis: <code>vespa-set-node-state [options] up|down|maintenance|retired [description]</code>
</p><p>
Example:
</p>
<pre>
$ vespa-set-node-state -i 0 maintenance "Set to maintenance for software upgrade"
</pre>
<table class="table">
  <thead>
  <tr>
    <th>Option</th>
    <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
      <th>-h, --help</th>
      <td>
        Show help
      </td>
    </tr><tr>
      <th>-v</th>
      <td>
        More verbose output
      </td>
    </tr><tr>
      <th>-s</th>
      <td>
        Less verbose output
      </td>
    </tr><tr>
      <th>--show-hidden</th>
      <td>
        Also show hidden undocumented debug options
      </td>
    </tr><tr>
      <th>-n, --no-wait</th>
      <td>
        Do not wait for node state changes to be visible in the cluster before returning
      </td>
    </tr><tr>
      <th>-c, --cluster</th>
      <td>
        Cluster name of cluster to query.
        If unspecified, and vespa is installed on current node,
        information will be attempted auto-extracted
      </td>
    </tr><tr>
      <th>-f, --force</th>
      <td>
        Force execution
      </td>
    </tr><tr>
      <th>-t, --type</th>
      <td>
        Node type - can either be 'storage' or 'distributor'.
        If not specified, the operation will use state for both types
      </td>
    </tr><tr>
      <th>-i, --index</th>
      <td>
        Node index. If not specified,
        all nodes found running on this host will be used
      </td>
    </tr><tr>
      <th>--config-server</th>
      <td>
        Host name of config server to query
      </td>
    </tr><tr>
      <th>--config-server-port</th>
      <td>
        Port to connect to config server on
       </td>
    </tr><tr>
      <th>--config-request-timeout</th>
      <td>
        Timeout of config request
      </td>
    </tr>
  </tbody>
</table>



<!--h2 id="vespa-slobrok-cmd">vespa-slobrok-cmd</h2-->

<h2 id="vespa-significance">vespa-significance</h2>
<p>The <em>vespa-signficance</em> cli is a tool that generates a significance model <a href="../reference/significance-reference.html#significance-file-format">file</a>. Its input is a <a href="../reference/document-json-format.html"><em>vespa-feed</em></a> file. 
</p>
<p>Synopsis: <code>vespa-significance [options]</code></p>
<p>Example</p>
<pre>
$ vespa-significance --in vespa-dump.jsonl --out en_model.json --field text --language EN --doc-type "en"
</pre>
<table class="table">
  <thead>
  <tr>
    <th>Option</th>
    <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
      <th>-h, --help</th>
      <td>Help text</td>
    </tr>
    <tr>
      <th>-i, --in &lt;input file&gt;</th>
      <td>
        <a href="../reference/document-json-format.html">Vespa-feed</a>  file to be used for generating the significance model
      </td>
    </tr><tr>
      <th>-o, --out &lt;output file&gt;</th>
      <td>
        Output file for the significance model, with <a href="../significance.html#significance-file-format">this</a> JSON file format
      </td>
    </tr><tr>
      <th> -f, --field &lt;field&gt;</th>
      <td>
        Name of the text field to be used for significance model 
      </td>
    </tr><tr>
      <th> -l, --language &lt;language&gt;</th>
      <td>
        <p>
          Language of the text field, must be a valid language code from the <a href="https://www.rfc-editor.org/rfc/rfc5646">RFC5646</a> standard. 
        <br >
          It is used with
          OpenNLP's tokenizer to tokenize the text field based on that language's rules.
        </p>
      </td>
    </tr><tr>
      <th> -d, --doc-type &lt;doc-id&gt;</th>
      <td>
        <p>Document type identifier for the vespa dump file. <br>
          It becomes a part of the id for <a href="../reference/document-json-format.html#put">put</a> operations in the vespa-feed file. <code>&#123; "put": "id::&lt;doc-id&gt;::1" &#125; </code>
        </p>
      </td>
    </tr>
  </tbody>
</table>


<h2 id="vespa-start-configserver">vespa-start-configserver</h2>
<p>
  Start a config server on a node, <a href="/en/operations-selfhosted/admin-procedures.html#vespa-start-stop-restart">details</a>.
  See <a href="#vespa-start-services">vespa-start-services</a> for node setup steps, before startup.
</p>
<p>
  Synopsis: <code>vespa-start-configserver</code>
</p>



<h2 id="vespa-start-services">vespa-start-services</h2>
<p>
  Start all services on a node, <a href="/en/operations-selfhosted/admin-procedures.html#vespa-start-stop-restart">details</a>.
</p>
<p>
  As part of starting Vespa, the startup script calls
  <a href="https://github.com/vespa-engine/vespa/blob/master/vespabase/src/rhel-prestart.sh">rhel-prestart.sh</a>
  to set up directories and system limits - this requires privileges to do so -
  run this command with sudo,
  see <a href="/en/operations-selfhosted/multinode-systems.html#config-server-cluster-setup">example</a>.
  Refer to <a href="https://github.com/vespa-engine/vespa/blob/master/vespabase/src/vespa-start-services.sh">
  vespa-start-services.sh</a> and
  <a href="/en/operations-selfhosted/files-processes-and-ports.html#environment-variables">environment variables</a>.
</p>
<p>
  Synopsis: <code>vespa-start-services</code>
</p>
<p>
  When debugging a failed start, use <a href="#vespa-logfmt">vespa-logfmt</a> to inspect the log.
  It is also useful to read up on the <a href="/en/operations-selfhosted/configuration-server.html#start-sequence">
  start sequence</a> and make sure the config server is running - Vespa will not start with a running config server.
</p>
<p>
  Vespa has a <em>Safe Cluster Startup</em> mode to only start vespa services after X% of nodes are running -
  see <a href="/en/operations-selfhosted/config-sentinel.html#cluster-startup">cluster startup</a>.
</p>



<h2 id="vespa-stat">vespa-stat</h2>
<p>
<em>vespa-stat</em> is a tool to fetch statistics about a specific user, group, bucket, gid or document.
</p>
<p>
vespa-stat works in two stages.
The first stage is to figure out the actual buckets we want to look at.
In the second stage, it can dump the located buckets.
For each command line option, only the relevant documents will be dumped
(the document for <code>--document/--gid</code>, or the user/group's documents for <code>--user/--group</code>).
This stage can be turned on by adding <code>--dump</code>,
but is default on for the case of <code>--document/--gid</code>.
</p><p>
Synopsis: <code>vespa-stat [options]</code>
</p><p>
Example:
</p>
<pre>
$ vespa-stat --document id:my_namespace:my_search::12345678-4fb7-3797-ae9a-d4d7a4e6e085
Bucket maps to the following actual files:
	BucketInfo(BucketId(0x4000000000004800): [distributor:17] [node(idx=17,crc=0xe5ce35c7,docs=57/57,bytes=478040/478040,trusted=true,active=true,ready=true),  node(idx=15,crc=0xe5ce35c7,docs=57/57,bytes=478040/478040,trusted=true,active=true,ready=true)])

Details for BucketId(0x4000000000004800):
	Bucket information from node 15:
Persistence bucket BucketId(0x4000000000004800), partition 0
  Timestamp: 1452598747000000, Doc(id:my_namespace:my_search::12345678-4fb7-3797-ae9a-d4d7a4e6e085), gid(0x0048e840a48002b12abbb0a0), size: 101

	Bucket information from node 17:
Persistence bucket BucketId(0x4000000000004800), partition 0
  Timestamp: 1452598747000000, Doc(id:my_namespace:my_search::12345678-4fb7-3797-ae9a-d4d7a4e6e085), gid(0x0048e840a48002b12abbb0a0), size: 101
</pre>
<table class="table">
  <thead>
  <tr>
    <th>Option</th>
    <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
      <th>-b, --bucket &lt;bucketid&gt;</th>
      <td>
        Dump list of buckets that are contained in the given bucket, or that contain it
      </td>
    </tr><tr>
      <th> -d, --dump</th>
      <td>
        Dump list of documents for all buckets matching the selection command.
      </td>
    </tr><tr>
      <th>-g, --group &lt;groupid&gt;</th>
      <td>
          Dump list of buckets that can contain the given group
      </td>
    </tr><tr>
      <th>-h, --help</th>
      <td>
        Help text
      </td>
    </tr><tr>
      <th>-l, --gid &lt;globalid&gt;</th>
      <td>
        Dump information about one specific document, as given by the GID (implies --dump)
      </td>
    </tr><tr>
      <th>-o, --document &lt;docid&gt;</th>
      <td>
          Dump information about one specific document (implies --dump)
      </td>
    </tr><tr>
      <th> -r, --route &lt;route&gt;</th>
      <td>
          Route to send the messages to, usually the name of the storage cluster
      </td>
    </tr><tr>
      <th> -s, --bucketspace &lt;space&gt;</th>
      <td>
          <a href="/en/content/buckets.html#bucket-space">Bucket space</a>
          (<em>default</em> or <em>global</em>). If not specified, <em>default</em> is used
      </td>
    </tr><tr>
      <th> -u, --user &lt;userid&gt;</th>
      <td>
          Dump list of buckets that can contain the given user
      </td>
    </tr>
  </tbody>
</table>



<h2 id="vespa-status-filedistribution">vespa-status-filedistribution</h2>
<p>
  Use <em>vespa-status-filedistribution</em> to get status from file distribution.
  Should be run on a config server, it connects to config server on localhost to get status.
</p><p>
Synopsis: <code>vespa-status-filedistribution [--application &lt;applicationNameArg&gt;]
  [--debug] [--environment &lt;environmentArg&gt;] [(-h | --help)]
  [--instance &lt;instanceNameArg&gt;] [--region &lt;regionArg&gt;]
  [--tenant &lt;tenantNameArg&gt;] [--timeout &lt;timeoutArg&gt;]</code>
</p>
<table class="table">
  <thead>
  <tr>
    <th>Option</th>
    <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
      <th>--application &lt;applicationName&gt;</th>
      <td>
        Application name
      </td>
    </tr><tr>
      <th>--debug</th>
      <td>
        Print debug log
      </td>
    </tr><tr>
      <th>--environment &lt;environment&gt;</th>
      <td>
        Environment name
      </td>
    </tr><tr>
      <th>-h, --help</th>
      <td>
        Display help information
      </td>
    </tr><tr>
      <th>--instance &lt;instanceName&gt;</th>
      <td>
        Instance name
      </td>
    </tr><tr>
      <th>--region &lt;regionName&gt;</th>
      <td>
        Region name
      </td>
    </tr><tr>
      <th>--tenant &lt;tenantName&gt;</th>
      <td>
        Tenant name
      </td>
    </tr><tr>
      <th>--timeout &lt;timeout&gt;</th>
      <td>
        timeout (in seconds)
      </td>
    </tr>
  </tbody>
</table>



<h2 id="vespa-stop-configserver">vespa-stop-configserver</h2>
<p>
  Stop a config server on a node, <a href="/en/operations-selfhosted/admin-procedures.html#vespa-start-stop-restart">details</a>.
</p>
<p>
  Synopsis: <code>vespa-stop-configserver</code>
</p>



<h2 id="vespa-stop-services">vespa-stop-services</h2>
<p>
  Stop all services on a node, <a href="/en/operations-selfhosted/admin-procedures.html#vespa-start-stop-restart">details</a>.
  Running <em>vespa-stop-services</em> on a content node will call
  <a href="#vespa-proton-cmd">prepareRestart</a> to optimize restart time.
</p>
<p>
  Synopsis: <code>vespa-stop-services</code>
</p>



<h2 id="vespa-summary-benchmark">vespa-summary-benchmark</h2>
<p>
Tool for testing and benchmarking rpc docsum interface. Refer to
<a href="https://github.com/vespa-engine/vespa/blob/master/vespaclient-java/src/main/java/com/yahoo/vespasummarybenchmark/VespaSummaryBenchmark.java">
VespaSummaryBenchmark.java</a>
</p>



<!--h2 id="vespa-transactionlog-inspect">vespa-transactionlog-inspect</h2-->
<!--h2 id="vespa-treenet-converter">vespa-treenet-converter</h2-->
<!--h2 id="vespa-validate-application">vespa-validate-application</h2-->
<!--h2 id="vespa-verify-logdatastore">vespa-verify-logdatastore</h2-->
<!--h2 id="vespa-verify-ranksetup">vespa-verify-ranksetup</h2-->



<h2 id="vespa-visit">vespa-visit</h2>
<p>
  Used to run a <a href="../visiting.html">visit</a> operation,
  with more options than <a href="/en/vespa-cli.html">vespa visit</a>.
  It uses the <a href="/en/operations-selfhosted/routing.html">Vespa Message Bus</a> and must be run inside a Vespa application -
  it does not use the Vespa HTTP APIs.
</p>
{% include note.html content='This tool is easily confused with <code>vespa visit</code>
in the <a href="/en/vespa-cli.html">vespa CLI</a>.
The latter is the common tool for visiting, <code>vespa-visit</code> is built for debugging
and complex use cases.' %}
<p>
  By default, vespa-visit gets visited documents and emits to stdout.
  However, the tool may specify a <a href="#vespa-visit-target">vespa-visit-target</a>
  and be used as a tool to run reprocessing or migration.
  It supports keeping a progress file on disk,
  such that you can restart it if it should fail in the middle for some reason.
</p>
<p>
  To migrate a set of documents from one cluster to another, use <em>visiting</em> -
  as the data is transferred directly, using a compact
  serialization format, from the source nodes to the targets,
  this is performance optimal (data is not piped through the visit client).
  Implement backup this way, or dump to file.
</p><p>
  Search node recovery: Feed the documents directly to a search cluster.
  Example, selecting documents of type <em>music</em>:
</p>
<pre>
$ vespa-visit --selection music --datahandler indexing
</pre>
<p>
  This feeds from the source into the search cluster in the same application.
  Note that simultaneous feed can make updates go lost.
</p><p>
  Include <a href="/en/operations-selfhosted/admin-procedures.html#data-retention-vs-size">remove-entries</a>
  in the visit operation using <em>--visitremove</em> - this dumps the tombstones
  of documents recently removed.
</p><p>
  The <a href="/en/operations-selfhosted/routing.html/#content">content policy</a> can be configured to
  use a set of configuration servers from another cluster to configure
  itself. This is specified with the <em>config</em> parameter. As
  an example, the following route routes to the content cluster
  <em>mycluster</em> with a configuration server on
  <em>myconfigserver.mydomain.com:12345</em>:
<pre>
[Content:config=tcp/myconfigserver.mydomain.com:12345;cluster=mycluster]
</pre>
<p>
  The following examples illustrate how to copy all data from a source cluster to another cluster using vespa-visit:
</p>
<pre>
# Copies all data in the local cluster, routing it to the remote <em>mycluster</em>
$ vespa-visit --datahandler '[Content:config=tcp/myconfigserver.mydomain.com:12345;cluster=mycluster]'

# Limit to 'music' documents only
$ vespa-visit --datahandler '[Content:config=tcp/myconfigserver.mydomain.com:19070;cluster=mycluster]' \
  --selection music

# Limit to all documents for user '1234'
$ vespa-visit --datahandler '[Content:config=tcp/myconfigserver.mydomain.com:12345;cluster=mycluster]' \
  --selection id.user=1234
</pre>
<p>Visitor processor types:</p>
<table class="table">
  <thead>
  <tr><th>Processor Type</th><th>Description</th></tr>
  </thead><tbody>
<tr>
  <th>Dump visitor</th>
  <td>
    The most commonly used visitor processor type is the dump visitor.
    All it does is to send the read documents on to some external target
    specified by the visitor.
    Using the command line tool <em>vespa-visit</em>
    the default is to just send the documents back to the client,
    and have them printed to stdout.
    The dump visitor is used to implement reprocessing.
    Typically, using a messagebus route,
    that will send the documents through the document processing cluster
    and then back to the content cluster.
    Migration of documents from one cluster to another
    is also implemented using a dump visitor.
  </td>
</tr><tr>
  <th style="white-space: nowrap">Streaming search visitor</th>
  <td>
    The <a href="/en/streaming-search.html">streaming search</a> visitor runs in the Vespa container,
    making it transparent whether search results were created from streaming or indexed search -
    see <a href="/en/reference/services-content.html#document">indexing mode</a>.
  </td>
</tr>
</tbody>
</table>
<p>Requests sent from the visitor processor are sent to a visitor target - types:</p>
<table class="table">
  <thead>
  <tr><th>Target Type</th><th>Description</th></tr>
  </thead><tbody>
<tr>
  <th style="white-space: nowrap">Message bus routes</th>
  <td>
    You can specify a <a href="/en/operations-selfhosted/routing.html">message bus route</a> name directly,
    and this route will be used to send the results.
    This is typically used when doing reprocessing or migration.
    Message bus routes is set up in the application package.
    In addition, some routes may have been auto-generated in simple setups,
    for instance a route called <em>default</em> is generated
    if your setup is simple enough for the config model
    to likely guess where you want to send your data.
  </td>
</tr><tr>
  <th>Slobrok address</th>
  <td><p>
    You can also specify a slobrok address for data to be sent to.
    A slobrok address is a slash-separated path
    where you can use asterisk to mean any element within this path.
    For instance, if you have a docproc cluster called <em>mydpcluster</em>,
    it will have registered its nodes with slobrok names like
    <em>docproc/cluster.mydpcluster/docproc/0/feed_processor</em>,
    where the 0 here indicates the first node in the cluster.
    You can thus specify to send visit data to this docproc cluster
    by stating a slobrok address of <em>docproc/cluster.mydpcluster/docproc/*/feed_processor</em>.
    Note that this will not send all the data to one or all the nodes.
    The data sent from the visitor will be distributed among the matching nodes,
    but each message will just be sent to one node.
  </p><p>
    Slobrok names can be used when using
    <a href="#vespa-visit-target">vespa-visit-target</a>
    to retrieve the data at some location.
    If you start vespa-visit-target on two nodes,
    listening to slobrok names <em>mynode/0/visit-destination</em>
    and <em>mynode/1/visit-destination</em>,
    you can send the results to these nodes by specifying
    <em>mynode/*/visit-destination</em> as the data handler.
  </p><p>
    <a href="#vespa-destination">vespa-destination</a>
    is similar to vespa-visit-target in that it can receive messages
    from messagebus and print the contents to stdout.
    It can be useful in situations where you want to debug a route or a docproc,
    by using the vespadestination as the endpoint of your route.</p>
  </td>
</tr><tr>
  <th>TCP socket</th>
  <td>
    TCP sockets can also be specified directly.
    This requires that the endpoint speaks FNET RPC.
    This is typically done, either by using the <em>vespa-visit-target</em> tool,
    or by using a visitor destination programmatically by using utility class in the document API.
    A socket address looks like the following:
    tcp/<em>hostname</em>:<em>port</em>/<em>servicename</em>.
    For instance, an address generated by <em>vespa-visit-target</em>
    might look like: <em>tcp/myhost.mydomain.com:12345/visit-destination</em>
  </td>
</tr>
</tbody>
</table>
<p>Also see <a href="#vespa-destination">vespa-destination</a>.</p>
<p>Synopsis: <code>vespa-visit [options]</code></p>
<table class="table">
  <thead>
  <tr>
    <th>Option</th>
    <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
      <th style="width:300px">--abortonclusterdown</th>
      <td>Abort if cluster is down</td>
    </tr><tr>
      <th>-b, --maxbuckets &lt;num&gt;</th>
      <td>Maximum buckets per visitor</td>
    </tr><tr>
      <th>--bucketspace &lt;space&gt;</th>
      <td>
        <a href="/en/content/buckets.html#bucket-space">Bucket space</a> to visit
        (<em>default</em> or <em>global</em>). If not specified, <em>default</em> is used
      </td>
    </tr><tr>
      <th>-c, --cluster &lt;cluster&gt;</th>
      <td>Visit the given cluster</td>
    </tr><tr>
      <th>-d, --datahandler &lt;target&gt;</th>
      <td>Send results to the given target - see <a href="#vespa-visit-target">vespa-visit-target</a></td>
    </tr><tr>
      <th>-f, --from &lt;timestamp&gt;</th>
      <td>Only visit from the given timestamp (microseconds)</td>
    </tr><tr>
      <th>-h, --help</th>
      <td>Show help text</td>
    </tr><tr>
      <th>-i, --printids</th>
      <td>Display only document identifiers</td>
    </tr><tr>
      <th>--jsonoutput</th>
      <td>Output a JSON array of document objects. This is the default output format.</td>
    </tr><tr>
      <th>--jsonl</th>
      <td>Output documents as JSONL (JSON Lines format). Each individual document is output as a single line,
          with a newline separating each document. Lines are not comma separated, and there is no top-level
          array wrapping the document objects.
      </td>
    </tr><tr>
      <th>-l, --fieldset &lt;fieldset&gt;</th>
      <td>
        Retrieve the specified fields only
        (see <a href="/en/documents.html#fieldsets">Document field sets</a>).
        Default: <code>[document]</code>
      </td>
    </tr><tr>
      <th>--libraryparam &lt;key&gt; &lt;val&gt;</th>
      <td>Send parameter to the visitor library</td>
    </tr><tr>
      <th>-m, --maxpending &lt;num&gt;</th>
      <td>Maximum pending messages to data handlers per storage visitor</td>
    </tr><tr>
      <th>--maxpendingsuperbuckets &lt;num&gt;</th>
      <td>
        Maximum pending visitor messages from the vespa-visit client.
        If set, dynamic throttling of visitors is disabled <!-- ToDo: link to somewhere documenting throttling -->
      </td>
    </tr><tr>
      <th>--maxtotalhits &lt;num&gt;</th>
      <td>
        Abort visiting when received this many total documents.
        This is only an approximate number,
        all pending work will be completed and those documents will also be returned
      </td>
    </tr><tr>
      <th>-o, --timeout &lt;milliseconds&gt;</th>
      <td>Time out visitor after given time</td>
    </tr><tr>
        <th>-p, --progress &lt;file&gt;</th>
      <td>
        Use given file to track progress.
        <code>-p progress-file</code> saves progress, allowing the visitor to resume at next startup.
        Always remove the progress file to run the visiting operation from the start.
      </td>
    </tr><tr>
      <th>--processtime &lt;num&gt;</th>
      <td>
        Sleep this amount of milliseconds before processing message.
        (Debug option for pretending to be slow client)
      </td>
    </tr><tr>
      <th>-r, --visitremoves</th>
      <td>
        Return tombstone entries of documents that have been removed.
        Tombstones will be output as <code>remove</code> objects which only contain a document ID.
        When using <code>--visitremoves</code> regular (non-tombstone) documents will also be returned.
      </td>
    </tr><tr>
      <th>-s, --selection &lt;selection&gt;</th>
      <td>
        <p>
          <a href="/en/reference/document-select-language.html">Selection</a> string for which documents to visit.
          E.g., <code>-s 'id.hash().abs() % 100 == 0'</code> dumps 1% of the corpus -
          see <a href="../visiting.html#selection">selection</a>.
          Note that this expression is evaluated for <em>every</em> document in the cluster, so running 100
          visits comparing against all values in [0, 99) ends up reading all documents 100 times. Prefer
          using <code>--slices</code> and <code>--sliceid</code> instead if available.
        </p>
      </td>
    </tr><tr>
      <th>--shorttensors</th>
      <td>Output using <a href="/en/reference/document-json-format.html#tensor">tensor short form</a></td>
    </tr><tr>
      <th>--skipbucketsonfatalerrors</th>
      <td>Skip visiting super buckets with fatal error codes</td>
    </tr><tr>
      <th>--sliceid &lt;arg&gt;</th>
      <td>
        The slice number of the visit represented by this visitor.
        This number must be non-negative and less than the number of slices specified for the visit.
      </td>
    </tr><tr>
      <th>--slices &lt;arg&gt;</th>
      <td>
        <p>
          Split the document corpus into this number of independent slices.
          This lets multiple, concurrent series of visitors advance the same logical visit independently,
          by specifying a different <code>sliceid</code> for each.
        </p>
        <p>
          E.g. <code>--slices 100 --sliceid 0</code> dumps 1% of the corpus by efficiently iterating
          over only 1/100th of the data space. For a given number of <code>--slices</code>, it's
          possible to visit the entire corpus (possibly in parallel) with non-overlapping output
          by visiting with all <code>--sliceid</code> values from (and including) 0 up to (and excluding)
          <code>--slices</code>.
        </p>
      </td>
    </tr><tr>
      <th>-t, --to &lt;timestamp&gt;</th>
      <td>Only visit up to the given timestamp (microseconds)</td>
    </tr><tr>
      <th>--tracelevel &lt;level&gt;</th>
      <td>Tracelevel ([0-9]), for debugging</td>
    </tr><tr>
      <th>-u, --buckettimeout &lt;milliseconds&gt;</th>
      <td>Fail visitor if visiting a single bucket takes longer than this (default same as timeout)</td>
    </tr><tr>
      <th>-v, --verbose</th>
      <td>Show progress and info on STDERR</td>
    </tr><tr>
      <th>--visitinconsistentbuckets</th>
      <td>
        <p id="visitinconsistentbuckets">
          Don't wait for inconsistent buckets to become consistent.
          See <a href="/en/content/consistency.html#read-consistency">read-consistency</a> for details.
        </p>
      </td>
    </tr><tr>
      <th>--visitlibrary &lt;string&gt;</th>
      <td>Use the given visitor library</td>
    </tr>
  </tbody>
</table>



<h2 id="vespa-visit-target">vespa-visit-target</h2>
<p>
  <a href="#vespa-visit-target">vespa-visit-target</a>
  is a tool to set up an endpoint for <a href="/en/visiting.html">visiting</a> data.
  It binds to a socket or to a slobrok address,
  which is specified as a target in the visit client.
  Also see <a href="#vespa-destination">vespa-destination</a>.
</p>
<p>
Synopsis: <code>vespa-visit-target [options]</code>
</p>
<table class="table">
  <thead>
  <tr>
    <th>Option</th>
    <th>Description</th>
  </tr>
  </thead>
  <tbody>
    <tr>
      <th style="width:300px">-c, --visithandler &lt;classname&gt;</th>
      <td>Use the given class as a visit handler (defaults to StdOutVisitorHandler)</td>
    </tr><tr>
      <th style="width:300px">-h, --help</th>
      <td>Show help page</td>
    </tr><tr>
      <th style="width:300px">-i, --printids</th>
      <td>Display document IDs only</td>
    </tr><tr>
      <th style="width:300px">-o, --visitoptions &lt;args&gt;</th>
      <td>Option arguments to pass through to the visitor handler instance</td>
    </tr><tr>
      <th style="width:300px">-p, --processtime &lt;msecs&gt;</th>
      <td>Sleep msecs milliseconds before processing message.
        (Debug option for pretending to be slow client)</td>
    </tr><tr>
      <th style="width:300px">-s, --bindtoslobrok &lt;address&gt;</th>
      <td>Bind to slobrok address.
        One, and only one, of the binding options must be set</td>
    </tr><tr>
      <th style="width:300px">-t, --bindtosocket &lt;port&gt;</th>
      <td>Bind to TCP port.
        One, and only one, of the binding options must be set</td>
    </tr><tr>
      <th style="width:300px">-v, --verbose</th>
      <td>Indent output, show progress and info on STDERR</td>
    </tr>
  </tbody>
</table>
