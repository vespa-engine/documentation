---
# Copyright Vespa.ai. All rights reserved.
title: "Querying"
---

<p>An introduction to querying with Vespa.</p>


<h2 id="queries">Queries</h2>

<p>Queries in Vespa are expressed as a YQL string: A query language identical to SQL for structured data,
with additions for vector and full-text search, for example:</p>

<pre>
select * from mySchema where myTextField contains 'someWord' and myNumber > 10.0
</pre>

<p>You can also search multiple fields at the same time, by defining
<a href="reference/schema-reference.html#fieldset">fieldset</a> in the schema.</p>

<p>Any nested combination of and/or and so on is supported, see the full syntax in the
<a href="reference/query-language-reference.html">query language reference</a>.</p>


<h2 id="query-requests">Query requests</h2>

<p>Queries are sent as HTTP requests, to the endpoint of a container cluster having &lt;search&gt; in services.xml.
The YQL query is sent as the <code>yql</code> parameter (HTTP Encoded):

<pre>
endpoint-url/search/?yql=select+%2A+from+sources+%2A+where+true
</pre>

<p>The Vespa CLI can do this for you:</p>

<pre>
vespa query "select * from sources * where true"
</pre>

<p>You can add the <code>-v</code> option to see the HTTP request that this becomes.</p>

<p>You can also send the query parameters
<a href="query-api.html#http">as a JSON payload</a> instead of as request parameters:</p>

<pre>
$ curl -H "Content-Type: application/json" \
--data '{"yql" : "select * from sources * where true"}' \
endpoint-url/search/
</pre>


<h2 id="query-request-parameters">Query request parameters</h2>

<p>In addition to the YQL parameter, you can send other query request parameters
to supply data such as user/llm query text, vectors, and parameters controlling the query execution.
These are added to HTTP requests in the obvious way, and passed to Vespa CLI by adding multiple arguments:

<pre>
vespa query -v "select * from sources * where true" "timeout=100ms"
</pre>

<p>To see all the parameters accepted, see the <a href="reference/query-api-reference.html">query API reference</a>.</p>

<p>You may end up wanting to set many query parameters in your queries. Instead of passing them in the request,
you can create a query profile in the application package containing all the parameters and just specify
the profile in the request, see <a href="query-profiles.html">query profiles</a>.</p>


<h2 id="querying-with-text">Querying with text</h2>

<p>You often want to send text directly from users or language models to Vespa to retrieve/rank by full-text match.
Such text can be inserted into a YQL query using the <code>userInput</code> parameter. This will process the text
and (by default) search it using the <a href="using-wand-with-vespa.html#weakand">WeakAnd</a> text search operator.</p>

<p>You can pass the text directly, or refer to a separate request parameter (using <code>@parameter</code>):</p>

<pre>{% raw %}
$ vespa query "select * from sources * where myNumber > 10.0 and userInput(@query)" \
  "query=Some text, from a user/llm"
{% endraw %}</pre>

<p>You can set options controlling how the user input is to be parsed and executed, see
the <a href="reference/query-language-reference.html#userinput">userInput reference documentation</a>.


<h2 id="querying-with-vectors">Querying with vectors</h2>

<p>Querying by vectors is done using the nearestNeighbor YQL operator, which takes a document and query vector:</p>

<pre>{% raw %}
$ vespa query 'select * from sources *  where {targetHits: 3}nearestNeighbor(my_vector_field, my_query_vector)' \
  ranking=my_rank_profile \
  'input.query(my_query_vector)'='[1,2,3]'
{% endraw %}</pre>

<p>Read more in <a href="nearest-neighbor-search">nearest neighbor search</a>.</p>

<p>You can combine multiple nearestNeighbor, userInput and other parameters in any way:</p>

<pre>{% raw %}
$ vespa query "select * from sources * where (({targetHits: 10}nearestNeighbor(my_title_embedding, my_query_vector)) \
                                              or ({targetHits: 10}nearestNeighbor(my_body_embeddings, my_query_vector)) \
                                              or userInput(@query) or ({defaultIndex:'ngramFields'}userInput(@query))) \
                                             and range(title, 0.0, 500.0) and category in ('c1', 'c2') \
                                             and ! blacklisted=true" \
  "input.query(my_query_vector)=embed(@query)" \
  "query=Hello, world! "

{% endraw %}</pre>

