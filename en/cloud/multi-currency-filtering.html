---
# Copyright Vespa.ai. All rights reserved.
title: Multi-Currency Pricing
category: cloud
---

<p>
  Vespa Cloud includes multi-currency pricing support
  for e-commerce applications with global product catalogs
  where products are priced in different currencies and sold across multiple markets.
  This enables filtering by price range in any currency and using converted prices in ranking,
  with automatic currency conversion when market-specific pricing is not available.
</p>


<h2 id="overview">Overview</h2>
<p>
  The multi-currency pricing feature supports:
</p>
<ul>
  <li><strong>Per-market pricing</strong> - Define different prices for different markets on each product</li>
  <li><strong>Keeping track of exchange rates</strong> - An N×N mapping of currency-to-currency exchange rates is stored in a "forex" document, and can be updated at any time.</li>
  <li><strong>Automatic currency conversion</strong> - Fallback to forex rates when no market-specific price exists</li>
  <li><strong>Query-time filtering</strong> - Filter products by price range in any currency</li>
  <li><strong>Ranking integration</strong> - Optional exposure of forex rates for use in ranking expressions (ranking on the computed price)</li>
</ul>

<p>
  The implementation consists of two key components:
</p>
<ul>
  <li><strong>ForexCache</strong> - A background service that refreshes exchange rates from the forex document</li>
  <li><strong>MultiCurrencyFilterSearcher</strong> - A custom searcher that intercepts queries and dynamically filters products based on effective prices</li>
</ul>



<h2 id="quick-start">Quick Start</h2>

<h3 id="define-schemas">Define Schemas</h3>
<p>
  Create two schemas: one to store the forex rates, and one for products.
</p>

<h4 id="forex-schema">Forex Schema</h4>
<p>
  The forex schema stores currency exchange rates as a tensor:
</p>

<pre>{% highlight xml %}
schema forex {
    document forex {
        field timestamp type long {
            indexing: attribute | summary
        }

        field rates type tensor<double>(from{}, to{}) {
            indexing: attribute | summary
        }
    }
}
{% endhighlight %}</pre>

<h4 id="product-schema">Product Schema</h4>
<p>
  The product schema stores products with their seller currency and per-market prices.
  The <code>per_market_price</code> array contains price overrides for specific markets,
  with a <code>DEFAULT</code> market used as fallback.
</p>

<pre>{% highlight xml %}
schema product {
    document product {
        field product_id type string {
            indexing: summary | attribute
        }

        field product_name type string {
            indexing: summary | index
        }

        field seller_currency type string {
            indexing: summary | attribute
        }

        struct market_price {
            field market type string {}
            field price type double {}
        }

        field per_market_price type array<market_price> {
            indexing: summary
            summary: matched-elements-only
            struct-field market {
                indexing: attribute
            }
            struct-field price {
                indexing: attribute
            }
        }
    }
}
{% endhighlight %}</pre>


<h3 id="configure-services">Configure Services</h3>
<p>
  Add the multi-currency components and search chain to your <code>services.xml</code>:
</p>

<pre>{% highlight xml %}
<container id="default" version="1.0">
    <search>
        <chain id="multi-currency-filter" inherits="vespa">
            <searcher id="ai.vespa.ecommerce.multicurrency.MultiCurrencyFilterSearcher"
                      bundle="ecommerce-multi-currency" />
        </chain>
    </search>

    <component id="ai.vespa.ecommerce.multicurrency.ForexRateService"
               class="ai.vespa.ecommerce.multicurrency.CachedForexRateService"
               bundle="ecommerce-multi-currency" />

    <component id="ai.vespa.ecommerce.multicurrency.ForexRateRetriever"
               bundle="ecommerce-multi-currency" />
</container>

<content id="content" version="1.0">
    <documents>
        <document type="forex" mode="index" />
        <document type="product" mode="index" />
    </documents>
    <nodes count="2" />
</content>
{% endhighlight %}</pre>


<h3 id="feed-data">Feed Data</h3>

<h4 id="feed-forex-rates">Feed Forex Rates</h4>
<p>
  Feed a single forex document with ID <code>id:forex:forex::forex</code> containing all currency-to-currency exchange rates.
  Include identity rates (e.g., USD→USD = 1.0) to avoid missing-cell lookups.
  The <code>timestamp</code> field is required and must be updated with each rate change to ensure the cache picks up new rates.
</p>

<pre>{% highlight json %}
{
  "put": "id:forex:forex::forex",
  "fields": {
    "timestamp": 1757385600,
    "rates": {
      "cells": [
        {"address": {"from": "USD", "to": "USD"}, "value": 1.0},
        {"address": {"from": "USD", "to": "EUR"}, "value": 0.92},
        {"address": {"from": "USD", "to": "GBP"}, "value": 0.78},
        {"address": {"from": "USD", "to": "NOK"}, "value": 10.50},
        {"address": {"from": "EUR", "to": "USD"}, "value": 1.09},
        {"address": {"from": "EUR", "to": "EUR"}, "value": 1.0},
        {"address": {"from": "EUR", "to": "GBP"}, "value": 0.85}
      ]
    }
  }
}
{% endhighlight %}</pre>

<h4 id="feed-products">Feed Products</h4>
<p>
  Feed products with their seller currency and per-market prices. Always include a <code>DEFAULT</code> market
  entry as fallback.
</p>

<pre>{% highlight json %}
{
  "put": "id:product:product::sku-100",
  "fields": {
    "product_id": "sku-100",
    "product_name": "Wireless Headphones",
    "seller_currency": "USD",
    "per_market_price": [
      {"market": "DEFAULT", "price": 199.0},
      {"market": "EU", "price": 189.0},
      {"market": "UK", "price": 209.0},
      {"market": "NO", "price": 300.0}
    ]
  }
}
{% endhighlight %}</pre>


<h3 id="query-with-price-filtering">Query with Price Filtering</h3>
<p>
  Use the following query parameters to filter products by price range in a specific market and currency:
</p>

<table class="table">
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Description</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>ecommerce.multicurrency.market</code></td>
      <td>Target market code</td>
      <td><code>NO</code>, <code>US</code>, <code>EU</code></td>
    </tr>
    <tr>
      <td><code>ecommerce.multicurrency.currency</code></td>
      <td>Target currency code</td>
      <td><code>NOK</code>, <code>USD</code>, <code>EUR</code></td>
    </tr>
    <tr>
      <td><code>ecommerce.multicurrency.price-min</code></td>
      <td>Minimum price in target currency</td>
      <td><code>1000</code></td>
    </tr>
    <tr>
      <td><code>ecommerce.multicurrency.price-max</code></td>
      <td>Maximum price in target currency</td>
      <td><code>1500</code></td>
    </tr>
    <tr>
      <td><code>ecommerce.multicurrency.enrich</code></td>
      <td>Optional: expose forex rates as query tensor for ranking</td>
      <td><code>true</code> or <code>false</code></td>
    </tr>
  </tbody>
</table>

<h4 id="example-query">Example Query</h4>
<pre>{% highlight sh %}
$ vespa query \
    'yql=select * from product where true' \
    'searchChain=multi-currency-filter' \
    'ecommerce.multicurrency.market=NO' \
    'ecommerce.multicurrency.currency=NOK' \
    'ecommerce.multicurrency.price-min=1000' \
    'ecommerce.multicurrency.price-max=1500'
{% endhighlight %}</pre>

<p>
  This query returns all products whose effective price in NOK (Norwegian Krone) for the Norwegian market
  is between 1000 and 1500 NOK. The searcher will:
</p>
<ol>
  <li>Check if the product has a market-specific price for <code>NO</code></li>
  <li>If yes, use that price directly</li>
  <li>If no, convert the product's <code>DEFAULT</code> market price from the seller currency to NOK using forex rates</li>
  <li>Keep only products within the specified price range</li>
</ol>


<h3 id="validation-rules">Validation Rules</h3>
<p>
  The multi-currency searcher validates query parameters and returns an error if validation fails:
</p>
<ul>
  <li><strong>Currency codes</strong> must be exactly 3 letters (ISO-4217 format, e.g., <code>USD</code>, <code>EUR</code>, <code>NOK</code>)</li>
  <li><strong>Market codes</strong> must be alphanumeric (e.g., <code>US</code>, <code>NO</code>, <code>EU</code>)</li>
  <li><strong>Price values</strong> must be valid numbers and non-negative</li>
  <li><strong>Price range</strong>: <code>price-max</code> must be greater than or equal to <code>price-min</code></li>
  <li><strong>Currency availability</strong>: The requested currency must exist in the forex document</li>
</ul>

<p>
  If any parameter is missing or invalid, the searcher will either skip filtering (for format issues)
  or return an error result (for logical issues like invalid price ranges or unknown currencies).
</p>


<h3 id="updating-forex-rates">Updating Forex Rates</h3>
<p>
  Forex rates can be updated at any time by feeding a new version of the forex document
  with an updated <code>timestamp</code> field. The cache will automatically pick up the new rates
  on its next refresh cycle (typically within seconds).
</p>

<pre>{% highlight sh %}
$ vespa feed <(echo '{
    "update": "id:forex:forex::forex",
    "fields": {
        "timestamp": {"assign": 1757472000},
        "rates": {
            "assign": {
                "cells": [...]
            }
        }
    }
}')
{% endhighlight %}</pre>



<h2 id="how-it-works">How It Works</h2>

<h3 id="price-resolution-logic">Price Resolution Logic</h3>
<p>
  For each product, the effective price in the target currency is determined as follows:
</p>
<ol>
  <li><strong>Market-specific price:</strong> If the product has a price entry for the requested market, use that price directly</li>
  <li><strong>Currency conversion:</strong> Otherwise, use the <code>DEFAULT</code> market price and convert it from the seller currency to the target currency using forex rates</li>
  <li><strong>Price range filter:</strong> Keep only products whose effective price falls within the specified min/max range</li>
</ol>

<h3 id="forex-cache">Forex Cache</h3>
<p>
  The <code>CachedForexRateService</code> component maintains an in-memory cache of exchange rates
  and refreshes them periodically from the forex document (<code>id:forex:forex::forex</code>).
  This ensures low-latency access to forex rates during query processing.
</p>

<h4 id="automatic-refresh">Automatic Refresh</h4>
<p>
  The <code>ForexRateRetriever</code> component automatically refreshes forex rates every 10 seconds.
  The refresh process:
</p>
<ul>
  <li>Queries the forex document using the <code>forex-cache</code> search chain</li>
  <li>Validates the document has both <code>rates</code> (tensor) and <code>timestamp</code> (long) fields</li>
  <li>Only applies updates if the timestamp is newer than the cached version</li>
  <li>Retries within a 5-second budget if the first attempt fails</li>
</ul>

<h4 id="health-states">Health States</h4>
<p>
  The forex service tracks its operational status with the following health states:
</p>
<table class="table">
  <thead>
    <tr>
      <th>State</th>
      <th>Description</th>
      <th>Query Behavior</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>READY</code></td>
      <td>Forex rates loaded and service is operational</td>
      <td>Queries with multi-currency filtering work normally</td>
    </tr>
    <tr>
      <td><code>UNINITIALIZED</code></td>
      <td>No forex document has been loaded yet</td>
      <td>Queries return error: "forex rate service not initialized"</td>
    </tr>
    <tr>
      <td><code>OUTAGE</code></td>
      <td>Refresh failed but stale data exists</td>
      <td>Queries continue using cached rates (may be outdated)</td>
    </tr>
    <tr>
      <td><code>INVALID_FOREX_DOCUMENTS</code></td>
      <td>Multiple forex documents detected (expected exactly one)</td>
      <td>Queries return error: "ensure exactly one forex document exists"</td>
    </tr>
  </tbody>
</table>

<h4 id="error-handling">Error Handling</h4>
<p>
  When the service is not in <code>READY</code> state, queries with multi-currency filtering will:
</p>
<ul>
  <li>Return an empty result with an appropriate error message</li>
  <li>Log detailed diagnostic information at appropriate trace levels</li>
  <li>Continue retrying background refresh attempts until successful</li>
</ul>

<h3 id="performance">Performance</h3>
<p>
  Multi-currency price filtering is implemented as efficient query-time filter construction,
  not result-time evaluation. This means Vespa can use its indexes to find matching products
  without iterating through all documents.
</p>

<h4 id="how-filtering-works">How Filtering Works</h4>
<p>
  When a query with multi-currency parameters is received, the searcher:
</p>
<ol>
  <li><strong>Pre-computes price ranges:</strong> Converts the buyer's price range (e.g., 1000-1500 NOK)
      into equivalent ranges for every seller currency using cached forex rates.
      For example, if the forex cache has USD, EUR, and GBP, it computes what 1000-1500 NOK equals in each currency.</li>
  <li><strong>Builds structured query filters:</strong> Creates a query tree using Vespa's efficient query primitives:
    <ul>
      <li><code>SameElementItem</code> - Matches documents where market and price appear in the same array element</li>
      <li><code>RangeItem</code> - Efficiently filters on numeric price ranges using indexes</li>
      <li><code>WordItem</code> - Matches exact seller currency and market values</li>
    </ul>
  </li>
  <li><strong>Injects filter into query tree:</strong> Combines the price filter with the user's query,
      allowing Vespa's query execution engine to evaluate it efficiently using indexes.</li>
</ol>

<p>
  This approach has several performance benefits:
</p>
<ul>
  <li><strong>No document iteration:</strong> Vespa uses attribute indexes to quickly identify matching documents
      without fetching and evaluating all products</li>
  <li><strong>One-time conversion:</strong> Currency conversion happens once during query construction,
      not for every product in the result set</li>
  <li><strong>Index-backed filtering:</strong> Price range and market matching leverage Vespa's fast attribute lookups</li>
  <li><strong>Query optimization:</strong> Vespa's query optimizer can reorder and optimize the combined query tree
      for efficient execution</li>
</ul>

<h2 id="advanced-usage">Advanced Usage</h2>

<h3 id="custom-field-configuration">Custom Field Configuration</h3>
<p>
  By default, the multi-currency components expect specific field names in your product schema.
  You can customize these field names using the <code>product-schema-wiring</code> configuration.
</p>

<pre>{% highlight xml %}
<container id="default" version="1.0">
    <search>
        <chain id="multi-currency-filter" inherits="vespa">
            <searcher id="ai.vespa.ecommerce.multicurrency.MultiCurrencyFilterSearcher"
                      bundle="ecommerce-multi-currency">
                <config name="ai.vespa.ecommerce.multicurrency.product-schema-wiring">
                    <productFields>
                        <sellerCurrency>seller_currency</sellerCurrency>
                        <perMarketPriceArrayStruct>per_market_price</perMarketPriceArrayStruct>
                        <marketStructField>market</marketStructField>
                        <priceStructField>price</priceStructField>
                    </productFields>
                    <defaults>
                        <market>DEFAULT</market>
                    </defaults>
                    <rankProfileInputs>
                        <forexRates>forexRates</forexRates>
                    </rankProfileInputs>
                </config>
            </searcher>
        </chain>
    </search>
</container>
{% endhighlight %}</pre>

<p>
  Configuration parameters:
</p>
<ul>
  <li><code>productFields.sellerCurrency</code> - Field name for the product's seller currency (default: <code>seller_currency</code>)</li>
  <li><code>productFields.perMarketPriceArrayStruct</code> - Array field name containing per-market prices (default: <code>per_market_price</code>)</li>
  <li><code>productFields.marketStructField</code> - Struct field name for market code (default: <code>market</code>)</li>
  <li><code>productFields.priceStructField</code> - Struct field name for price value (default: <code>price</code>)</li>
  <li><code>defaults.market</code> - Default market identifier used as fallback (default: <code>DEFAULT</code>)</li>
  <li><code>rankProfileInputs.forexRates</code> - Query tensor name for forex rates in ranking (default: <code>forexRates</code>)</li>
</ul>


<h3 id="using-forex-in-ranking">Using Forex Rates in Ranking</h3>
<p>
  When <code>ecommerce.multicurrency.enrich=true</code> is set, the searcher exposes the forex rates
  as a query tensor <code>query(forexRates)</code> that can be used in ranking expressions.
  The ranking profile should implement the same fallback logic as the searcher: check for market-specific prices first,
  then fall back to the DEFAULT market price, and convert to the buyer's currency.
</p>

<pre>{% highlight xml %}
rank-profile price_ranking {
    inputs {
        query(forexRates) tensor<double>(from{}, to{})
        query(buyer_currency) tensor<double>(to{})
        query(buyer_market) tensor<double>(market{})
    }

    function from_selector() {
        expression: tensorFromLabels(attribute(seller_currency), from)
    }

    function buyer_rate() {
        expression: sum(query(forexRates) * from_selector() * query(buyer_currency), from, to)
    }

    function price_tensor() {
        expression: tensorFromStructs(attribute(per_market_price), market, price, double)
    }

    function market_specific_price() {
        expression: sum(price_tensor() * query(buyer_market), market)
    }

    function default_price() {
        expression: price_tensor(){market:'DEFAULT'}
    }

    function effective_price_in_seller_currency() {
        expression: if(market_specific_price() > 0, market_specific_price(), default_price())
    }

    function effective_price_in_buyer_currency() {
        expression: effective_price_in_seller_currency() * buyer_rate()
    }

    first-phase {
        expression: -effective_price_in_buyer_currency()
    }
}
{% endhighlight %}</pre>

<p>
  This rank profile requires passing one-hot encoded tensors for the buyer's currency and market as query parameters:
</p>
<pre>{% highlight sh %}
$ vespa query \
    'yql=select * from product where true' \
    'searchChain=multi-currency-filter' \
    'ecommerce.multicurrency.enrich=true' \
    'ranking.features.query(buyer_currency)={% raw %}{{to:NOK}:1}{% endraw %}' \
    'ranking.features.query(buyer_market)={% raw %}{{market:NO}:1}{% endraw %}'
{% endhighlight %}</pre>

<p>
  Key functions:
</p>
<ul>
  <li><code>tensorFromStructs</code> - Converts the <code>per_market_price</code> array to a tensor at ranking time</li>
  <li><code>market_specific_price()</code> - Extracts price for the requested market if it exists</li>
  <li><code>default_price()</code> - Gets the DEFAULT market price as fallback</li>
  <li><code>effective_price_in_seller_currency()</code> - Selects market-specific price or falls back to DEFAULT</li>
  <li><code>effective_price_in_buyer_currency()</code> - Converts the effective price using forex rates</li>
</ul>


<h2 id="best-practices">Best Practices</h2>
<ul>
  <li>
    <strong>Single forex document:</strong> Use a single forex document with ID <code>id:forex:forex::forex</code>
    containing all currency pairs. Do not create multiple forex documents.
  </li>
  <li>
    <strong>Include identity rates:</strong> Always include identity rates (USD→USD = 1.0, EUR→EUR = 1.0, etc.)
    to avoid missing-cell lookups.
  </li>
  <li>
    <strong>Store in seller currency:</strong> Store products in their native (seller) currency and use
    per-market price overrides only when necessary.
  </li>
  <li>
    <strong>DEFAULT market:</strong> Always include a <code>DEFAULT</code> market entry as fallback
    for markets without specific pricing.
  </li>
  <li>
    <strong>Asymmetric rates:</strong> Exchange rates are not assumed to be symmetric.
    The implementation uses directed conversion rates (buyer→seller) to ensure pricing accuracy.
    Store both directions explicitly (A→B and B→A) as they may differ slightly due to
    exchange spreads or rounding. This protects against asymmetric forex rates where rates are not perfect inverses.
  </li>
  <li>
    <strong>Timestamp field:</strong> Always include and update the <code>timestamp</code> field when feeding
    forex documents. The cache uses this to determine if an update contains newer data.
    Use epoch seconds for the timestamp value.
  </li>
  <li>
    <strong>Update frequency:</strong> Consider the volatility of your target currencies when deciding
    on forex rate update frequency. Financial applications may need more frequent updates than retail applications.
    The 10-second refresh interval ensures updates are picked up quickly after feeding.
  </li>
  <li>
    <strong>Search chain:</strong> Always specify <code>searchChain=multi-currency-filter</code>
    in queries that use multi-currency filtering, or add it to your default search chain.
  </li>
</ul>


<h2 id="see-also">See Also</h2>
<ul>
  <li><a href="/en/use-case-shopping.html">Use Case - Shopping</a></li>
  <li><a href="/en/searcher-development.html">Searcher Development</a></li>
  <li><a href="/en/tensor-user-guide.html">Tensor Guide</a></li>
  <li><a href="/en/reference/rank-features.html#tensorFromStructs(attribute,key,value,type)">tensorFromStructs - Convert struct arrays to tensors</a></li>
  <li><a href="/en/reference/schema-reference.html#struct-field">Struct Fields in Schemas</a></li>
  <li><a href="/en/operations-selfhosted/routing.html#search-chains">Search Chains</a></li>
</ul>
