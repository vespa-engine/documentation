---
# Copyright Yahoo. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.
title: "YQL Query Language Reference"
redirect_from:
- /documentation/reference/query-language-reference.html
---

<p>
  Vespa accepts unstructured human input and structured queries for application logic separately,
  then combines them into a single data structure for executing.
  Human input is parsed heuristically, while application queries are formulated in YQL.
</p>
{% include note.html content='See the <a href="../query-language.html">Query Language Guide</a>
for query examples'%}
<p>A query URL looks like:</p>
<pre>
http://myhost.mydomain.com:8080/search/?yql=select%20%2A%20from%20sources%20%2A%20where%20text%20contains%20%22blues%22
</pre>
<p>In other words, <code>yql</code> contains:</p>
<pre>
select * from sources * where text contains "blues"
</pre>
<p>
  This <a href="schema-reference.html#match">matches</a> all documents
  where the field named <em>text</em> contains the word <em>blues</em>.
</p>
<p>
  Quote <code>"</code> and backslash <code>\</code> characters in text values must be escaped by a backslash,
  also see <a href="../faq.html#how-does-backslash-escapes-work">how does backslash escapes work</a>.
</p>
{% include important.html content='There is no way to query for a field that is not set
/ equals <code>null</code> or <code>NaN</code>.
Work around using a "magic" value (like MAXINT) that is not normally used in the documents.'%}
<p>Since Vespa 7.520.3, YQL queries do not require a semicolon at the end.</p>



<h2 id="select">select</h2>
<p>
<em>select</em> is the list of <a href="../schemas.html#indexing">summary fields</a> requested
(a field with the <code>summary</code> index attribute).
Vespa will hide other fields in the matching documents.
</p>
<pre>
select price,isbn from sources * where title contains "madonna"
</pre>
<p>
  The above explicitly requests the fields "price" and "isbn" (from all sources).
  To request all fields, use an asterisk as field selection:
</p>
<pre>
select * from sources * where title contains "madonna"
</pre>



<h2 id="from-sources">from sources</h2>
<!-- ToDo: describe how this is equal to model.sources -->
<p>
  <em>from sources</em> specifies which content
  <a href="query-api-reference.html#model.sources">sources</a> to query. Example:
</p>
<pre>
select * from music where title contains "madonna"
</pre>
<p>
  queries all document types in the <em>music</em> content cluster or federation source. Query in:
</p>
<table class="table">
<thead></thead><tbody>
  <tr><td>all sources</td>
      <td><code>select … from <strong>sources *</strong> where …</code></td></tr>
  <tr><td>a set of sources</td>
      <td><code>select … from <strong>sources source1, source2</strong> where …</code></td></tr>
  <tr><td>a single source</td>
      <td><code>select … from <strong>source1</strong> where …</code></td></tr>
</tbody>
</table>
<p>
  In other words, <em>sources</em> is used for querying some/all sources.
  If only a single source is queried, the <em>sources</em> keyword is dropped.
  To restrict the query to only one schema (aka document type) use the
  <a href="query-api-reference.html#model.restrict">model.restrict</a> URL parameter.
  Also see <a href="../federation.html">federation</a>.
</p>



<h2 id="where">where</h2>
<p>The <code>where</code> clause is a tree of operators:</p>
<table class="table">
  <thead></thead>
  <tbody>

  <tr><th>numeric</th><td>
    <p id="numeric">
    The following numeric operators are available:
    <code>= &lt; &gt; &lt;= &gt;= range(field, lower bound, upper bound)</code>.
    </p>
<pre>
where 500 >= price
</pre>
<pre>
where range(fieldname, 0, 5000000000L)
</pre>
    <p>
      Numbers must be in the signed 32-bit range.
      Input 64-bit signed numbers using <code>L</code> as suffix.
    </p>
    <p>
      For the <code>range</code> operator, one can also use
      the strings <code>Infinity</code> or <code>-Infinity</code>:
    </p>
<pre>
where (range(year, 2000, Infinity))
</pre>
    <table class="table">
      <thead>
      <tr>
        <th>Annotation</th>
        <th>Effect</th>
      </tr>
      </thead>
      <tbody>
      <tr>
        <td><a href="#bounds">bounds</a></td>
        <td>Range: open or closed interval.</td>
      </tr>
      <tr>
        <td><a href="#hitlimit">hitLimit</a></td>
        <td>
          Used for <em>capped range search</em>.
          The <code>range()</code> query operator with <code>hitLimit</code> can be used to efficiently implement
          top-k selection for ranking a subset of the documents in the index.
          See <a href="../performance/practical-search-performance-guide.html#advanced-range-search-with-hitlimit">
          example and use cases</a>.
        </td>
      </tr>
      </tbody>
    </table>
    <p>
    The <a href="schema-reference.html#weightedset">weightedset</a> field does not support filtering on weight.
    Solve this using the <a href="schema-reference.html#map">map</a> type and
    <a href="#sameelement">sameElement</a> query operator -
    see <a href="../query-language.html#map">example</a>.
    </p>
  </td></tr>

  <tr><th>boolean</th><td>
    <p id="boolean">The boolean operator is: <code>=</code></p>
<pre>
where alive = true
</pre>
  </td></tr>

  <tr><th>contains</th><td>
    <p id="contains">
    The right-hand side argument of the contains operator is either a string literal,
    or a function, like <code>phrase</code>.
    </p>
    <p>
    <code>contains</code> is the basic building block for text matching.
    The kind of <a href="schema-reference.html#match">matching</a>
    to be done depends on the field settings in the schema.
    </p>
<pre>
where title contains "madonna"
</pre>
    <table class="table">
      <thead>
      <tr>
        <th>Annotation</th>
        <th>Effect</th>
      </tr>
      </thead>
      <tbody>
      <tr>
        <td><a href="#stem">stem</a></td>
        <td>
          By default, the string literal is <a href="../linguistics.html#tokenization">tokenized</a>
          to match the field(s) searched.
          Explicitly control tokenization by using <a href="#stem">stem</a>:
<pre>
where title contains ({stem: false}"madonna")
</pre>
        </td>
      </tr>
      </tbody>
    </table>
    <p>
    The matched field must be an
    <a href="../schemas.html#indexing">indexed field or attribute</a>.
    </p><p>
    Fields inside structs are referenced using dot notation -
    e.g <code>mystruct.mystructfield</code>.
    </p>
    </td>
  </tr>

  <tr>
    <th>and</th>
    <td>
      <p id="and">
        <code>and</code> accepts other <code>and</code> statements, <code>or</code> statements,
        <a href="#userquery">userQuery</a>, logically inverted statements -
        and contains statements as arguments:
      </p>
<pre>
where title contains "madonna" and title contains "saint"
</pre>
    </td>
  </tr>

  <tr>
    <th>or</th>
    <td>
      <p id="or">
        <code>or</code> accepts other <code>or</code> statements, <code>and</code> statements,
        <a href="#userquery">userQuery</a> - and contains statements as arguments:
      </p>
<pre>
where title contains "madonna" or title contains "saint"
</pre>
    </td>
  </tr>

  <tr>
    <th>not</th>
    <td>
      <p id="not">
        Use the <code>!</code> operator to match document that does <i>not</i> satisfy some condition:
      </p>
<pre>
where title contains "madonna" and !(title contains "saint")
</pre>
    </td>
  </tr>

  <tr>
    <th>phrase</th>
    <td>
      <p id="phrase">
        Phrases are expressed as a function:
      </p>
<pre>
where text contains phrase("st", "louis", "blues")
</pre>
    </td>
  </tr>

  <tr>
    <th>near</th>
    <td>
      <p id="near">
        <code>near()</code> matches if all argument terms occur close to each other in the same document.
      </p>
      <table class="table">
        <thead>
        <tr>
          <th>Annotation</th>
          <th>Effect</th>
        </tr>
        </thead>
        <tbody>
        <tr>
          <td><a href="#distance">distance</a></td>
          <td>Tune closeness using <code>distance</code>.</td>
        </tr>
        </tbody>
      </table>
    </td>
  </tr>

  <tr>
    <th>onear</th>
    <td>
      <p id="onear">
        <code>onear()</code> (ordered near) is like <code>near()</code>,
        but also requires the terms in the document having the same order
        as given in the function (i.e. it is a phrase allowing other words interleaved).
        With distance 1, <code>onear()</code> has the same semantics as <code>phrase()</code>.
      </p>
      <table class="table"> <!-- ToDo: Assuming near and onear support the same annotations -->
        <thead>
        <tr>
          <th>Annotation</th>
          <th>Effect</th>
        </tr>
        </thead>
        <tbody>
        <tr>
          <td><a href="#distance">distance</a></td>
          <td>Tune closeness using <code>distance</code>.</td>
        </tr>
        </tbody>
      </table>
    </td>
  </tr>

  <tr>
    <th>sameElement</th>
    <td>
      <p id="sameelement">
        <em>sameElement()</em> is an operator that requires the terms to match within the same struct element
        in an array or a map field. Example:
      </p>
<pre>
struct person {
    field first_name    type string {}
    field last_name     type string {}
    field year_of_birth type int {}
}

field persons type array&lt;person&gt; {
    indexing: summary
    struct-field first_name    { indexing: attribute }
    struct-field last_name     { indexing: attribute }
    struct-field year_of_birth { indexing: attribute }
}
field identities type map&lt;string, person&gt; {
    indexing: summary
    struct-field key                 { indexing: attribute }
    struct-field value.first_name    { indexing: attribute }
    struct-field value.last_name     { indexing: attribute }
    struct-field value.year_of_birth { indexing: attribute }
}
</pre>
      <p>
        With normal <em>AND</em> the query <code>persons.first_name AND persons.last_name</code>
        will normally not give you what you want.
        It will match if a document has a <em>persons</em> element with a matching <em>first_name</em>
        <em>AND</em> any element with a matching <em>last_name</em>.
        So you will get a lot of false positives since there is nothing limiting them to the same element.
        However, that is what <em>sameElement</em> ensures. Note that <em>sameElement</em> uses
        <em>AND</em> to connect the operands. To use <em>OR</em>, use multiple sameElement operators using logical OR.
      </p>
<pre>
where persons contains sameElement(first_name contains 'Joe', last_name contains 'Smith', year_of_birth < 1940)
</pre>
      <p>
        The above returns all documents containing Joe Smith born before 1940 in the <em>persons</em> array.
      </p>
      <p>
        Searching in a map is similar to searching in an array of struct.
        The difference is that you have an extra synthetic struct with the field members <em>key</em> and <em>value</em>.
        The above example with the <em>identities</em> map looks like this:
      </p>
<pre>
where identities contains sameElement(key contains 'father', value.first_name contains 'Joe', value.last_name contains 'Smith', value.year_of_birth < 1940)
</pre>
      <p>
        The above returns all documents that have tagged Joe Smith born before 1940 as a 'father'.
        The importance here is using the indirection of <em>key</em> and <em>value</em>
        to address the keys and the values of the map.
      </p>
    </td>
  </tr>

  <tr><th>equiv</th><td>
    <p id="equiv">
      If two terms in the same field should give exactly the same behavior when matched,
      the <code>equiv()</code> operator behaves like a special case of <code>or</code>.
    </p>
<pre>
where fieldName contains equiv("A","B")
</pre>
    <p>
      In many cases, the OR operator will give the same results as an EQUIV.
      The matching logic is exactly the same,
      and an OR does not have the limitations that EQUIV does (below).
      The difference is in how matches are visible to ranking functions.
      All words that are children of an OR count for ranking.
      When using an EQUIV however, it looks like a single word:
    </p>
    <ul>
      <li>Counts as only +1 for queryTermCount</li>
      <li>Counts as 1 word for completeness measures</li>
      <li>Proximity will not discriminate different words inside the EQUIV</li>
      <li>Connectivity can be set between the entire EQUIV and the word before and after</li>
      <li>Items inside the EQUIV are not directly visible to ranking features,
        so weight and connectivity on those will have no effect</li>
    </ul>
    <p>Limitations on how <code>equiv</code> can be used in a query:</p>
    <ul>
      <li><code>equiv</code> may not appear inside a phrase</li>
      <li>It may only contain <code>TermItem</code> and <code>PhraseItem</code> instances.
        Operators like <code>and</code> cannot be placed inside <code>equiv</code></li>
      <li><code>PhraseItems</code> inside <code>equiv</code> will rank like as if they have size 1</li>
    </ul>
    <p>Learn how to use <a href="../query-rewriting.html#equiv">equiv</a>.</p>
  </td>
  </tr>

  <tr>
    <th>uri</th>
    <td>
      <p id="uri">Used to search for urls indexed using the
        <a href="schema-reference.html#uri">uri field type</a>.</p>
<pre>
where myUrlField contains uri("vespa.ai/foo")
</pre>
      <p>Various subfields are supported to search components of the URL, see the field type definition.</p>
      <table class="table">
        <thead>
        <tr>
          <th>Annotation</th>
          <th>Effect</th>
        </tr>
        </thead>
        <tbody>
        <tr>
          <td><a href="#startanchor">startAnchor</a></td>
          <td>Anchor uri.hostname at start.</td>
        </tr>
        <tr>
          <td><a href="#endanchor">endAnchor</a></td>
          <td>Anchor uri.hostname at end.</td>
        </tr>
        </tbody>
      </table>
    </td>
  </tr>

  <tr>
    <th>fuzzy</th>
    <td>
      <p id="fuzzy">
        <a href="https://en.wikipedia.org/wiki/Levenshtein_distance">Levenshtein</a>
        edit distance search within a string <a href='schema-reference.html#attribute'>attribute</a>.
      </p>
<pre>
where myStringAttribute contains ({prefixLength:1, maxEditDistance:2}fuzzy("parantesis"))
</pre>
      <p>Annotations below are configuring <code>fuzzy</code>:</p>
      <table class="table">
        <thead>
        <tr>
          <th>Annotation</th>
          <th>Effect</th>
        </tr>
        </thead>
        <tbody>
        <tr>
          <td><a href="#maxeditdistance">maxEditDistance</a></td>
          <td>An inclusive upper bound of edit distance between query and string attribute (default is 2).</td>
        </tr>
        <tr>
          <td><a href="#prefixlength">prefixLength</a></td>
          <td>Number of characters that are considered frozen,
            so the fuzzy match will be performed only with the suffix left.
            Default is 0 (i.e. <code>fuzzy</code> will match across whole query)</td>
        </tr>
        </tbody>
      </table>
      <p>Find an example in <a href="../text-matching.html#fuzzy-match">text matching</a>.</p>
      {% include important.html content="Only string <a href='schema-reference.html#attribute'>attribute</a>
      fields in <a href='services-content.html#document'>documents</a> are supported (single, array or weightedset).
      It is also not optimized, but setting <a href='#prefixlength'>prefixLength</a> greater than 0
      would narrow the match for the <a href='schema-reference.html#attribute'>fast-search</a>,
      so it won't run a full scan."%}
    </td>
  </tr>
  <tr>
    <th>matches</th>
    <td>
      <p id="matches">
        Regular expression match is supported using
        <a href="https://en.wikibooks.org/wiki/Regular_Expressions/POSIX_Extended_Regular_Expressions">posix extended syntax</a>,
        with the limitation that it is <strong>case insensitive</strong>.
      </p>
      <p>Example matching both <code>madonna</code>, <code>madona</code> and with any number of <code>n</code>s:</p>
<pre>
where attribute_field matches "mado[n]+a"
</pre>
      <p>Find more examples in the <a href="../text-matching.html#regexp-match">text matching</a> guide.</p>
      {% include important.html content="Only <a href='schema-reference.html#attribute'>attribute</a>
      fields in <a href='services-content.html#document'>documents</a> is supported.
      It is not optimized for performance.
      Having a prefix using the <code>^</code> will be faster than not having one."%}
    </td>
  </tr>

  <tr>
    <th>userInput</th>
    <td>
      <p id="userinput">
        <em>userInput()</em> is a robust way of mixing user input and a formal query.
        It allows controlling whether the user input is to be stemmed, lowercased, etc.,
        but it also allows for controlling whether it should be treated as a raw string,
        whether it should simply be segmented or parsed as a query.
      </p>
<pre>
yql=select * from sources * where userInput(@animal)&amp;animal=panda
</pre>
      <p>
        Here, the userInput() function will access the query property "animal",
          and parse the property value as a <a href="query-language-reference.html#weakand"><em>weakAnd</em></a> query, resulting in the following expression:
      </p>
<pre>
select * from sources * where weakAnd(default contains "panda")
</pre>
      <p>
        Find a full example in the <a href="../query-api.html#input-examples">query API</a> guide.
      </p>
      <p>
        Instead of <a href="#parameter-substitution">parameter substitution</a>,
        the <em>userInput()</em> function also accepts raw strings as arguments,
        but this would obviously not be suited for parametrizing the query from a query profile.
        It is mostly intended as test feature.
      </p>
      <table class="table">
        <thead>
        <tr>
          <th>Annotation</th>
          <th>Effect</th>
        </tr>
        </thead>
        <tbody>
        <tr>
          <td><a href="#grammar">grammar</a></td>
          <td>
            How to parse the user input.
            For any value of <code>grammar</code> other than <code>raw</code> or <code>segment</code>,
            only the following annotations are applied:
            <ul>
              <li><a href="#defaultindex">defaultIndex</a></li>
              <li><a href="#targethits">targetHits</a></li> (for weakAnd)
              <li><a href="#ranked">ranked</a></li>
              <li><a href="#filter">filter</a></li>
              <li><a href="#stem">stem</a></li>
              <li><a href="#normalizecase">normalizeCase</a></li>
              <li><a href="#accentdrop">accentDrop</a></li>
              <li><a href="#usepositiondata">usePositionData</a></li>
            </ul>
            E.g. if annotating <code>userInput</code> with <code>phrase</code>,
            a <code>filter</code> annotation will have effect,
            but not <code>language</code>.
          </td>
        </tr>
        <tr>
          <td><a href="#defaultindex">defaultIndex</a></td>
          <td>Same as <a href="query-api-reference.html#model.defaultindex">model.defaultIndex</a>
            in the query API.</td>
        </tr>
        <tr>
          <td><a href="#language">language</a></td>
          <td>Language setting for the linguistics treatment of this userInput() call.</td>
        </tr>
        <tr>
          <td><a href="#allowempty">allowEmpty</a></td>
          <td>Whether to allow empty input for query parsing and search terms.</td>
        </tr>
        </tbody>
      </table>
      <p>
        In addition, other annotations, like <a href="#stem">stem</a> or <a href="#ranked">ranked</a>,
        will take effect as normal.
      </p>
    </td>
  </tr>

  <tr>
    <th>userQuery</th>
    <td>
      <p id="userquery">
        <em>userQuery()</em> reads from <a href="query-api-reference.html#model.querystring">model.queryString</a>
        and parses the query using <a href="simple-query-language-reference.html">simple query language</a>.
        If set, <a href="query-api-reference.html#model.filter">model.filter</a> is combined with
        <em>model.queryString</em> before the parsing.
      </p>
      <p>
        The user query is first parsed,
        then the resulting tree is inserted into the corresponding place in the YQL query tree. Example:
      </p>
<pre>
query=abc def -ghi
type=all
yql=select * from sources * where vendor contains "brick and mortar" AND price < 50 AND userQuery()
</pre>
      <p>This evaluates to a query where:</p>
      <ul>
        <li>the numeric field <em>price</em> must be less than 50</li>
        <li><em>vendor</em> must match <em>brick and mortar</em></li>
        <li>the default index must contain the two terms <em>abc</em> and <em>def</em>,
          <em>and not</em> contain <em>ghi</em>.</li>
      </ul>
    </td>
  </tr>

  <tr>
    <th>rank</th>
    <td>
      <p id="rank">
      The first, and only the first, argument of the <em>rank()</em> function
      determines whether a document is a match,
      but all arguments are used for calculating rank score.
      </p>
<pre>
where rank(a contains "A", b contains "B")
</pre>
    </td>
  </tr>

  <tr>
    <th>dotProduct</th>
    <td>
      <p id="dotproduct">
        <em>dotProduct</em> calculates the dot product between the weighted set
        in the query and a weighted set field in the document as its rank score contribution:
      </p>
<pre>
where dotProduct(description, {"a":1, "b":2})
</pre>
      <p>
        The result is stored as a <a href="../multivalue-query-operators.html#raw-scores-and-query-item-labeling">raw score</a>.
      </p>
      <p>
        A normal use case is a collection of weighted tokens produced by an algorithm,
        to match against a corpus containing weighted tokens
        produced by another algorithm in order to implement personalized content exploration.
        See example usage of <em>dotProduct</em>
        in <a href="../performance/practical-search-performance-guide.html#multi-valued-query-operators">
          practical performance guide
        </a>.
      </p>
      <p>
        Refer to <a href="../multivalue-query-operators.html">multivalue query operators</a>
        for a discussion of usage and examples.
      </p>
      <p>
        Keys must be single or double-quoted if passed inline in YQL -
        alternatively, use <a href="#parameter-substitution">parameter substitution</a>
        to submit the weighted set with a simple format for faster query parsing -
        example: <code>where dotProduct(description, @myterms)</code>.
      </p>
      <table class="table">
        <thead></thead><tbody>
      <tr>
        <th>Field type</th>
        <td>Weighted set attribute with fast-search. Note: Also supported for regular attribute or
          index fields, but then with much weaker performance).</td>
      </tr><tr>
        <th>Query model</th>
        <td>Weighted set with {token, weight} pairs</td>
      </tr><tr>
        <th>Matching</th>
        <td>Documents where the weighted set field contains at least one of the tokens in the query.</td>
      </tr><tr>
        <th>Ranking</th>
        <td>Dot product score between the weights of the matched query tokens and field tokens.
          This score is available using
          <a href="rank-features.html#rawScore(field)">rawScore</a> or
          <a href="rank-features.html#itemRawScore(label)">itemRawScore</a>
          rank features.</td>
      </tr><tr>
        <th style="white-space:nowrap;">Java Query Item</th>
        <td><a href="https://javadoc.io/doc/com.yahoo.vespa/container-search/latest/com/yahoo/prelude/query/DotProductItem.html">DotProductItem</a></td>
      </tr>
      </tbody>
      </table>
    </td>
  </tr>

  <tr>
    <th>weightedSet</th>
    <td>
      <p id="weightedset">
        When using <em>weightedSet</em> to search a field,
        all tokens present in the searched field will be matched against the weighted set in the query.
        This means that using a weighted set to search a single-value attribute field
        will have similar semantics to using a normal term to search a weighted set field.
        The low-level matching information resulting from matching a document with a weighted set in the query
        will contain the weights of all the matched tokens in descending order.
        Each matched weight will be represented as a standard occurrence on position 0 in element 0.
      </p>
<pre>
where weightedSet(description, {"a":1, "b":2})
</pre>
      <p>
        <em>weightedSet</em> has similar semantics to <a href="#equiv">equiv</a>,
        as it acts as a single term in the query.
        However, the restriction dictating that it contains a collection of weighted tokens directly
        enables specific back-end optimizations that improves performance
        for large sets of tokens compared to using the generic <a href="#equiv">equiv</a> or <a href="#or">or</a> operators.
      </p>
      <p>
        Refer to <a href="../multivalue-query-operators.html">multivalue query operators</a>
        for a discussion of usage and examples.
        Also see <a href="../performance/feature-tuning.html#multi-lookup-set-filtering">multi-lookup set filtering</a>.
      </p>
      <p>
        Keys must be single or double-quoted if passed inline in YQL -
        alternatively, use <a href="#parameter-substitution">parameter substitution</a>
        to submit the weighted set with a simple format for faster query parsing -
        example: <code>where weightedSet(description, @myterms)</code>.
      </p>
      <table class="table">
        <thead></thead><tbody>
      <tr>
        <th>Field type</th>
        <td>Singlevalue or <a href="../schemas.html#field">multivalue</a> attribute or index field.
          (Note: Most use cases operates on a single value field).</td>
      </tr><tr>
        <th>Query model</th>
        <td>Weighted set with {token, weight} pairs.</td>
      </tr><tr>
        <th>Matching</th>
        <td>Documents where the field contains at least one of the tokens in the query.</td>
      </tr><tr>
        <th>Ranking</th>
        <td>The operator will act as a single term in the back-end.
          The query term weight is the weight assigned to the operator itself
          and the match weight is the largest weight among matching tokens from the weighted set.
          This operator does not produce a raw score.
          Due to better ranking and performance we recommend using <a href="#dotproduct">dotProduct</a> instead.</td>
      </tr><tr>
        <th style="white-space:nowrap;">Java Query Item</th>
        <td><a href="https://javadoc.io/doc/com.yahoo.vespa/container-search/latest/com/yahoo/prelude/query/WeightedSetItem.html">WeightedSetItem</a></td>
      </tr>
      </tbody>
      </table>
    </td>
  </tr>

  <tr><th>wand</th><td>
    <p id="wand">
      <code>wand</code> can be used to search for documents
      where weighted tokens in a field matches a subset of weighted tokens in the query.
      At the same time, it internally calculates the dot product between token weights in the query and the field.
      <code>wand</code> is guaranteed to return the top-k hits according to its internal dot product rank score.
      It is an operator that scales adaptively from <a href="#or">or</a> to <a href="#and">and</a>.
    </p>
    <p>Note that total hit count becomes inaccurate when using wand.</p>
    <p>
      <code>wand</code> optimizes the performance of using multiple threads per search in the backend,
      and is also called <em>Parallel Wand</em>.
    </p>
    <p>
      <code>wand</code> also allows numeric arguments, then the search argument is an array of arrays of length two.
      In each pair, the first number is the search term, the second its weight:
<pre>
where wand(description, [[11,1], [37,2]])
</pre>
    <p>
      Keys must be single or double-quoted if passed inline in YQL -
      alternatively, use <a href="#parameter-substitution">parameter substitution</a>
      to submit the weighted set with a simple format for faster query parsing -
      example: <code>where wand(description, @myterms)</code>.
    </p>
    <table class="table">
      <thead>
      <tr>
        <th>Annotation</th>
        <th>Effect</th>
      </tr>
      </thead>
      <tbody>
      <tr>
        <td><a href="#scorethreshold">scoreThreshold</a></td>
        <td>Minimum rank score for hits to include.</td>
      </tr>
      <tr>
        <td><a href="#targethits">targetHits</a></td>
        <td>Wanted number of hits exposed to the real first-phase ranking function per content node.</td>
      </tr>
      </tbody>
    </table>
<pre>
where ({scoreThreshold: 0.13, targetHits: 7}wand(description, {"a":1, "b":2}))
</pre>
    <p>
      Refer to <a href="../using-wand-with-vespa.html">using wand</a> for introduction to the WAND
      algorithm and example usage of <em>wand</em>
      in <a href="../performance/practical-search-performance-guide.html#multi-valued-query-operators">
        practical performance guide
      </a>.
    </p>
    <table class="table">
      <thead></thead><tbody>
    <tr>
      <th>Field type</th>
      <td>Weighted set attribute with fast-search.
        Note: Also supported for regular attribute or index fields,
        but then with much weaker performance).</td>
    </tr><tr>
      <th>Query model</th>
      <td>Weighted set with {token, weight} pairs.</td>
    </tr><tr>
      <th>Matching</th>
      <td>Documents where the weighted set field contains at least one of the tokens in the query
        and where the internal dot product score for this document,
        is larger than the worst among the current top-k best hits.
        This means that more than top-k documents are matched and returned for ranking.
        It also means that many documents are skipped,
        even they match several tokens in the query because the dot product score is too low.
        This skipping makes <em>wand</em> faster than <a href="#dotproduct">dotProduct</a> in some cases.
      </td>
    </tr><tr>
      <th>Ranking</th>
      <td>Dot product score between the weights of the matched query tokens and field tokens.
        This score is available using
        <a href="rank-features.html#rawScore(field)">rawScore</a> or
        <a href="rank-features.html#itemRawScore(label)">itemRawScore</a>
        rank features.
        Note that the top-k best hits are only guaranteed to be returned
        when using this internal score as the final ranking expression.
      </td>
    </tr><tr>
      <th style="white-space:nowrap;">Java Query Item</th>
      <td><a href="https://javadoc.io/doc/com.yahoo.vespa/container-search/latest/com/yahoo/prelude/query/WandItem.html">WandItem</a></td>
    </tr>
    </tbody>
    </table>
  </td>
  </tr>

  <tr>
    <th>weakAnd</th>
    <td>
      <p id="weakand">
        <code>weakAnd</code> is sometimes called <em>Vespa Wand</em>.
        Unlike <a href="#wand">wand</a>, it accepts arbitrary word matches (across arbitrary fields) as arguments.
        Only a limited number of documents are returned for ranking (default is 100),
        but it does not guarantee to return the best k hits.
        This function can be seen as an optimized <a href="#or">or</a>:
      </p>
<pre>
where weakAnd(a contains "A", b contains "B")
</pre>
      <table class="table">
        <thead>
        <tr>
          <th>Annotation</th>
          <th>Effect</th>
        </tr>
        </thead>
        <tbody>
        <tr>
          <td><a href="#scorethreshold">scoreThreshold</a></td>
          <td>Minimum rank score for hits to include.</td>
        </tr>
        <tr>
          <td><a href="#targethits">targetHits</a></td>
          <td>Wanted number of hits exposed to the real first-phase ranking function per content node.</td>
        </tr>
        </tbody>
      </table>
<pre>
where ({scoreThreshold: 0, targetHits: 7}weakAnd(a contains "A", b contains "B"))
</pre>
      <p>
        Unlike <a href="#wand">wand</a>, <code>weakAnd</code> can be used
        to search across several fields of various types,
        but it does NOT guarantee to return the top-k best number of hits.
        It can however be combined with any ranking expression.
        Keep in mind that this expression should correlate with its simple internal ranking score
        that uses query term weight and inverse document frequency for matching terms.
      </p>
      <p>
        Refer to <a href="../using-wand-with-vespa.html">using wand</a> for a usage and examples.
      </p>
      <table class="table">
        <thead></thead><tbody>
      <tr>
        <th>Field type</th>
        <td>Multiple fields of all types (both attribute and index).</td>
      </tr><tr>
        <th>Query model</th>
        <td>Arbitrary number of query items searching across different fields.</td>
      </tr><tr>
        <th>Matching</th>
        <td>Documents that matches at least one of the tokens in the query
          and where the internal operator score for this document
          is larger than the worst among the current top-k best hits.
          As with <a href="#wand">wand</a>, this means that typically more than top-k documents are matched
          and a lot of documents are skipped.
        </td>
      </tr><tr>
        <th>Ranking</th>
        <td>Internal ranking score based on query term weight
          and inverse document frequency for matching terms to find the top-k hits.
          This score is currently not available to the ranking framework.
          Matching terms are exposed to the ranking framework
          (same as when using <a href="#and">and</a> or <a href="#or">or</a>),
          so an arbitrary ranking expression can be used in combination with this operator.
          Note that the ranking expression used should correlate with this internal ranking score.
          <a href="rank-features.html#bm25">bm25</a>,
          <a href="rank-features.html#nativeFieldMatch">nativeFieldMatch</a> and
          <a href="rank-features.html#nativeDotProduct(field)">nativeDotProduct</a>
          rank features are good starting points.
        </td>
      </tr><tr>
        <th style="white-space:nowrap;">Java Query Item</th>
        <td><a href="https://javadoc.io/doc/com.yahoo.vespa/container-search/latest/com/yahoo/prelude/query/WeakAndItem.html">WeakAndItem</a></td>
      </tr>
      </tbody>
      </table>
    </td>
  </tr>

  <tr>
    <th>geoLocation</th>
    <td>
      <p id="geolocation">
        <code>geoLocation</code> matches a <a href="schema-reference.html#position">position</a>
        inside a geographical circle, specified as latitude, longitude, and a maximum distance (radius).
        Example:
      </p>
<pre>
where geoLocation(myfieldname, 63.5, 10.5, "200 km")
</pre>
      <p>
        In this example we search for documents near 63.5° north, 10.5° east,
        and within a 200 km radius.
        So a document with a "myfieldname" position in Trondheim, Norway at
        N63°25'47;E10°23'36 would match.
        The first parameter is the name of the attribute field.
        The second parameter is the longitude (positive for north, negative for south).
        The third parameter is the latitude (positive for east, negative for west).
        The fourth parameter must be a string specifying the radius and its units,
        where the supported units include "km", "m" (for meters), "miles", and "deg" for degrees
        (so "deg" gives radius the same units as latitude).
        Any negative number for radius (e.g. "-1 m") is interpreted as an "infinite" radius,
        letting any geographical position at all match the geoLocation operator.
      </p>
      <p>
        The position attribute in the schema could look like:
      </p>
<pre>
field myfieldname type position {
    indexing: attribute | summary
}
</pre>
      <p>Arrays of positions are also possible:</p>
<pre>
field myfieldname type array&lt;position&gt; {
    indexing: attribute
}
</pre>
      <table class="table">
        <thead>
        <tr>
          <th>Annotation</th>
          <th>Effect</th>
        </tr>
        </thead>
        <tbody>
        <tr>
          <td><a href="#label">label</a></td>
          <td>Label for referring to this term during ranking.</td>
        </tr>
        </tbody>
      </table>
      <p>
        Properties:
      </p>
      <table class="table">
        <thead></thead><tbody>
      <tr>
        <th>Field type</th>
        <td>position attribute (single-valued or array).</td>
      </tr><tr>
        <th>Query parameters</th>
        <td>Field name, longitude, latitude, radius.</td>
      </tr><tr>
        <th>Matching</th>
        <td>Returns documents inside the given geo circle.</td>
      </tr><tr>
        <th>Ranking</th>
        <td>Use <code>closeness(myfieldname)</code>, or <code>distance(myfieldname)</code>
          in ranking calculations.
          See <a href="rank-features.html#closeness(name)">closeness</a>
          and <a href="rank-features.html#distance(name)">distance</a> documentation.</td>
      </tr><tr>
        <th style="white-space:nowrap;">Java Query Item</th>
        <td><a href="https://javadoc.io/doc/com.yahoo.vespa/container-search/latest/com/yahoo/prelude/query/GeoLocationItem.html">GeoLocationItem</a></td>
      </tr>
      </tbody>
      </table>
    </td>
  </tr>

  <tr>
    <th>nearestNeighbor</th>
    <td>
      <p id="nearestneighbor">
        <code>nearestNeighbor</code> matches the top-k nearest neighbors in a multidimensional vector space.
        Points in the vector space are specified as
        <a href="../tensor-user-guide.html">tensors</a> with one indexed dimension,
        where the size of that dimension is equal to the dimensionality of the vector space.
      </p>
      <p>
        The document vectors are stored in a
        <a href="schema-reference.html#tensor">tensor field attribute</a>,
        and the query vector is sent with the query request.
        The following tensor field types are supported:
      </p>
        <ul>
          <li>Single vector per document: Tensor type with one indexed dimension.
            Example: <code>tensor&lt;float&gt;(x[3])</code></li>

          <li>Multiple vectors per document: Tensor type with one mapped and one indexed dimension.
            Example: <code>tensor&lt;float&gt;(m{},x[3])</code></li>
        </ul>
      <p>
        Euclidean distance is used as the default
        <a href="schema-reference.html#distance-metric">distance metric</a>
        and the exact nearest neighbors are returned.
        When storing multiple vectors per document, the vector that is closest to the query vector
        is used when calculating the distance between the document and the query.
        If an <a href="schema-reference.html#index-hnsw">HNSW index</a> is specified on the tensor field,
        the <span style="text-decoration: underline">approximate</span> nearest neighbors are returned. Example:
      </p>
<pre>
where ({targetHits: 10}nearestNeighbor(doc_vector, query_vector))&amp;input.query(query_vector)=[3,5,7]&ranking=semantic
</pre>
      <p>
        In this example we search for the top 10 nearest neighbors in a 3-dimensional vector space.
        <em>targetHits</em> specifies the top-k nearest neighbors to expose to a user defined <code>semantic</code>
        <a href="../ranking.html">rank profile</a>. The <a href="#targethits">targetHits</a> annotation is required.
        The first parameter of <em>nearestNeighbor</em> is the name of the tensor field attribute
        containing the document vectors (<em>doc_vector</em>).
      </p>
      <p>
        The second parameter is the name of the tensor sent with the query request (<em>query_vector</em>).
        Specifying <em>query_vector</em> as the name means the query request must set this tensor as
        <em>input.query(query_vector)</em> - see the <a href="query-api-reference.html#ranking.features">reference</a>.
        The tensor type of the <b>input query vector must be defined</b> in the rank profile:
      </p>
<pre>
rank-profile semantic {
    inputs {
        query(query_vector) tensor&lt;float&gt;(x[3])
    }
    first-phase: closeness(field, doc_vector)
}
</pre>
      <p>
        Also see <a href="../ranking-expressions-features.html#query-feature-types">defining query feature types</a>.
        Failure to define the query input tensor in the schema will fail the request:
      </p>
<pre>
  Expected 'query(query_vector)' to be a tensor, but it is the string '[3,5,7]'
</pre>
      <p>The document tensor field attribute is defined as follows:</p>
<pre>
field doc_vector type tensor&lt;float&gt;(x[3]) {
    indexing: attribute | summary
}
</pre>
      <p>The above example does not define HNSW <code>index</code> and the search for neighbors will be exact.</p>
      <p>
        See <a href="../nearest-neighbor-search.html">Nearest Neighbor Search</a>,
        <a href="../approximate-nn-hnsw.html">Approximate Nearest Neighbor Search using HNSW Index</a> and
        <a href="../nearest-neighbor-search-guide.html">Nearest Neighbor Search Guide</a>
        for more detailed examples.
      </p>
      <table class="table">
        <thead>
        <tr>
          <th>Annotation</th>
          <th>Effect</th>
        </tr>
        </thead>
        <tbody>
        <tr>
          <td><a href="#targethits">targetHits</a></td>
          <td>
            This annotation is required, and specifies the number of hits nearestNeighbor
            should expose to <a href="../ranking.html">ranking</a>.
            Note that more or less hits might actually be produced. <em>targetHits</em> is per node
            involved in the query.
          </td>
        </tr>
        <tr>
          <td><a href="#approximate">approximate</a></td>
          <td>
            The optional <code>approximate</code> annotation may be set to <code>false</code>
            to not use an approximate <a href="schema-reference.html#index-hnsw">HNSW index</a>.
            This is especially useful to compare exact and approximate results in order to perform
            tuning of HNSW parameters.
            This annotation is default <code>true</code> when an HNSW index is specified,
            otherwise it is always <code>false</code>. Setting this to <code>false</code>
            might trigger <a href="../graceful-degradation.html">graceful query degradation</a>. Adjust
            <a href="#timeout">timeout</a> as needed.
          </td>
        </tr>
        <tr>
          <td><a href="#hnsw-exploreadditionalhits">hnsw.exploreAdditionalHits</a></td>
          <td>
            Tune how many extra nodes in the HNSW graph (in addition to <code>targetHits</code>)
            that should be explored before selecting the best hits. Default is <code>0</code>. Increasing
            this parameter increases the accuracy of the approximate search, at the cost of more distance computations.
          </td>
        </tr>
        <tr>
          <td><a href="#label">label</a></td>
          <td>
            Use to mark the query operator with a label
            that can be referred to from the ranking expression in the rank profile.
            See the <a href="rank-features.html#closeness(dimension,name)">closeness</a> and
            <a href="rank-features.html#distance(dimension,name)">distance</a> rank features.
            Useful when having multiple <code>nearestNeighbor</code> operators in the same query,
            e.g., when the schema has multiple vector fields.
            See <a href="../nearest-neighbor-search-guide.html#multiple-nearest-neighbor-search-operators-in-the-same-query">
              nearest neighbor search guide
            </a> for usage example.
          </td>
        </tr>
        <tr>
          <td><a href="#distancethreshold">distanceThreshold</a></td>
          <td>
            Use to filter out hits with a higher distance than a threshold.
            See
            <a href="../nearest-neighbor-search-guide.html#strict-filters-and-distant-neighbors">
              nearest neighbor search guide
            </a> for usage example.
          </td>
        </tr>
        </tbody>
      </table>
      <p>Properties:</p>
      <table class="table">
        <thead></thead><tbody>
      <tr>
        <th>Field type</th>
        <td>Tensor attribute with one indexed dimension of size N or with one mapped and one indexed dimension.</td>
      </tr><tr>
        <th>Query model</th>
        <td>Tensor with one indexed dimension of size N.</td>
      </tr><tr>
        <th>Matching</th>
        <td>Returns documents where the distance (according to the
          <a href="schema-reference.html#distance-metric">distance metric</a> used)
          between the document tensor
          and the query tensor is less than the greatest distance among the current top-k best hits.
          This means that typically more than top-k documents are matched and
          returned for ranking. This is similar to the behavior of
          <a href="#wand">wand</a>.
          When an <a href="schema-reference.html#index-hnsw">HNSW index</a> is used,
          the top-k best hits are calculated before regular matching happens,
          taking the rest of the query filters into account.</td>
      </tr><tr>
        <th>Ranking</th>
        <td>Calculates a closeness score that is defined as
          <code>1 / (1 + d)</code>, where <code>d</code> is the distance
          between the document tensor and query tensor.
          This score is available using
          <a href="rank-features.html#rawScore(field)">rawScore</a>,
          <a href="rank-features.html#itemRawScore(label)">itemRawScore</a>, or
          <a href="rank-features.html#closeness(dimension,name)">closeness</a> rank features.
          The raw distance is available using the
          <a href="rank-features.html#distance(dimension,name)">distance</a> rank feature.</td>
      </tr><tr>
        <th style="white-space:nowrap;">Java Query Item</th>
        <td><a href="https://javadoc.io/doc/com.yahoo.vespa/container-search/latest/com/yahoo/prelude/query/NearestNeighborItem.html">NearestNeighborItem</a></td>
      </tr>
      </tbody>
      </table>
    </td>
  </tr>

  <tr>
    <th>nonEmpty</th>
    <td>
      <p id="nonempty">
        <em>nonEmpty</em> takes as its only argument an arbitrary search expression.
        It will then perform a set of checks on that expression.
        If all the checks pass, the result is the same expression, otherwise the query will fail.
        The checks are as follows:
      </p>
      <ol>
        <li>No empty search term</li>
        <li>No empty operators, like phrases without terms</li>
        <li>No null markers (NullItem) from e.g. failed query parsing</li>
      </ol>
<pre>
yql=select * from sources * where bar contains "a" and nonEmpty(bar contains "bar" and foo contains @foo)&amp;foo=
</pre>
      <p>
        Note how "foo" is empty in this case, which will force the query to fail.
        If "foo" contained a searchable term, the query would not have failed.
      </p>
    </td>
  </tr>

  <tr>
    <th>predicate</th>
    <td>
      <p id="predicate">
        <em>predicate()</em> specifies a predicate query -
        see <a href="../predicate-fields.html">predicate fields</a>.
        It takes three arguments: the predicate field to search, a map of attributes, and a map of range attributes:
      </p>
<pre>
where predicate(predicate_field,{"gender":"Female"},{"age":20L})
</pre>
      <p>Due to a quirk in YQL-parsing, one cannot specify an empty map, use the number 0 instead.</p>
<pre>
where predicate(predicate_field,0,{"age":20L})
</pre>
    </td>
  </tr>

  <tr>
    <th>true</th>
    <td>
      <p id="literal.true">
        Matches all documents of any type.  Care must be taken when using this since processing all documents as matches
        is expensive.   At minimum, consider restricting to only one schema where you know the corpus isn't too big,
        see the <a href="query-api-reference.html#model.restrict">model.restrict</a> URL parameter.
      </p>
    </td>
  </tr>

  <tr>
    <th>false</th>
    <td>
      <p id="literal.false">
        Does not match any document at all.  Not useful in itself, but could potentially be used as
        a placeholder in the query tree.
      </p>
    </td>
  </tr>

</tbody>
</table>




<h2 id="order-by">order by</h2>
<!-- ToDo ref reference/query-api-reference.html#ranking.sorting -->
<p>
  Sort using <code>order by</code>.
  Add <code>asc</code> or <code>desc</code> after the name of an
  <a href="../attributes.html">attribute</a> to set sort order -
  ascending order is default. Add another sorting attributes to get a secondary sort, that will be a tiebreaker for the
  primary ordering attribute. This is typically used to get a predictable ordering when the primary ordering attribute
  has the same value for multiple documents.
</p>
<pre>
where title contains "madonna" order by price asc, releasedate desc
</pre>
<p>
  Sorting function, locale and strength are defined using the annotations "function", "locale" and "strength", as in:
</p>
<pre>
where title contains "madonna" order by {function: "uca", locale: "en_US", strength: "IDENTICAL"}other desc, {function: "lowercase"}something
</pre>
{% include note.html content="<a href='schema-reference.html#match-phase'>match-phase</a>
is enabled when sorting - refer to the <a href='sorting.html'>sorting reference</a>."%}
<p>
  The <a href="../ranking.html">rank profile</a> determines the rank score each document will get.
  Results are ordered by that value by default, but <code>order by</code> overrides that ordering.
  Vespa does not optimize away the rank score computation in this case, it is still executed, even if the model score is thrown away. Use the built-in rank-profile <em>unranked</em> for optimal performance of sorting queries.
  </p>
  <p>
  To do a primary ordering on the rank score, and a secondary sort on an attribute, use <code>'[relevance]'</code> as the first order by attribute.
  See <a href="sorting.html#special-sorting-attributes">Special sorting attributes</a> for more details.
</p>
<table class="table">
  <thead>
  <tr>
    <th>Annotation</th>
    <th>Effect</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><a href="#function">function</a></td>
    <td>
      Sort function, default UCA.
    </td>
  </tr>
  <tr>
    <td><a href="#locale">locale</a></td>
    <td>
      Locale identifier for the <a href="#function">UCA sort function</a>.
    </td>
  </tr>
  <tr>
    <td><a href="#strength">strength</a></td>
    <td>
      Strength setting for the <a href="#function">UCA sort function</a>.
    </td>
  </tr>
  </tbody>
</table>



<h2 id="limit-offset">limit / offset</h2>
<p>
  To specify a slice / limit the number of hits returned / do pagination,
  use <code>limit</code> and/or <code>offset</code>. This can also be controlled by using
  <a href="query-api-reference.html#native-execution-parameters">native execution parameters</a>.
</p>
  {% include important.html content='Values set in YQL takes precedence over
  <a href="query-api-reference.html#hits">hits/offset</a>.
  Values for hits/offset in query profiles are also overridden by YQL,
  e.g., <code>limit 100</code> overrides <code>&lt;field name="hits" overridable="false"&gt;50&lt;/field&gt;</code>.' %}
<p>
  Limited by <a href="query-api-reference.html#hits">maxHits</a> (default 400)
  and <a href="query-api-reference.html#offset">maxOffset</a> (default 1000) -
  these can be configured in a <a href="../query-profiles.html">queryProfile</a>.
</p>
<p>Example: This returns two hits (if there are sufficiently many hits matching the query),
  skipping the 29 first documents</p>
<pre>
where title contains "madonna" limit 31 offset 29
</pre>



<h2 id="timeout">timeout</h2>
<p>
  Set query timeout in milliseconds using <code>timeout</code>. This can also be controlled by using the native
  execution parameter <a href="query-api-reference.html#timeout">timeout</a>. YQL specified values takes precedence.:
</p>
<pre>
where title contains "madonna" timeout 70
</pre>
<p>
  Only literal numbers are valid, i.e. setting another unit is not supported.
</p>
{% include note.html content='The value is in milliseconds,
whereas the native execution parameter <a href="query-api-reference.html#timeout">timeout</a> is in seconds' %}



<h2 id="parameter-substitution">Parameter substitution</h2>
<p>
  The query operators <a href="#dotproduct">dotProduct(field, value)</a>,
  <a href="#weightedset">weightedSet(field, value)</a> and <a href="#wand">wand(field, value)</a>
  support parameter substitution for the <code>value</code> parameter - example of equivalent queries:
</p>
<pre>
... where weightedSet(field, {"a":1, "b":2})
... where weightedSet(field, @myset)&amp;myset={a:1,b:2}
</pre>
<p>
  Use this to:
</p>
<ul>
  <li>Simplify query generation, separating the value of the set/array from the YQL string.
    Quotes can be skipped unless the keys contain <code>,</code> or <code>:</code>.</li>
  <li>Speed up query parsing. Using parameter substitution accelerates string parsing.</li>
</ul>
<p>
  The value string can be passed in one of:
</p>
<ul>
  <li>Array form: <code>[[key, value], ...]</code></li>
  <li>Map form: <code>{key: value, ...}</code></li>
</ul>
<p>
  The query operator <a href="#userinput">userInput(value)</a>
  supports parameter substitution for the <code>value</code> parameter:
</p>
<pre>
... where userInput(@userinput)&amp;userinput=free+text
</pre>
<p>
  Use this to submit the user data unchanged for parsing in Vespa,
  without risk of corrupting the YQL query.
</p>
<!-- ToDo: Move the examples to the query-api guide instead -->



<h2 id="annotations">Annotations</h2>
<p>
  Terms and phrases can be annotated to manipulate the behavior.
  Add an annotation using <code>{}</code>:
</p>
<pre>
where text contains ({distance: 5}near("a", "b")) and text contains ({distance:2}near("c", "d"))
</pre>
<p>Note that the annotation is enclosed by parentheses to scope the annotation to the operator.
</p>
<p>
  All annotations are supported by the string arguments to functions like
  and phrase() and near() and also the string argument to the "contains" operator.
  Some annotations are also supported by the functions which are handled like leaf nodes internally in the query tree:
  phrase(), near(), onear(), range(), equiv(), dotProduct(), weightedSet(), weakAnd(), wand() and nearestNeighbor().
</p>
<p>
  Refer to <a href="https://github.com/vespa-engine/vespa/blob/master/container-search/src/test/java/com/yahoo/select/SelectTestCase.java">
  SelectTestCase.java</a> for sample usage. <!-- ToDo: improve this a little or add examples elsewhere, from this -->
</p>
<table class="table">
  <thead>
  <tr>
    <th>Annotation</th>
    <th>Default</th>
    <th>Values</th>
    <th>Description</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td>accentDrop</td>
    <td>true</td>
    <td>boolean</td>
    <td><p id="accentdrop">
      Remove accents from this term if it is the setting for this field.
      Refer to <a href="../linguistics.html#normalization">linguistics</a>.
    </p></td>
  </tr>
  <tr>
    <td>allowEmpty</td>
    <td>false</td>
    <td>boolean</td>
    <td>
      <p id="allowempty">
      Whether to allow empty input for query parsing and query terms in <a href="#userinput">userInput</a>.
      If <code>true</code>, a NullItem instance is inserted in the proper place in the query tree.
      If <code>false</code>, the query will fail if the user provided input can not be parsed or is empty.
      </p>
    </td>
  </tr>
  <tr>
    <td>andSegmenting</td>
    <td></td>
    <td>true|false</td>
    <td>
      <p id="andsegmenting">
      Force phrase or AND operator if re-segmenting (e.g. in stemming) this term results in multiple terms.
      Default is choosing from language settings.
      </p>
      <!-- Too: Add an example -->
    </td>
  </tr>
  <tr>
    <td>annotations</td>
    <td></td>
    <td>map</td>
    <td>
      <p id="annotations-table">
      Map of <code>string: string</code>. Custom annotations. No special semantics inside the YQL layer. Example:
      </p>
      <pre>annotations : {cox: "another"}</pre>
    </td>
  </tr>
  <tr>
    <td>approximate</td>
    <td></td>
    <td>boolean</td>
    <td>
      <p id="approximate">
      Used in <a href="#nearestneighbor">nearestNeighbor</a>.
      The optional <em>approximate</em> annotation may be set to <code>false</code> to disallow usage of an approximate
      <a href="schema-reference.html#index-hnsw">HNSW index</a>.
      This is especially useful to compare exact and approximate results in order to perform tuning of other parameters.
      This annotation is default <code>true</code> when an HNSW index is specified,
      otherwise it is always <code>false</code>.
      </p>
    </td>
  </tr>
  <tr>
    <td>ascending</td>
    <td></td>
    <td>boolean</td>
    <td>
      <p id="ascending">Ascending hit order. Used by <a href="#hitlimit">hitLimit</a>.</p>
    </td>
  </tr>
  <tr>
    <td>bounds</td>
    <td><code>closed</code></td>
    <td>enum</td>
    <td>
      <p id="bounds">
      A <a href="#numeric">numeric</a> interval is by default a closed interval.
      If the lower bound is exclusive, set to <code>leftOpen</code>.
      If the upper bound is exclusive, set to <code>rightOpen</code>.
      If both bounds are exclusive, set the annotation to <code>open</code>.
      Example:
      </p>
      <pre>where ({bounds:"rightOpen"}range(year, 2000, 2018))</pre>
    </td>
  </tr>
  <tr>
    <td>connectivity</td>
    <td></td>
    <td>map</td>
    <td>
      <p id="connectivity">
      Map of <code>id: int, weight: double</code> of explicit connectivity between this item
      and the item with the given <a href="#id">id</a> -
      see <a href="../ranking.html#weight-significance-and-connectedness">text matching and ranking</a>.
      Example:
      </p>
      <pre>connectivity: {id: 4, weight: 0.8}</pre>
      <!-- ToDo: verify that the keys in the map do not have to be quoted -->
    </td>
  </tr>
  <tr>
    <td>descending</td>
    <td></td>
    <td>boolean</td>
    <td>
      <p id="descending">Descending hit order. Used by <a href="#hitlimit">hitLimit</a>.</p>
    </td>
  </tr>
  <tr>
    <td>defaultIndex</td>
    <td><code>default</code></td>
    <td>Any searchable field in the schema.</td>
    <td>
      <p id="defaultindex">
      Used by <a href="#userinput">userInput</a>.
      Same as <a href="query-api-reference.html#model.defaultindex">model.defaultIndex</a> in the query API.
      If <a href="#grammar">grammar</a> is set to <code>raw</code> or <code>segment</code>,
      this will be the field searched.
      </p>
    </td>
  </tr>
  <tr>
    <td>distance</td>
    <td>2</td>
    <td>int</td>
    <td>
      <p id="distance">
      The <em>distance</em>-annotation sets the maximum position difference to count as a match,
      see <a href="#near">near</a> / <a href="#onear">onear</a>.
      The default distance is 2, meaning match if the words have up to one separating word.
      </p>
<pre>
where text contains ({distance: 5}near("a", "b"))
</pre>
    </td>
  </tr>
  <tr>
    <td>distanceThreshold</td>
    <td>+infinity</td>
    <td>double</td>
    <td>
      <p id="distancethreshold">
      Used in <a href="#nearestneighbor">nearestNeighbor</a>.
      The <code>distanceThreshold</code> annotation may be used to filter away hits
      with a higher distance than the given threshold from the results.
      Note that one will never get more hits with <code>distanceThreshold</code> than you would get without it -
      to get more hits, increase <a href="#targethits">targetHits</a>, too.
      The units for the threshold depends on the
      <a href="schema-reference.html#distance-metric">distance metric</a> used.
      </p>
    </td>
  </tr>
  <tr>
    <td>endAnchor</td>
    <td>true</td>
    <td>boolean</td>
    <td>
      <p id="endanchor">
        The <code>hostname</code> subfield of <a href="#uri">uri</a>
        supports anchoring to the start and/or end of the hostname,
        controlled by the <code>startAnchor</code> and <code>endAnchor</code> annotations.
        Anchoring to the end is on by default while anchoring to the start is not. Hence
      </p>
<pre>
where myUrlField.hostname contains uri("vespa.ai")
</pre>
      <p>will match <em>vespa.ai</em> and <em>docs.vespa.ai</em>, while</p>
<pre>
where myUrlField.hostname contains ({startAnchor: true}uri("vespa.ai"))
</pre>
      <p>will only match vespa.ai.</p>
    </td>
  </tr>
  <tr>
    <td>filter</td>
    <td>false</td>
    <td>boolean</td>
    <td><p id="filter">
      Regard this term as a "filter" term and not a term from the end user.
      Terms that are annotated with "filter:true" are not bolded.
      See also <a href="query-api-reference.html#model.filter">model.filter</a>. Bolding of terms
      is controlled by <a href="schema-reference.html#bolding">schema:bolding</a>.
    </p></td>
  </tr>
  <tr>
    <td>function</td>
    <td></td>
    <td></td>
    <td>
      <p id="function">
        Default sort function for strings is <code>uca</code>.
        Field sort specification can be configured in the <a href="schema-reference.html#sorting">schema</a>,
        values in the query overrides the schema settings.
      </p>
      <p>
        Numeric fields are numerically sorted.
      </p>
      <table class="table">
        <thead>
        <tr>
          <th>Function</th>
          <th>Description</th>
        </tr>
        </thead>
        <tbody>
        <tr>
          <td><code>uca</code></td>
          <td>
            <p id="uca">
              This sorting is based on the <a href="https://icu.unicode.org/">icu</a> library
              that follows the <a href="https://unicode.org/reports/tr10/">
              Universal Collation Algorithm</a>.
              The specifications of
              <a href="https://github.com/unicode-org/icu/blob/main/icu4j/main/classes/core/src/com/ibm/icu/util/ULocale.java">locale</a>
              and <a href="https://github.com/unicode-org/icu/blob/main/icu4j/main/classes/collate/src/com/ibm/icu/text/Collator.java">strength</a>
              are identical to how <a href="https://icu.unicode.org/">icu</a> specifies them.
            </p>
            <p>
              Both <a href="#locale">locale</a> and <a href="#strength">strength</a> are optional,
              however <code>strength</code> requires <code>locale</code>.
            </p>
            <p>
              The <a href="#locale">locale</a> query annotation will override
              locale-setting in the <a href="schema-reference.html#sorting">schema</a>.
              If <code>locale</code> is missing from both, the <code>lowercase</code> function will be used by default.
            </p>
          </td>
        </tr>
        <tr>
          <td><code>lowercase</code></td>
          <td>
            <p id="lowercase">
            This improves the sorting by first lowercasing and normalising the strings before sorting.
            This is slightly more correct and might be enough for the use case.
            It is not that much more costly than <code>raw</code> sort, and less expensive than <code>uca</code>.
            </p>
          </td>
        </tr>
        <tr>
          <td><code>raw</code></td>
          <td>
            <p id="raw">
            Raw byteorder is a simple and fast ordering based on memcmp of utf8 for strings
            and correct sort order compliant binary rep for other fields is done.
            However, that is not correct for anything except computers,
            looking only at the binary representation.
            </p>
          </td>
        </tr>
      </tbody>
      </table>
    </td>
  </tr>
  <tr>
    <td>grammar</td>
    <td><code>weakAnd</code></td>
    <td><code>raw</code>, <code>segment</code> and all values accepted for the
      <a href="query-api-reference.html#model.type">model.type</a> argument in the query API.</td>
    <td>
      <p id="grammar">
      How to parse <a href="#userinput">userInput</a>.
      <code>raw</code> will treat the user input as a string to be matched without any processing,
      <code>segment</code> will do a first pass through the linguistic libraries,
      while the rest of the values will treat the string as a query to be parsed.
      If query parsing fails, an error message will be returned.
      <a href="../query-api.html#input-examples">Example</a>.
      </p>
    </td>
  </tr>
  <tr>
    <td>hitLimit</td>
    <td></td>
    <td>int</td>
    <td>
      <p id="hitlimit">
        <a href="#numeric">Numeric</a> operations support <code>hitLimit</code>.
        This is used for <em>capped range search</em>.
        An alternative to using negative and positive values for hitLimit is always using a positive number of hits
        (as a negative number of hits does not make much sense) and combine this with either of the
        <a href="#ascending">ascending</a> and <a href="#descending">descending</a> annotations (but not both).
        Example: <code>{hitLimit: 38, descending: true}</code> would be equivalent to setting it to -38,
        i.e. only populate with 38 hits and start from upper boundary, i.e. descending order.
      </p>
      <p>
        Note that <code>hitLimit</code> will limit the number of documents that are considered.
        This is a powerful optimisation that must be used with care,
        particularly in combination with other filters.
        The set of documents to be considered will be limited upfront
        by only selecting the N best according to the range query and the hitLimit annotation,
        for further query evaluation.
      </p>
      <p>
        <code>hitLimit</code> is not exact, but "at least".
        In addition, it will only kick in if the attribute has <a href="schema-reference.html#attribute">fast-search</a>.
        It will look up the upper or lower bound in the range in the dictionary and scan in ascending or descending order
        and select entries until it has satisfied hitLimit.
        You will get all documents for all the dictionary entries selected.
      </p>
      <p>
        See the <a href="../performance/practical-search-performance-guide.html#advanced-range-search-with-hitlimit">
        practical-search-performance-guide</a> for an example.
      </p>
    </td>
  </tr>
  <tr>
    <td>hnsw.exploreAdditionalHits</td>
    <td></td>
    <td></td>
    <td>
      <p id="hnsw-exploreadditionalhits">
      Used in <a href="#nearestneighbor">nearestNeighbor</a>.
      When using an <a href="schema-reference.html#index-hnsw">HNSW index</a>,
      the optional <code>hnsw.exploreAdditionalHits</code> annotation can be used to
      tune how many extra nodes in the graph (in addition to <code>targetHits</code>)
      should be explored before selecting the best hits.
      Using a greater number here gives better quality, but worse performance.
      </p>
    </td>
  </tr>
  <tr>
    <td>id</td>
    <td></td>
    <td>int</td>
    <td><p id="id">Unique ID used for e.g. <a href="#connectivity">connectivity</a>.</p></td>
  </tr>
  <tr>
    <td>implicitTransforms</td>
    <td>true</td>
    <td>boolean</td>
    <td>
      <p id="implicittransforms">
        Implicit term transformations (field defaults).
        If <code>implicitTransforms</code> is true,
        the settings for the field in the schema will be honored in term transforms,
        e.g. if the field has stemming, this term will be stemmed.
        If <code>implicitTransforms</code> is false,
        the search backend will receive the term exactly as written in the initial YQL expression.
        This is in other words a top level switch to turn off all other
        <a href="../linguistics.html#stemming">stemming</a>, accent removal, Unicode
        <a href="../linguistics.html#normalization">normalizations</a> and so on.
      </p>
    </td>
  </tr>
  <tr>
    <td>label</td>
    <td></td>
    <td>string</td>
    <td>
      <p id="label">
      Used by <a href="#geolocation">geoLocation</a>
      and <a href="#nearestneighbor">nearestNeighbor</a>. <!-- ToDo: and probably others ... -->
      Label for referring to this term/operator during ranking.
      </p>
    </td>
  </tr>
  <tr>
    <td>language</td>
    <td></td>
    <td>RFC 3066 language code</td>
    <td>
      <p id="language">
      Language setting for the linguistics handling of <a href="#userinput">userInput</a>,
      also see <a href="query-api-reference.html#model.language">model.language</a> in the query API reference.
      </p>
    </td>
  </tr>
  <tr>
    <td>locale</td>
    <td></td>
    <td></td>
    <td>
      <p id="locale">
      Used by the <a href="#function">UCA sort function</a>.
      An identifier following <a href="https://www.unicode.org/reports/tr35/#Unicode_Language_and_Locale_Identifiers">
      unicode locale identifiers</a>, e.g. <code>en_US</code>.
      </p>
    </td>
  </tr>
  <tr>
    <td>maxEditDistance</td>
    <td>2</td>
    <td>int</td>
    <td>
      <p id="maxeditdistance">
        Used in <a href="#fuzzy">fuzzy</a>. An inclusive upper bound of edit distance between query and string attribute.
      </p>
    </td>
  </tr>
  <tr>
    <td>nfkc</td>
    <td>true</td>
    <td>boolean</td>
    <td><p id="nfkc">NFKC <a href="../linguistics.html#normalization">normalization</a>.</p></td>
  </tr>
  <tr>
    <td>normalizeCase</td>
    <td>true</td>
    <td>boolean</td>
    <td><p id="normalizecase">Normalize casing of this term if it is the setting for this field.</p></td>
  </tr>
  <tr>
    <td>origin</td>
    <td></td>
    <td>map</td>
    <td>
      <p id="origin">
      Map of <code>original: string, offset: int, length: int</code>.
      The (sub-)string which produced this term. Default unset. Example:
      </p>
      <pre>origin: {original: "abc", offset: 1, length: 2}</pre>
    </td>
  </tr>
  <tr>
    <td>prefix</td>
    <td>false</td>
    <td>boolean</td>
    <td><p id="prefix">Do <a href="schema-reference.html#prefix">prefix matching</a> for this term,
      e.g. search for "word*".</p></td>
  </tr>
  <tr>
      <td>substring</td>
      <td>false</td>
      <td>boolean</td>
      <td>Do substring matching for this word if available in the index. ("Search for "*word*".")
          Only supported for <a href="../streaming-search.html">streaming search</a>.</td>
  </tr>
  <tr>
    <td>prefixLength</td>
    <td>0</td>
    <td>int</td>
    <td><p id="prefixlength">Used in <a href="#fuzzy">fuzzy</a>. Number of characters that are considered frozen, so the fuzzy match will be performed with the suffix left.</p></td>
  </tr>
  <tr>
    <td>ranked</td>
    <td>true</td>
    <td>boolean</td>
    <td>
      <p id="ranked">
      Include this term for ranking calculation. Setting ranked to false can speed up query evaluation.
      Read more about <a href="schema-reference.html#rank">schema reference</a>.
      <a href="../ranking-expressions-features.html#dumping-rank-features-for-specific-documents">Example</a>
      </p>
    </td>
  </tr>
  <tr>
    <td>scoreThreshold</td>
    <td></td>
    <td>double / integer</td>
    <td>
      <p id="scorethreshold">
      Both <a href="#wand">wand</a> and <a href="#weakand">weakAnd</a> supports <code>scoreThreshold</code>,
      which is a double for <code>wand</code> and an integer for <code>weakAnd</code>.
      This threshold specifies the minimum score for hits to include.
      The <code>wand</code> / <code>weakAnd</code> operators both expose hits
      that were evaluated during the search to the first-phase ranking expression, and not only <em>targetHits</em>.
      </p>
    </td>
  </tr>
  <tr>
    <td>significance</td>
    <td></td>
    <td>double</td>
    <td>
      <p id="significance">
      Significance value for text ranking features -
      see <a href="../ranking.html#weight-significance-and-connectedness">text matching and ranking</a>.
      </p>
    </td>
  </tr>
  <tr>
    <td>startAnchor</td>
    <td>false</td>
    <td>boolean</td>
    <td><p id="startanchor">See <a href="#endanchor">endAnchor</a>.</p></td>
  </tr>
  <tr>
    <td>stem</td>
    <td>true</td>
    <td>boolean</td>
    <td><p id="stem">Stem this term if it is the setting for this field.</p></td>
  </tr>
  <tr>
    <td>strength</td>
    <td><code>PRIMARY</code></td>
    <td>
      <ul>
        <li><code>PRIMARY</code></li>
        <li><code>SECONDARY</code></li>
        <li><code>TERTIARY</code></li>
        <li><code>QUATERNARY</code></li>
        <li><code>IDENTICAL</code></li>
      </ul>
    </td>
    <td>
      <p id="strength">
      Used by the <a href="#function">UCA sort function</a>.
      Default is <code>PRIMARY</code>, which only sorts on primary differentiating characteristics;
      this means that letters in uppercase/lowercase or with differences in accents only are considered equal.
      </p>
    </td>
  </tr>
  <tr>
    <td>suffix</td>
    <td>false</td>
    <td>boolean</td>
    <td><p id="suffix">Do <em>suffix matching</em> for this term, e.g. search for "*word".</p></td>
  </tr>
  <tr>
    <td>targetHits</td>
    <td>100</td>
    <td>int</td>
    <td>
      <p id="targethits">
        Used by <a href="#wand">wand</a>and <a href="#weakand">weakAnd</a>, where the default is 100.
      </p>
      <p>
        It is also used with <a href="#nearestneighbor">nearestNeighbor</a>,
        where it has no default - it must always be set,
        see examples in <a href="../nearest-neighbor-search.html">nearest neighbor search</a>.
      </p>
      <p>
        It sets the wanted number of hits exposed to the real first-phase ranking function per content node.
        If additional second phase ranking with rerank-count is used,
        do not set <code>targetHits</code> less than the configured rank-profile's
        <a href="schema-reference.html#secondphase-rerank-count">rerank-count</a>.
      </p>
    </td>
  </tr>
  <tr>
    <td>usePositionData</td>
    <td>true</td>
    <td>boolean</td>
    <td>
      <p id="usepositiondata">
      Use term position data for text ranking features such as <a href="../nativerank.html">nativeRank</a>.
      This is <em>term</em> position, not to be confused with
      <a href="../geo-search.html">geo searches</a>. Setting "usePositionData:false" can improve query performance.
      </p>
      <!-- ToDo: Add more documentation / link somewhere. Not sure how to use this ... -->
    </td>
  </tr>
  <tr>
    <td>weight</td>
    <td>100</td>
    <td>int</td>
    <td>
      <p id="weight">
      Term weight, used in some text ranking features -
      see <a href="../ranking.html#weight-significance-and-connectedness">text matching and ranking</a>.
      </p>
<pre>
where title contains ({weight:200}"heads")
</pre>
    </td>
  </tr>
  </tbody>
</table>


<h3 id="annotations-of-sub-expressions">Annotations of sub-expressions</h3>
<p>
  Consider the following query:
</p>
<pre>
select * from sources * where ({stem: false}(foo contains "a" and bar contains "b")) or foo contains {stem: false}"c"
</pre>
<p>
  The "stem" annotation controls whether a given term should be stemmed if its
  field is configured as a stemmed field (default is "true").
  The "AND" operator itself has no internal API for whether its operands should be stemmed or not,
  but we can still annotate as such,
  because when the value of a given annotation is determined,
  the expression tree is followed from the term in question and up through its ancestors.
  Traversing the tree stops when a value is found (or there is nothing more to traverse).
  In other words, none of the terms in this example will be stemmed.
</p>
<p>
  How annotations behave may be easier to understand of expressing a boolean query in the style of an S-expression:
</p>
<pre>
(AND term1 term2 (OR term3 term4) (OR term5 (AND term6 term7)))
</pre>
<p>
  The annotation scopes would then be as follows, i.e. annotations on
  which elements will be checked when determining the settings for a given term:
</p>
<table class="table">
  <thead></thead><tbody>
<tr><td>term1</td><td>term1 itself, and the first AND</td></tr>
<tr><td>term2</td><td>term2 itself, and the first AND</td></tr>
<tr><td>term3</td><td>term3 itself, the first OR and the first AND</td></tr>
<tr><td>term4</td><td>term4 itself, the first OR and the first AND</td></tr>
<tr><td>term5</td><td>term5 itself, the second OR and the first AND</td></tr>
<tr><td>term6</td><td>term6 itself, the second AND, the second OR and the first AND</td></tr>
<tr><td>term7</td><td>term7 itself, the second AND, the second OR and the first AND</td></tr>
</tbody>
</table>



<h2 id="query-properties">Query properties</h2>
<p>
  Use YQL variable syntax to initialize words in phrases and as single terms.
  This removes the need for caring about quoting a term in YQL, as well as URL quoting.
  The term will be used <em>exactly</em> as it is in the URL.
  As an example, look at a query with a YQL argument, and the properties
  <em>animal</em> and <em>syntaxExample</em>:
</p>
<pre>
yql=select * from sources * where foo contains @animal and foo contains phrase(@animal, @syntaxExample, @animal)&amp;animal=panda&amp;syntaxExample=syntactic
</pre>
<p>
  This YQL expression will then access the query properties <em>animal</em> and
  <em>syntaxExample</em> and evaluate to:
</p>
<pre>
select * from sources * where (foo contains "panda" AND foo contains phrase("panda", "syntactic", "panda"))
</pre>



<h2 id="yql-in-query-profiles">YQL in query profiles</h2>
<p>
  YQL requires quoting to be included in a URL.
  Since YQL is well suited to application logic, while not being intended for end users,
  a solution to this is storing the application's YQL queries into different
  <a href="../query-profiles.html">query profiles</a>.
  To add a default query profile, add <em>search/query-profiles/default.xml</em> to the
  <a href="../application-packages.html">application package</a>:
</p>
<pre>
&lt;query-profile id="default"&gt;
    &lt;field name="yql"&gt;select * from sources * where default contains "latest" or userQuery()&lt;/field&gt;
&lt;/query-profile&gt;
</pre>
<p>
  This will add <em>latest</em> as an <em>OR term</em> to all queries not having an explicit query profile parameter.
  The important thing to note is how it is not necessary to URL-quote anything in the query profiles files.
  They operate independently of the HTTP parsing as such.
</p>



<h2 id="query-rewriting-in-searchers">Query rewriting in Searchers</h2>
<p>
  Searchers which modifies the textual YQL statement (not recommended)
  should be annotated with <code>@Before("ExternalYql")</code>.
  Searchers modifying query tree produced from an input YQL statement
  should annotate with <code>@After("ExternalYql")</code>.
</p>



<h2 id="grouping">Grouping</h2>
<p>
  Group / aggregate results by adding a grouping expression after a <code>|</code> -
  <a href="../grouping.html">read more</a>.
</p>
<pre>
select * from sources * where sddocname contains 'purchase' | all(group(customer) each(output(sum(price))))
</pre>
