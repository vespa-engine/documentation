---
# Copyright Yahoo. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.
title: "Query Language Reference"
redirect_from:
- /documentation/reference/query-language-reference.html
---

<p>
Vespa accepts unstructured human input and structured queries for application logic separately,
then combines them into a single data structure for executing.
Human input is parsed heuristically, while application queries are formulated in YQL.
</p><p>
A query URL looks like:
</p>
<pre>
http://myhost.mydomain.com:8080/search/?yql=select%20%2A%20from%20sources%20%2A%20where%20text%20contains%20%22blues%22
</pre>
In other words, <em>yql</em> contains:
<pre class="urlunencode" oncopy="">
select%20%2A%20from%20sources%20%2A%20where%20text%20contains%20%22blues%22
</pre>
<p>
This <a href="schema-reference.html#match">matches</a> all documents
where the field named <em>text</em> contains the word <em>blues</em>.
</p>
<p>
  Quote <code>"</code> and backslash <code>\</code> characters in text values must be escaped by a backslash.
</p>
{% include note.html content="There is no way to query for a field equals <code>null</code> or <code>NaN</code>.
Work around using a <code>not</code> clause."%}
{% include note.html content="Since Vespa 7.520.3, YQL queries do not require a semicolon at the end."%}



<h2 id="select">select</h2>
<p>
<em>select</em> is the list of <a href="../schemas.html#indexing">summary fields</a> requested
(a field with the <code>summary</code> index attribute).
Vespa will hide other fields in the matching documents.
</p>
<pre class="urlunencode" oncopy="">
select%20price,isbn%20from%20sources%20%2A%20where%20title%20contains%20%22madonna%22
</pre>
<p>
  The above explicitly requests the fields "price" and "isbn" (from all sources).
  To request all fields, use an asterisk as field selection:
</p>
<pre class="urlunencode" oncopy="">
select%20*%20from%20sources%20%2A%20where%20title%20contains%20%22madonna%22
</pre>



<h2 id="from-sources">from sources</h2>
<!-- ToDo: describe how this is equal to model.sources -->
<p>
  <em>from sources</em> specifies which content
  <a href="query-api-reference.html#model.sources">sources</a> to query. Example:
</p>
<pre class="urlunencode" oncopy="">
select%20%2A%20from%20music%20where%20title%20contains%20%22madonna%22
</pre>
<p>
  queries all document types in the <em>music</em> content cluster or federation source. Query in:
</p>
<table class="table">
<thead></thead><tbody>
  <tr><td>all sources</td>
      <td><code>select … from <strong>sources *</strong> where …</code></td></tr>
  <tr><td>a set of sources</td>
      <td><code>select … from <strong>sources source1, source2</strong> where …</code></td></tr>
  <tr><td>a single source</td>
      <td><code>select … from <strong>source1</strong> where …</code></td></tr>
</tbody>
</table>
<p>
  In other words, <em>sources</em> is used for querying some/all sources.
  If only a single source is queried, the <em>sources</em> keyword is dropped.
  To restrict the query to only one schema (aka document type) use the
  <a href="query-api-reference.html#model.restrict">model.restrict</a> URL parameter.
  Also see <a href="../federation.html">federation</a>.
</p>



<h2 id="where">where</h2>

<p>The <code>where</code> clause is a tree of operators:</p>

<table class="table">
  <thead></thead>
  <tbody>

  <tr id="numeric"><th>numeric</th><td>
    <p>
    The following numeric operators are available:
    <code>= &lt; &gt; &lt;= &gt;= range(field, lower bound, upper bound)</code>.
    </p>
<pre class="urlunencode" oncopy="">
where%20500%20%3E%3D%20price
</pre>
<pre class="urlunencode" oncopy="">
where%20range%28fieldname%2C%200%2C%205000000000L%29
</pre>
    <p>
      Numbers must be in the signed 32-bit range, or the string <code>Infinity</code> or <code>-Infinity</code>.
    Input 64-bit signed numbers using <code>L</code> as suffix.
    </p>
    <table class="table">
      <thead>
      <tr>
        <th>Annotation</th>
        <th>Effect</th>
      </tr>
      </thead>
      <tbody>
      <tr>
        <td><a href="#bounds">bounds</a></td>
        <td>Range: open or closed interval.</td>
      </tr>
      <tr>
        <td><a href="#hitlimit">hitLimit</a></td>
        <td>Used for <em>capped range search</em>.</td>
      </tr>
      </tbody>
    </table>
    <p>
    The <a href="schema-reference.html#type:weightedset">weightedset</a> field does not support filtering on weight.
    Solve this using the <a href="schema-reference.html#type:map">map</a> type and
    <a href="#sameelement">sameElement</a> query operator -
    see <a href="../query-language.html#map">example</a>.
    </p>
  </td></tr>

  <tr id="boolean"><th>boolean</th><td>
    <p>The boolean operator is: <code>=</code></p>
<pre class="urlunencode" oncopy="">
where%20alive%20%3D%20true
</pre>
  </td></tr>

  <tr id="contains"><th>contains</th><td>
    <p>
    The right-hand side argument of the contains operator is either a string literal,
    or a function, like <code>phrase</code>.
    </p>
    <p>
    <code>contains</code> is the basic building block for text matching.
    The kind of <a href="schema-reference.html#match">matching</a>
    to be done depends on the field settings in the schema.
    </p>
<pre class="urlunencode" oncopy="">
where%20title%20contains%20%22madonna%22
</pre>
    <table class="table">
      <thead>
      <tr>
        <th>Annotation</th>
        <th>Effect</th>
      </tr>
      </thead>
      <tbody>
      <tr>
        <td><a href="#stem">stem</a></td>
        <td>
          By default, the string literal is <a href="../linguistics.html#tokenization">tokenized</a>
          to match the field(s) searched.
          Explicitly control tokenization by using <a href="#stem">stem</a>:
          <pre class="urlunencode" oncopy="">
where%20title%20contains%20(%7Bstem%3A%20false%7D%22madonna%22)
</pre></td>
      </tr>
      </tbody>
    </table>
    <p>
    The matched field must be an
    <a href="../schemas.html#indexing">indexed field or attribute</a>.
    </p><p>
    Fields inside structs are referenced using dot notation -
    e.g <code>mystruct.mystructfield</code>.
    </p>


    <table class="table">

      <tr id="and">
        <th>and</th>
        <td>
          <code>and</code> accepts other <code>and</code> statements, <code>or</code> statements,
          <a href="#userquery">userQuery</a>, logically inverted statements -
          and contains statements as arguments:
<pre class="urlunencode" oncopy="">
where%20title%20contains%20%22madonna%22%20and%20title%20contains%20%22saint%22
</pre>
        </td>
      </tr>

      <tr id="or">
        <th>or</th>
        <td>
          <code>or</code> accepts other <code>or</code> statements, <code>and</code> statements,
          <a href="#userquery">userQuery</a> - and contains statements as arguments:
<pre class="urlunencode" oncopy="">
where%20title%20contains%20%22madonna%22%20or%20title%20contains%20%22saint%22
</pre>
        </td>
      </tr>

      <tr id="not">
        <th>not</th>
        <td>
          Use the <code>!</code> operator to match document that does <i>not</i> satisfy some condition:
<pre class="urlunencode" oncopy="">
where%20title%20contains%20%22madonna%22%20and%20%21%28title%20contains%20%22saint%22%29
</pre>
        </td>
      </tr>

      <tr id="phrase">
        <th>phrase</th>
        <td>
          Phrases are expressed as a function:
<pre class="urlunencode" oncopy="">
where%20text%20contains%20phrase%28%22st%22%2C%20%22louis%22%2C%20%22blues%22%29
</pre>
        </td>
      </tr>

      <tr id="near">
        <th>near</th>
        <td>
          <code>near()</code> matches if all argument terms occur close to each other in the same document.
          <table class="table">
            <thead>
            <tr>
              <th>Annotation</th>
              <th>Effect</th>
            </tr>
            </thead>
            <tbody>
            <tr>
              <td><a href="#distance">distance</a></td>
              <td>Tune closeness using <em>distance</em>.</td>
            </tr>
            </tbody>
          </table>
        </td>
      </tr>

      <tr id="onear">
        <th>onear</th>
        <td>
          <code>onear()</code> (ordered near) is like <code>near()</code>,
          but also requires the terms in the document having the same order
          as given in the function (i.e. it is a phrase allowing other words interleaved).
          With distance 1, <code>onear()</code> has the same semantics as <code>phrase()</code>.
          <table class="table"> <!-- ToDo: Assuming near and onear support the same annotations -->
            <thead>
            <tr>
              <th>Annotation</th>
              <th>Effect</th>
            </tr>
            </thead>
            <tbody>
            <tr>
              <td><a href="#distance">distance</a></td>
              <td>Tune closeness using <code>distance</code>.</td>
            </tr>
            </tbody>
          </table>
        </td>
      </tr>

      <tr id="sameelement">
        <th>sameElement</th>
        <td>
          <p>
            <em>sameElement()</em> is an operator that requires the terms to match within the same struct element
            in an array or a map field. Example:
          </p>
<pre>
struct person {
    field first_name    type string {}
    field last_name     type string {}
    field year_of_birth type int {}
}

field persons type array&lt;person&gt; {
    indexing: summary
    struct-field first_name    { indexing: attribute }
    struct-field last_name     { indexing: attribute }
    struct-field year_of_birth { indexing: attribute }
}
field identities type map&lt;string, person&gt; {
    indexing: summary
    struct-field key                 { indexing: attribute }
    struct-field value.first_name    { indexing: attribute }
    struct-field value.last_name     { indexing: attribute }
    struct-field value.year_of_birth { indexing: attribute }
}
</pre>
          <p>
            With normal <em>AND</em> the query <code>persons.first_name AND persons.last_name</code>
            will normally not give you what you want.
            It will match if a document has a <em>persons</em> element with a matching <em>first_name</em>
            <em>AND</em> any element with a matching <em>last_name</em>.
            So you will get a lot of false positives since there is nothing limiting them to the same element.
            However, that is what <em>sameElement</em> ensures.
          </p>
<pre class="urlunencode" oncopy="">
where%20persons%20contains%20sameElement%28first_name%20contains%20'Joe',%20last_name%20contains%20'Smith',%20year_of_birth%20%3C%201940%29
</pre>
          <p>
            The above returns all documents containing Joe Smith born before 1940 in the <em>persons</em> array.
          </p>
          <p>
            Searching in a map is similar to searching in an array of struct.
            The difference is that you have an extra synthetic struct with the field members <em>key</em> and <em>value</em>.
            The above example with the <em>identities</em> map looks like this:
          </p>
<pre class="urlunencode" oncopy="">
where%20identities%20contains%20sameElement%28key%20contains%20'father',%20value.first_name%20contains%20'Joe',%20value.last_name%20contains%20'Smith',%20value.year_of_birth%20%3C%201940%29
</pre>
          <p>
            The above returns all documents that have tagged Joe Smith born before 1940 as a 'father'.
            The importance here is using the indirection of <em>key</em> and <em>value</em>
            to address the keys and the values of the map.
          </p>
        </td>
      </tr>

      <tr id="equiv"><th>equiv</th><td>
        <p>
          If two terms in the same field should give exactly the same behavior when matched,
          the <code>equiv()</code> operator behaves like a special case of <code>or</code>.
        </p>
<pre class="urlunencode" oncopy="">
where%20fieldName%20contains%20equiv%28%22A%22%2C%22B%22%29
</pre>
        <p>
          In many cases, the OR operator will give the same results as an EQUIV.
          The matching logic is exactly the same,
          and an OR does not have the limitations that EQUIV does (below).
          The difference is in how matches are visible to ranking functions.
          All words that are children of an OR count for ranking.
          When using an EQUIV however, it looks like a single word:
        </p>
        <ul>
          <li>Counts as only +1 for queryTermCount</li>
          <li>Counts as 1 word for completeness measures</li>
          <li>Proximity will not discriminate different words inside the EQUIV</li>
          <li>Connectivity can be set between the entire EQUIV and the word before and after</li>
          <li>Items inside the EQUIV are not directly visible to ranking features,
            so weight and connectivity on those will have no effect</li>
        </ul>
        <p>Limitations on how <code>equiv</code> can be used in a query:</p>
        <ul>
          <li><code>equiv</code> may not appear inside a phrase</li>
          <li>It may only contain <code>TermItem</code> and <code>PhraseItem</code> instances.
            Operators like <code>and</code> cannot be placed inside <code>equiv</code></li>
          <li><code>PhraseItems</code> inside <code>equiv</code> will rank like as if they have size 1</li>
        </ul>
        <p>Learn how to use <a href="../query-rewriting.html#equiv">equiv</a>.</p>
      </td>
      </tr>

      <tr id="uri">
        <th>uri</th>
        <td>
          <p>Used to search for urls indexed using the
            <a href="schema-reference.html#type:uri">uri field type</a>.</p>
<pre class="urlunencode" oncopy="">
where%20myUrlField%20contains%20uri(%22vespa.ai%2Ffoo%22)
</pre>
          <p>Various subfields are supported to search components of the URL, see the field type definition.</p>
          <table class="table">
            <thead>
            <tr>
              <th>Annotation</th>
              <th>Effect</th>
            </tr>
            </thead>
            <tbody>
            <tr>
              <td><a href="#startanchor">startAnchor</a></td>
              <td>Anchor uri.hostname at start.</td>
            </tr>
            <tr>
              <td><a href="#endanchor">endAnchor</a></td>
              <td>Anchor uri.hostname at end.</td>
            </tr>
            </tbody>
          </table>
        </td>
      </tr>

    </table></td>
  </tr>

  <tr id="matches">
    <th>matches</th>
    <td>
      <p>
        Regular expressions is supported using
        <a href="https://en.wikibooks.org/wiki/Regular_Expressions/POSIX_Extended_Regular_Expressions">posix extended syntax</a>
        with the limitation that it is <strong>case insensitive</strong>.
        Replace <code>contains</code> with <code>matches</code> to run a regex search.
        This example becomes a substring search:
      </p>
<pre class="urlunencode" oncopy="">
where%20title%20matches%20%22madonna%22
</pre>
      <p>This example matches both <code>madonna</code>, <code>madona</code> and with any number of <code>n</code>s:</p>
<pre class="urlunencode" oncopy="">
where%20title%20matches%20%22mado%5Bn%5D%2Ba%22%3B
</pre>
      <p>Here you match any string starting with <code>mad</code>:</p>
<pre class="urlunencode" oncopy="">
where%20title%20matches%20%22^mad%22
</pre>
      {% include important.html content="Only <a href='schema-reference.html#attribute'>attribute</a>
      fields in <a href='services-content.html#document'>documents</a> that have <code>mode=\"index\"</code> is supported.
      It is also not optimized.
      Having a prefix using the <code>^</code> will be faster than not having one."%}
    </td>
  </tr>

  <tr id="userinput">
    <th>userInput</th>
    <td>
      <p>
        <em>userInput()</em> is a robust way of mixing user input and a formal query.
        It allows controlling whether the user input is to be stemmed, lowercased, etc.,
        but it also allows for controlling whether it should be treated as a raw string,
        whether it should simply be segmented or parsed as a query.
      </p>
<pre class="urlunencode" oncopy="">
yql=select%20%2A%20from%20sources%20%2A%20where%20userInput%28%40animal%29&amp;animal=panda
</pre>
      <p>
        Here, the userInput() function will access the query property "animal",
        and parse the property value as an "ALL" query, resulting in the following expression:
      </p>
<pre class="urlunencode" oncopy="">
select%20%2A%20from%20sources%20%2A%20where%20default%20contains%20%22panda%22
</pre>
      Now, if we changed the value of "animal" without changing the rest of the expression:
<pre class="urlunencode" oncopy="">
yql=select%20%2A%20from%20sources%20%2A%20where%20userInput%28%40animal%29&amp;animal=panda%20smokey
</pre>
      The result would be:
<pre class="urlunencode" oncopy="">
select%20%2A%20from%20sources%20%2A%20where%20default%20contains%20%22panda%22%20and%20default%20contains%20%22smokey%22
</pre>
      Now, let's assume we want to combine multiple query properties and have a more complex expression as well:
<pre class="urlunencode" oncopy="">
yql=select%20%2A%20from%20sources%20%2A%20where%20range%28year%2C%201963%2C%202014%29%20and%20%28userInput%28%40animal%29%20or%20userInput%28%40teddy%29%29&amp;animal=panda&amp;teddy=bear%20roosevelt
</pre>
      The resulting YQL expression will be:
<pre class="urlunencode" oncopy="">
select%20%2A%20from%20sources%20%2A%20where%20range%28year%2C%201963%2C%202014%29%20and%20%28default%20contains%20%22panda%22%20or%20%28default%20contains%20%22bear%22%20and%20default%20contains%20%22roosevelt%22%29%29
</pre>
      Now, consider we do not want the "teddy" field to be treated as its own query segment,
      it should only be segmented with the linguistic libraries to get recall.
      We can do this by adding a "grammar" annotation to the userInput() call:
<pre class="urlunencode" oncopy="">
yql=select%20%2A%20from%20sources%20%2A%20where%20range%28year%2C%201963%2C%202014%29%20and%20%28userInput%28%40animal%29%20or%20%7Bgrammar%3A%20%22segment%22%7DuserInput%28%40teddy%29%29&amp;animal=panda&amp;teddy=bear%20roosevelt
</pre>
      Then, the linguistic library will split on space, and the resulting expression is:
<pre class="urlunencode" oncopy="">
select%20%2A%20from%20sources%20%2A%20where%20range%28year%2C%201963%2C%202014%29%20and%20%28default%20contains%20%22panda%22%20or%20default%20contains%20phrase%28%22bear%22%2C%20%22roosevelt%22%29%29
</pre>
      <p>
        Instead of <a href="#parameter-substitution">parameter substitution</a>,
        the <em>userInput()</em> function also accepts raw strings as arguments,
        but this would obviously not be suited for parametrizing the query from a query profile.
        It is mostly intended as test feature.
      </p>
      <!-- ToDo: rewrite this a little once all the examples are moved to the query api guide -->
      <table class="table">
        <thead>
        <tr>
          <th>Annotation</th>
          <th>Effect</th>
        </tr>
        </thead>
        <tbody>
        <tr>
          <td><a href="#grammar">grammar</a></td>
          <td>
            How to parse the user input.
            The query parsing mechanism has currently certain limitations for propagating annotations,
            therefore, for any value of <code>grammar</code> other than <code>raw</code> or <code>segment</code>,
            only the following annotations will take effect:
            <ul>
              <li><a href="#ranked">ranked</a></li>
              <li><a href="#filter">filter</a></li>
              <li><a href="#stem">stem</a></li>
              <li><a href="#normalizecase">normalizeCase</a></li>
              <li><a href="#accentdrop">accentDrop</a></li>
              <li><a href="#usepositiondata">usePositionData</a></li>
            </ul>
          </td>
        </tr>
        <tr>
          <td><a href="#defaultindex">defaultIndex</a></td>
          <td>Same as <a href="query-api-reference.html#model.defaultIndex">model.defaultIndex</a>
            in the query API.</td>
        </tr>
        <tr>
          <td><a href="#language">language</a></td>
          <td>Language setting for the linguistics treatment of this userInput() call.</td>
        </tr>
        <tr>
          <td><a href="#allowempty">allowEmpty</a></td>
          <td>Whether to allow empty input for query parsing and search terms.</td>
        </tr>
        </tbody>
      </table>
      <p>
        In addition, other annotations, like <a href="#stem">stem</a> or <a href="#ranked">ranked</a>,
        will take effect as normal.
      </p>
    </td>
  </tr>

  <tr id="userquery">
    <th>userQuery</th>
    <td>
      <p>
        <em>userQuery()</em> reads from <a href="query-api-reference.html#model.querystring">model.queryString</a>
        and parses the query using <a href="simple-query-language-reference.html">simple query language</a>.
        If set, <a href="query-api-reference.html#model.filter">model.filter</a> is combined with
        <em>model.queryString</em> before the parsing.
      </p>
      <p>
        The user query is first parsed,
        then the resulting tree is inserted into the corresponding place in the YQL query tree. Example:
      </p>
<pre class="urlunencode" oncopy="">
query%3Dabc%20def%20-ghi%26%0Atype%3Dall%26%0Ayql%3Dselect%20%2A%20from%20sources%20%2A%20where%20vendor%20contains%20%22brick%20and%20mortar%22%20AND%20price%20%3C%2050%20AND%20userQuery%28%29
</pre>
      <p>This evaluates to a query where:</p>
      <ul>
        <li>the numeric field <em>price</em> must be less than 50</li>
        <li><em>vendor</em> must match <em>brick and mortar</em></li>
        <li>the default index must contain the two terms <em>abc</em> and <em>def</em>,
          <em>and not</em> contain <em>ghi</em>.</li>
      </ul>
    </td>
  </tr>

  <tr id="rank">
    <th>rank</th>
    <td>
      The first, and only the first, argument of the <em>rank()</em> function
      determines whether a document is a match,
      but all arguments are used for calculating rank score.
<pre class="urlunencode" oncopy="">
where%20rank%28a%20contains%20%22A%22%2C%20b%20contains%20%22B%22%29
</pre>
    </td>
  </tr>

  <tr id="dotproduct">
    <th>dotProduct</th>
    <td>
      <p>
        <em>dotProduct</em> calculates the dot product between the weighted set
        in the query and a weighted set field in the document as its rank score contribution:
      </p>
<pre class="urlunencode" oncopy="">
where%20dotProduct%28description%2C%20%7B%22a%22%3A1%2C%20%22b%22%3A2%7D%29
</pre>
      <p>
        The result is stored as a <a href="../multivalue-query-operators.html#raw-scores-and-query-item-labeling">raw score</a>.
      </p>
      <p>
        A normal use case is a collection of weighted tokens produced by an algorithm,
        to match against a corpus containing weighted tokens
        produced by another algorithm in order to implement personalized content exploration.
      </p>
      <p>
        Refer to <a href="../multivalue-query-operators.html">multivalue query operators</a>
        for a discussion of usage and examples.
      </p>
      <p>
        Keys must be single or double-quoted if passed inline in YQL -
        alternatively, use <a href="#parameter-substitution">parameter substitution</a>
        to submit the weighted set with a simple format for faster query parsing -
        example: <code>where dotProduct(description, @myterms)</code>.
      </p>
      <table class="table">
        <thead></thead><tbody>
      <tr>
        <th>Field type</th>
        <td>Weighted set attribute with fast-search. Note: Also supported for regular attribute or
          index fields, but then with much weaker performance).</td>
      </tr><tr>
        <th>Query model</th>
        <td>Weighted set with {token, weight} pairs</td>
      </tr><tr>
        <th>Matching</th>
        <td>Documents where the weighted set field contains at least one of the tokens in the query.</td>
      </tr><tr>
        <th>Ranking</th>
        <td>Dot product score between the weights of the matched query tokens and field tokens.
          This score is available using
          <a href="rank-features.html#rawScore(field)">rawScore</a> or
          <a href="rank-features.html#itemRawScore(label)">itemRawScore</a>
          rank features.</td>
      </tr><tr>
        <th style="white-space:nowrap;">Java Query Item</th>
        <td><a href="https://javadoc.io/doc/com.yahoo.vespa/container-search/latest/com/yahoo/prelude/query/DotProductItem.html">DotProductItem</a></td>
      </tr>
      </tbody>
      </table>
    </td>
  </tr>

  <tr id="weightedset">
    <th>weightedSet</th>
    <td>
      <p>
        When using <em>weightedSet</em> to search a field,
        all tokens present in the searched field will be matched against the weighted set in the query.
        This means that using a weighted set to search a single-value attribute field
        will have similar semantics to using a normal term to search a weighted set field.
        The low-level matching information resulting from matching a document with a weighted set in the query
        will contain the weights of all the matched tokens in descending order.
        Each matched weight will be represented as a standard occurrence on position 0 in element 0.
      </p>
<pre class="urlunencode" oncopy="">
where%20weightedSet%28description%2C%20%7B%22a%22%3A1%2C%20%22b%22%3A2%7D%29
</pre>
      <p>
        <em>weightedSet</em> has similar semantics to <a href="#equiv">equiv</a>,
        as it acts as a single term in the query.
        However, the restriction dictating that it contains a collection of weighted tokens directly
        enables specific back-end optimizations that improves performance
        for large sets of tokens compared to using the generic <a href="#equiv">equiv</a> or <a href="#or">or</a> operators.
      </p>
      <p>
        Refer to <a href="../multivalue-query-operators.html">multivalue query operators</a>
        for a discussion of usage and examples.
        Also see <a href="../performance/feature-tuning.html#multi-lookup-set-filtering">multi-lookup set filtering</a>.
      </p>
      <p>
        Keys must be single or double-quoted if passed inline in YQL -
        alternatively, use <a href="#parameter-substitution">parameter substitution</a>
        to submit the weighted set with a simple format for faster query parsing -
        example: <code>where weightedSet(description, @myterms)</code>.
      </p>
      <table class="table">
        <thead></thead><tbody>
      <tr>
        <th>Field type</th>
        <td>Singlevalue or <a href="../schemas.html#field">multivalue</a> attribute or index field.
          (Note: Most use cases operates on a single value field).</td>
      </tr><tr>
        <th>Query model</th>
        <td>Weighted set with {token, weight} pairs.</td>
      </tr><tr>
        <th>Matching</th>
        <td>Documents where the field contains at least one of the tokens in the query.</td>
      </tr><tr>
        <th>Ranking</th>
        <td>The operator will act as a single term in the back-end.
          The query term weight is the weight assigned to the operator itself
          and the match weight is the largest weight among matching tokens from the weighted set.
          This operator does not produce a raw score.
          Due to better ranking and performance we recommend using <a href="#dotproduct">dotProduct</a> instead.</td>
      </tr><tr>
        <th style="white-space:nowrap;">Java Query Item</th>
        <td><a href="https://javadoc.io/doc/com.yahoo.vespa/container-search/latest/com/yahoo/prelude/query/WeightedSetItem.html">WeightedSetItem</a></td>
      </tr>
      </tbody>
      </table>
    </td>
  </tr>

  <tr id="wand"><th>wand</th><td>
    <p>
      <code>wand</code> can be used to search for documents
      where weighted tokens in a field matches a subset of weighted tokens in the query.
      At the same time, it internally calculates the dot product between token weights in the query and the field.
      <code>wand</code> is guaranteed to return the top-k hits according to its internal dot product rank score.
      It is an operator that scales adaptively from <a href="#or">or</a> to <a href="#and">and</a>.
    </p>
    <p>Note that total hit count becomes inaccurate when using wand.</p>
    <p>
      <code>wand</code> optimizes the performance of using multiple threads per search in the backend,
      and is also called <em>Parallel Wand</em>.
    </p>
    <p>
      <code>wand</code> also allows numeric arguments, then the search argument is an array of arrays of length two.
      In each pair, the first number is the search term, the second its weight:
<pre class="urlunencode" oncopy="">
where%20wand%28description%2C%20%5B%5B11%2C1%5D%2C%20%5B37%2C2%5D%5D%29
</pre>
    <p>
      Keys must be single or double-quoted if passed inline in YQL -
      alternatively, use <a href="#parameter-substitution">parameter substitution</a>
      to submit the weighted set with a simple format for faster query parsing -
      example: <code>where wand(description, @myterms)</code>.
    </p>
    <table class="table">
      <thead>
      <tr>
        <th>Annotation</th>
        <th>Effect</th>
      </tr>
      </thead>
      <tbody>
      <tr>
        <td><a href="#scorethreshold">scoreThreshold</a></td>
        <td>Minimum rank score for hits to include.</td>
      </tr>
      <tr>
        <td><a href="#targethits">targetHits</a></td>
        <td>Wanted number of hits exposed to the real first-phase ranking function per content node.</td>
      </tr>
      </tbody>
    </table>
<pre class="urlunencode" oncopy="">
where%20(%7BscoreThreshold%3A%200.13%2C%20targetHits%3A%207%7Dwand(description%2C%20%7B%22a%22%3A1%2C%20%22b%22%3A2%7D))
</pre>
    <p>
      Refer to <a href="../using-wand-with-vespa.html">using wand</a> for usage and examples.
    </p>
    <table class="table">
      <thead></thead><tbody>
    <tr>
      <th>Field type</th>
      <td>Weighted set attribute with fast-search.
        Note: Also supported for regular attribute or index fields,
        but then with much weaker performance).</td>
    </tr><tr>
      <th>Query model</th>
      <td>Weighted set with {token, weight} pairs.</td>
    </tr><tr>
      <th>Matching</th>
      <td>Documents where the weighted set field contains at least one of the tokens in the query
        and where the internal dot product score for this document,
        is larger than the worst among the current top-k best hits.
        This means that more than top-k documents are matched and returned for ranking.
        It also means that many documents are skipped,
        even they match several tokens in the query because the dot product score is too low.
        This skipping makes <em>wand</em> faster than <a href="#dotproduct">dotProduct</a> in some cases.
      </td>
    </tr><tr>
      <th>Ranking</th>
      <td>Dot product score between the weights of the matched query tokens and field tokens.
        This score is available using
        <a href="rank-features.html#rawScore(field)">rawScore</a> or
        <a href="rank-features.html#itemRawScore(label)">itemRawScore</a>
        rank features.
        Note that the top-k best hits are only guaranteed to be returned
        when using this internal score as the final ranking expression.
      </td>
    </tr><tr>
      <th style="white-space:nowrap;">Java Query Item</th>
      <td><a href="https://javadoc.io/doc/com.yahoo.vespa/container-search/latest/com/yahoo/prelude/query/WandItem.html">WandItem</a></td>
    </tr>
    </tbody>
    </table>
  </td>
  </tr>

  <tr id="weakand">
    <th>weakAnd</th>
    <td>
      <p>
        <code>weakAnd</code> is sometimes called <em>Vespa Wand</em>.
        Unlike <a href="#wand">wand</a>, it accepts arbitrary word matches (across arbitrary fields) as arguments.
        Only a limited number of documents are returned for ranking (default is 100),
        but it does not guarantee to return the best k hits.
        This function can be seen as an optimized <a href="#or">or</a>:
      </p>
<pre class="urlunencode" oncopy="">
where%20weakAnd%28a%20contains%20%22A%22%2C%20b%20contains%20%22B%22%29
</pre>
      <table class="table">
        <thead>
        <tr>
          <th>Annotation</th>
          <th>Effect</th>
        </tr>
        </thead>
        <tbody>
        <tr>
          <td><a href="#scorethreshold">scoreThreshold</a></td>
          <td>Minimum rank score for hits to include.</td>
        </tr>
        <tr>
          <td><a href="#targethits">targetHits</a></td>
          <td>Wanted number of hits exposed to the real first-phase ranking function per content node.</td>
        </tr>
        </tbody>
      </table>
<pre class="urlunencode" oncopy="">
where%20(%7BscoreThreshold%3A%200%2C%20targetHits%3A%207%7DweakAnd(a%20contains%20%22A%22%2C%20b%20contains%20%22B%22))
</pre>
      <p>
        Unlike <a href="#wand">wand</a>, <code>weakAnd</code> can be used
        to search across several fields of various types,
        but it does NOT guarantee to return the top-k best number of hits.
        It can however be combined with any ranking expression.
        Keep in mind that this expression should correlate with its simple internal ranking score
        that uses query term weight and inverse document frequency for matching terms.
      </p>
      <p>
        Refer to <a href="../using-wand-with-vespa.html">using wand</a> for a usage and examples.
      </p>
      <table class="table">
        <thead></thead><tbody>
      <tr>
        <th>Field type</th>
        <td>Multiple fields of all types (both attribute and index).</td>
      </tr><tr>
        <th>Query model</th>
        <td>Arbitrary number of query items searching across different fields.</td>
      </tr><tr>
        <th>Matching</th>
        <td>Documents that matches at least one of the tokens in the query
          and where the internal operator score for this document
          is larger than the worst among the current top-k best hits.
          As with <a href="#wand">wand</a>, this means that typically more than top-k documents are matched
          and a lot of documents are skipped.
        </td>
      </tr><tr>
        <th>Ranking</th>
        <td>Internal ranking score based on query term weight
          and inverse document frequency for matching terms to find the top-k hits.
          This score is currently not available to the ranking framework.
          Matching terms are exposed to the ranking framework
          (same as when using <a href="#and">and</a> or <a href="#or">or</a>),
          so an arbitrary ranking expression can be used in combination with this operator.
          Note that the ranking expression used should correlate with this internal ranking score.
          <a href="rank-features.html#bm25">bm25</a>,
          <a href="rank-features.html#nativeFieldMatch">nativeFieldMatch</a> and
          <a href="rank-features.html#nativeDotProduct(field)">nativeDotProduct</a>
          rank features are good starting points.
        </td>
      </tr><tr>
        <th style="white-space:nowrap;">Java Query Item</th>
        <td><a href="https://javadoc.io/doc/com.yahoo.vespa/container-search/latest/com/yahoo/prelude/query/WeakAndItem.html">WeakAndItem</a></td>
      </tr>
      </tbody>
      </table>
    </td>
  </tr>

  <tr id="geolocation">
    <th>geoLocation</th>
    <td>
      <p>
        <code>geoLocation</code> matches a <a href="schema-reference.html#type:position">position</a>
        inside a geographical circle, specified as latitude, longitude, and a maximum distance (radius).
        Example:
      </p>
<pre class="urlunencode" oncopy="">
where%20geoLocation%28myfieldname%2C%2063.5%2C%2010.5%2C%20%22200%20km%22%29
</pre>
      <p>
        In this example we search for documents near 63.5° north, 10.5° east,
        and within a 200 km radius.
        So a document with a "myfieldname" position in Trondheim, Norway at
        N63°25'47;E10°23'36 would match.
        The first parameter is the name of the attribute field.
        The second parameter is the longitude (positive for north, negative for south).
        The third parameter is the latitude (positive for east, negative for west).
        The fourth parameter must be a string specifying the radius and its units,
        where the supported units include "km", "m" (for meters), "miles", and "deg" for degrees
        (so "deg" gives radius the same units as latitude).
        Any negative number for radius (e.g. "-1 m") is interpreted as an "infinite" radius,
        letting any geographical position at all match the geoLocation operator.
      </p>
      <p>
        The position attribute in the schema could look like:
      </p>
<pre>
field myfieldname type position {
    indexing: attribute | summary
}
</pre>
      <p>Arrays of positions are also possible:</p>
<pre>
field myfieldname type array&lt;position&gt; {
    indexing: attribute
}
</pre>
      <table class="table">
        <thead>
        <tr>
          <th>Annotation</th>
          <th>Effect</th>
        </tr>
        </thead>
        <tbody>
        <tr>
          <td><a href="#label">label</a></td>
          <td>Label for referring to this term during ranking.</td>
        </tr>
        </tbody>
      </table>
      <p>
        Properties:
      </p>
      <table class="table">
        <thead></thead><tbody>
      <tr>
        <th>Field type</th>
        <td>position attribute (single-valued or array).</td>
      </tr><tr>
        <th>Query parameters</th>
        <td>Field name, longitude, latitude, radius.</td>
      </tr><tr>
        <th>Matching</th>
        <td>Returns documents inside the given geo circle.</td>
      </tr><tr>
        <th>Ranking</th>
        <td>Use <code>closeness(myfieldname)</code>, or <code>distance(myfieldname)</code>
          in ranking calculations.
          See <a href="rank-features.html#closeness(name)">closeness</a>
          and <a href="rank-features.html#distance(name)">distance</a> documentation.</td>
      </tr><tr>
        <th style="white-space:nowrap;">Java Query Item</th>
        <td><a href="https://javadoc.io/doc/com.yahoo.vespa/container-search/latest/com/yahoo/prelude/query/GeoLocationItem.html">GeoLocationItem</a></td>
      </tr>
      </tbody>
      </table>
    </td>
  </tr>

  <tr id="nearestneighbor">
    <th>nearestNeighbor</th>
    <td>
      <p>
        <code>nearestNeighbor</code> matches the top-k nearest neighbors in a multi-dimensional vector space.
        Points in the vector space are specified as
        <a href="../tensor-user-guide.html">tensors</a> with one indexed dimension,
        where the size of that dimension is equal to the dimensionality of the vector space.
        The document positions are stored in a tensor attribute, and the query position is sent with the query request.
        Euclidean distance is used as the default
        <a href="schema-reference.html#distance-metric">distance metric</a>
        and the exact nearest neighbors are returned.
        If a <a href="schema-reference.html#index-hnsw">HNSW index</a>
        is specified on the tensor, the approximate nearest neighbors are returned instead. Example:
      </p>
<pre class="urlunencode" oncopy="">
where%20(%7BtargetHits%3A%2010%7DnearestNeighbor(doc_vector%2C%20query_vector))&amp;ranking.features.query%28query_vector%29=%5B3%2C5%2C7%5D
</pre>
      <p>
        In this example we search for the top 10 nearest neighbors in a 3-dimensional vector space.
        <em>targetHits</em> specifies the wanted top-k nearest neighbors to find. This parameter is required.
        The first parameter of <em>nearestNeighbor</em> is the name of the tensor attribute containing the document positions (<em>doc_vector</em>).
        The second parameter is the name of the tensor sent with the query request (<em>query_vector</em>).
        Specifying <em>query_vector</em> as the name means the query request must set this tensor as
        <em>ranking.features.query(query_vector)</em>.
        The document tensor attribute is defined as follows:
      </p>
<pre>
field doc_vector type tensor&lt;float&gt;(x[3]) {
    indexing: attribute | summary
}
</pre>
      <p>
        The last part of the YQL example specifies the query tensor,
        see <a href="../ranking-expressions-features.html#query-feature-types">defining query feature types</a>
        This must have the same type as the document tensor.
        See <a href="../nearest-neighbor-search.html">Nearest Neighbor Search</a> and
        <a href="../approximate-nn-hnsw.html">Approximate Nearest Neighbor Search using HNSW Index</a>
        for more detailed examples.
      </p>
      <table class="table">
        <thead>
        <tr>
          <th>Annotation</th>
          <th>Effect</th>
        </tr>
        </thead>
        <tbody>
        <tr>
          <td><a href="#targethits">targetHits</a></td>
          <td>
            This annotation is required, and specifies the number of hits nearestNeighbor aims to produce.
            Note that more or less hits might actually be produced.
          </td>
        </tr>
        <tr>
          <td><a href="#approximate">approximate</a></td>
          <td>
            The optional <code>approximate</code> annotation may be set to <code>false</code>
            to not use an approximate <a href="schema-reference.html#index-hnsw">HNSW index</a>.
            This is especially useful to compare exact and approximate results in order to perform
            tuning of other parameters.
            This annotation is default "true" when an HNSW index is specified, otherwise it is always "false".
          </td>
        </tr>
        <tr>
          <td><a href="#hnsw-exploreadditionalhits">hnsw.exploreAdditionalHits</a></td>
          <td>
            Tune how many extra nodes in the graph (in addition to <code>targetHits</code>)
            that should be explored before selecting the best hits.
          </td>
        </tr>
        <tr>
          <td><a href="#label">label</a></td>
          <td>
            Use to mark the query operator with a label
            that can be referred to from the ranking expression in the rank profile.
            See the <a href="rank-features.html#closeness(dimension,name)">closeness</a> rank feature.
          </td>
        </tr>
        <tr>
          <td><a href="#distancethreshold">distanceThreshold</a></td>
          <td>
            Use to filter out hits with a higher distance than the given threshold.
          </td>
        </tr>
        </tbody>
      </table>
      <p>Properties:</p>
      <table class="table">
        <thead></thead><tbody>
      <tr>
        <th>Field type</th>
        <td>Tensor attribute with one indexed dimension of size N.</td>
      </tr><tr>
        <th>Query model</th>
        <td>Tensor with one indexed dimension of size N.</td>
      </tr><tr>
        <th>Matching</th>
        <td>Returns documents where the distance (according to the
          <a href="schema-reference.html#distance-metric">distance metric</a> used)
          between the document tensor
          and the query tensor is less than the greatest distance among the current top-k best hits.
          This means that typically more than top-k documents are matched and
          returned for ranking. This is similar to the behavior of
          <a href="#wand">wand</a>.
          When an <a href="schema-reference.html#index-hnsw">HNSW index</a> is used,
          the top-k best hits are calculated before regular matching happens,
          taking the rest of the query filters into account.</td>
      </tr><tr>
        <th>Ranking</th>
        <td>Calculates a closeness score that is defined as
          <code>1 / (1 + d)</code>, where <code>d</code> is the distance
          between the document tensor and query tensor.
          This score is available using
          <a href="rank-features.html#rawScore(field)">rawScore</a>,
          <a href="rank-features.html#itemRawScore(label)">itemRawScore</a>, or
          <a href="rank-features.html#closeness(dimension,name)">closeness</a> rank features.
          The raw distance is available using the
          <a href="rank-features.html#distance(dimension,name)">distance</a> rank feature.</td>
      </tr><tr>
        <th style="white-space:nowrap;">Java Query Item</th>
        <td><a href="https://javadoc.io/doc/com.yahoo.vespa/container-search/latest/com/yahoo/prelude/query/NearestNeighborItem.html">NearestNeighborItem</a></td>
      </tr>
      </tbody>
      </table>
    </td>
  </tr>

  <tr id="nonempty">
    <th>nonEmpty</th>
    <td>
      <p>
        <em>nonEmpty</em> takes as its only argument an arbitrary search expression.
        It will then perform a set of checks on that expression.
        If all the checks pass, the result is the same expression, otherwise the query will fail.
        The checks are as follows:
      </p>
      <ol>
        <li>No empty search term</li>
        <li>No empty operators, like phrases without terms</li>
        <li>No null markers (NullItem) from e.g. failed query parsing</li>
      </ol>
<pre class="urlunencode" oncopy="">
yql=select%20%2A%20from%20sources%20%2A%20where%20bar%20contains%20%22a%22%20and%20nonEmpty%28bar%20contains%20%22bar%22%20and%20foo%20contains%20%40foo%29&amp;foo=
</pre>
      <p>
        Note how "foo" is empty in this case, which will force the query to fail.
        If "foo" contained a searchable term, the query would not have failed.
      </p>
    </td>
  </tr>

  <tr id="predicate">
    <th>predicate</th>
    <td>
      <p>
        <em>predicate()</em> specifies a predicate query -
        see <a href="../predicate-fields.html">predicate fields</a>.
        It takes three arguments: the predicate field to search, a map of attributes, and a map of range attributes:
      </p>
<pre class="urlunencode" oncopy="">
where%20predicate(predicate_field%2C%7B%22gender%22%3A%22Female%22%7D%2C%7B%22age%22%3A20L%7D)
</pre>
      <p>Due to a quirk in YQL-parsing, one cannot specify an empty map, use the number 0 instead.</p>
<pre class="urlunencode" oncopy="">
where%20predicate(predicate_field%2C0%2C%7B%22age%22%3A20L%7D)
</pre>
    </td>
  </tr>

  <tr id="literal.true">
    <th>true</th>
    <td>
      <p>
        Matches all documents of any type.  Care must be taken when using this since processing all documents as matches
        is expensive.   At minimum, consider restricting to only one schema where you know the corpus isn't too big,
        see the <a href="query-api-reference.html#model.restrict">model.restrict</a> URL parameter.
      </p>
    </td>
  </tr>

  <tr id="literal.false">
    <th>false</th>
    <td>
      <p>
        Does not match any document at all.  Not useful in itself, but could potentially be used as
        a placeholder in the query tree.
      </p>
    </td>
  </tr>

</tbody>
</table>




<h2 id="order-by">order by</h2>
<!-- ToDo ref reference/query-api-reference.html#ranking.sorting -->
<p>
  Sort using <code>order by</code>.
  Add <code>asc</code> or <code>desc</code> after the name of an
  <a href="../attributes.html">attribute</a> to set sort order -
  ascending order is default.
</p>
<pre class="urlunencode" oncopy="">
where%20title%20contains%20%22madonna%22%20order%20by%20price%20asc%2C%20releasedate%20desc
</pre>
<p>
  Sorting function, locale and strength are defined using the annotations "function", "locale" and "strength", as in:
</p>
<pre class="urlunencode" oncopy="">
where%20title%20contains%20%22madonna%22%20order%20by%20%7Bfunction%3A%20%22uca%22%2C%20locale%3A%20%22en_US%22%2C%20strength%3A%20%22IDENTICAL%22%7Dother%20desc%2C%20%7Bfunction%3A%20%22lowercase%22%7Dsomething
</pre>
{% include note.html content="<a href='schema-reference.html#match-phase'>match-phase</a>
is enabled when sorting - refer to the <a href='sorting.html'>sorting reference</a>."%}
<table class="table">
  <thead>
  <tr>
    <th>Annotation</th>
    <th>Effect</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><a href="#function">function</a></td>
    <td>
      Sort function, default UCA.
    </td>
  </tr>
  <tr>
    <td><a href="#locale">locale</a></td>
    <td>
      Locale identifier for the <a href="#function">UCA sort function</a>.
    </td>
  </tr>
  <tr>
    <td><a href="#strength">strength</a></td>
    <td>
      Strength setting for the <a href="#function">UCA sort function</a>.
    </td>
  </tr>
  </tbody>
</table>



<h2 id="limit-offset">limit / offset</h2>
<p>
  To specify a slice / limit the number of hits returned / do pagination,
  use <code>limit</code> and/or <code>offset</code>:
</p>
<pre class="urlunencode" oncopy="">
where%20title%20contains%20%22madonna%22%20limit%2031%20offset%2029
</pre>
<p>
  The above will return two hits (if there are sufficiently many hits matching the query),
  skipping the 29 first documents.
</p>



<h2 id="timeout">timeout</h2>
<p>
  Set query timeout in milliseconds using <code>timeout</code>:
</p>
<pre class="urlunencode" oncopy="">
where%20title%20contains%20%22madonna%22%20timeout%2070
</pre>
<p>
  Only literal numbers are valid, i.e. setting another unit is not supported.
</p>



<h2 id="parameter-substitution">Parameter substitution</h2>
<p>
  The query operators <a href="#dotproduct">dotProduct(field, value)</a>,
  <a href="#weightedset">weightedSet(field, value)</a> and <a href="#wand">wand(field, value)</a>
  support parameter substitution for the <code>value</code> parameter - example of equivalent queries:
</p>
<pre>
... where weightedSet(field, {"a":1, "b":2})
... where weightedSet(field, @myset)&amp;myset={a:1,b:2}
</pre>
<p>
  Use this to:
</p>
<ul>
  <li>Simplify query generation, separating the value of the set/array from the YQL string.
    Quotes can be skipped unless the keys contain <code>,</code> or <code>:</code>.</li>
  <li>Speed up query parsing. Using parameter substitution accelerates string parsing.</li>
</ul>
<p>
  The value string can be passed in one of:
</p>
<ul>
  <li>Array form: <code>[[key, value], ...]</code></li>
  <li>Map form: <code>{key: value, ...}</code></li>
</ul>
<p>
  The query operator <a href="#userinput">userInput(value)</a>
  supports parameter substitution for the <code>value</code> parameter:
</p>
<pre>
... where userInput(@input)&amp;input=free+text
</pre>
<p>
  Use this to submit the user data unchanged for parsing in Vespa,
  without risk of corrupting the YQL query.
</p>
<!-- ToDo: Move the examples to the query-api guide instead -->



<h2 id="annotations">Annotations</h2>
<p>
  Terms and phrases can be annotated to manipulate the behavior.
  Add an annotation using <code>{}</code>:
</p>
<pre class="urlunencode" oncopy="">
where%20text%20contains%20(%7Bdistance%3A%205%7Dnear(%22a%22%2C%20%22b%22))
</pre>
<p>
  All annotations are supported by the string arguments to functions like
  and phrase() and near() and also the string argument to the "contains" operator.
  Some annotations are also supported by the functions which are handled like leaf nodes internally in the query tree:
  phrase(), near(), onear(), range(), equiv(), dotProduct(), weightedSet(), weakAnd(), wand() and nearestNeighbor().
</p>
<p>
  Refer to <a href="https://github.com/vespa-engine/vespa/blob/master/container-search/src/test/java/com/yahoo/select/SelectTestCase.java">
  SelectTestCase.java</a> for sample usage. <!-- ToDo: improve this a little or add examples elsewhere, from this -->
</p>
<table class="table">
  <thead>
  <tr>
    <th>Annotation</th>
    <th>Default</th>
    <th>Values</th>
    <th>Description</th>
  </tr>
  </thead>
  <tbody>
  <tr id="accentdrop">
    <td>accentDrop</td>
    <td>true</td>
    <td>boolean</td>
    <td>Remove accents from this term if it is the setting for this field.</td>
  </tr>
  <tr id="allowempty">
    <td>allowEmpty</td>
    <td>false</td>
    <td>boolean</td>
    <td>
      Whether to allow empty input for query parsing and query terms in <a href="#userinput">userInput</a>.
      If <code>true</code>, a NullItem instance is inserted in the proper place in the query tree.
      If <code>false</code>, the query will fail if the user provided inout can not be parsed or is empty.
    </td>
  </tr>
  <tr id="andsegmenting">
    <td>andSegmenting</td>
    <td></td>
    <td>true|false</td>
    <td>Force phrase or AND operator if re-segmenting (e.g. in stemming) this term results in multiple terms.
      Default is choosing from language settings.</td>
  </tr>
  <tr id="annotations-table">
    <td>annotations</td>
    <td></td>
    <td>map</td>
    <td>Map of <code>string: string</code>. Custom annotations. No special semantics inside the YQL layer. Example:
      <pre>annotations : {cox : "another"}</pre>
    </td>
  </tr>
  <tr id="approximate">
    <td>approximate</td>
    <td></td>
    <td>boolean</td>
    <td>
      Used in <a href="#nearestneighbor">nearestNeighbor</a>.
      The optional <em>approximate</em> annotation may be set to <code>false</code> to disallow usage of an approximate
      <a href="schema-reference.html#index-hnsw">HNSW index</a>.
      This is especially useful to compare exact and approximate results in order to perform tuning of other parameters.
      This annotation is default <code>true</code> when an HNSW index is specified,
      otherwise it is always <code>false</code>.
    </td>
  </tr>
  <tr id="ascending">
    <td>ascending</td>
    <td></td>
    <td>boolean</td>
    <td>
      Ascending hit order. Used by <a href="#hitlimit">hitLimit</a>.
    </td>
  </tr>
  <tr id="bounds">
    <td>bounds</td>
    <td>closed</td>
    <td>enum</td>
    <td>
      A <a href="#numeric">numeric</a> interval is by default a closed interval.
      If the lower bound is exclusive, set the annotation "bounds" to "leftOpen".
      If the upper bound is exclusive, set the same annotation to "rightOpen".
      If both bounds are exclusive, set the annotation to "open".
      <!-- ToDo: example here! -->
    </td>
  </tr>
  <tr id="connectivity">
    <td>connectivity</td>
    <td></td>
    <td>map</td>
    <td>Map of <code>id: int, weight: double</code> of explicit connectivity between this item and the item with the given
      <a href="#id">id</a> - example:
      <pre>connectivity: {"id": 4, "weight": 0.8}</pre>
    </td>
  </tr>
  <tr id="descending">
    <td>descending</td>
    <td></td>
    <td>boolean</td>
    <td>
      Descending hit order. Used by <a href="#hitlimit">hitLimit</a>.
    </td>
  </tr>
  <tr id="defaultindex">
    <td>defaultIndex</td>
    <td><code>default</code></td>
    <td>Any searchable field in the schema.</td>
    <td>
      Used by <a href="#userinput">userInput</a>.
      Same as <a href="query-api-reference.html#model.defaultIndex">model.defaultIndex</a> in the query API.
      If <a href="#grammar">grammar</a> is set to <code>raw</code> or <code>segment</code>,
      this will be the field searched.
    </td>
  </tr>
  <tr id="distance">
    <td>distance</td>
    <td>2</td>
    <td>int</td>
    <td>
      The <em>distance</em>-annotation sets the maximum position difference to count as a match.
      The default distance is 2, meaning match if the words have up to one separating word.
<pre class="urlunencode" oncopy="">
where%20text%20contains%20%28%7Bdistance%3A%205%7Dnear%28%22a%22%2C%20%22b%22%29%29
</pre>
    </td>
  </tr>
  <tr id="distancethreshold">
    <td>distanceThreshold</td>
    <td>2</td>
    <td>int</td>
    <td>
      Used in <a href="#nearestneighbor">nearestNeighbor</a>.
      The <code>distanceThreshold</code> annotation may be used to filter away hits
      with a higher distance than the given threshold from the results.
      Note that one will never get more hits with <code>distanceThreshold</code> than you would get without it -
      to get more hits, increase <a href="#targethits">targetHits</a>, too.
      The units for the threshold depends on the
      <a href="schema-reference.html#distance-metric">distance metric</a> used.
    </td>
  </tr>
  <tr id="endanchor">
    <td>endAnchor</td>
    <td>true</td>
    <td>boolean</td>
    <td>
      <p>
        The <code>hostname</code> subfield of <a href="#uri">uri</a>
        supports anchoring to the start and/or end of the hostname,
        controlled by the <code>startAnchor</code> and <code>endAnchor</code> annotations.
        Anchoring to the end is on by default while anchoring to the start is not. Hence
      </p>
<pre class="urlunencode" oncopy="">
where%20myUrlField.hostname%20contains%20uri(%5C%22vespa.ai%5C%22)
</pre>
      <p>will match <em>vespa.ai</em> and <em>docs.vespa.ai</em>, while</p>
<pre class="urlunencode" oncopy="">
where%20myUrlField.hostname%20contains%20(%7BstartAnchor%3A%20true%7Duri(%22vespa.ai%22))
</pre>
      <p>will only match vespa.ai.</p>
    </td>
  </tr>
  <tr id="filter">
    <td>filter</td>
    <td>false</td>
    <td>boolean</td>
    <td>Regard this term as a "filter" term.</td>
  </tr>
  <tr id="function">
    <td>function</td>
    <td></td>
    <td></td>
    <td>
      <p>
        Default sort function for strings is <code>uca</code>.
        Field sort specification can be configured in the <a href="schema-reference.html#sorting">schema</a>,
        values in the query overrides the schema settings.
      </p>
      <p>
        Numeric fields are numerically sorted.
      </p>
      <table class="table">
        <thead>
        <tr>
          <th>Function</th>
          <th>Description</th>
        </tr>
        </thead>
        <tbody>
        <tr id="uca">
          <td><code>uca</code></td>
          <td>
            <p>
              This sorting is based on the <a href="http://site.icu-project.org/">icu</a> library
              that follows the <a href="https://unicode.org/reports/tr10/">
              Universal Collation Algorithm</a>.
              The specification of
              <a href="https://unicode-org.github.io/icu-docs/#/icu4j/com/ibm/icu/util/ULocale.html">locale</a>
              and <a href="https://unicode-org.github.io/icu-docs/#/icu4j/com/ibm/icu/text/Collator.html">strength</a>
              are identical to how <a href="http://site.icu-project.org/">icu</a> specifies them.
            </p>
            <p>
              Both <a href="#locale">locale</a> and <a href="#strength">strength</a> are optional,
              however <code>strength</code> requires <code>locale</code>.
            </p>
            <p>
              The <a href="#locale">locale</a> query annotation will override
              locale-setting in the <a href="schema-reference.html#sorting">schema</a>.
              If <code>locale</code> is missing from both, the <code>lowercase</code> function will be used by default.
            </p>
          </td>
        </tr>
        <tr id="lowercase">
          <td><code>lowercase</code></td>
          <td>
            This improves the sorting by first lowercasing and normalising the strings before sorting.
            This is slightly more correct and might be enough for the use case.
            It is not that much more costly than <code>raw</code> sort, and less expensive than <code>uca</code>.
          </td>
        </tr>
        <tr id="raw">
          <td><code>raw</code></td>
          <td>
            Raw byteorder is a simple and fast ordering based on memcmp of utf8 for strings
            and correct sort order compliant binary rep for other fields is done.
            However, that is not correct for anything except computers,
            looking only at the binary representation.
          </td>
        </tr>
      </tbody>
      </table>
    </td>
  </tr>
  <tr id="grammar">
    <td>grammar</td>
    <td><code>all</code></td>
    <td><code>raw</code>, <code>segment</code> and all values accepted for the
      <a href="query-api-reference.html#model.type">model.type</a> argument in the query API.</td>
    <td>
      <p>
      How to parse <a href="#userinput">userInput</a>.
      <code>raw</code> will treat the user input as a string to be matched without any processing,
      <code>segment</code> will do a first pass through the linguistic libraries,
      while the rest of the values will treat the string as a query to be parsed.
      If query parsing fails, an error message will be returned.
      </p>
    </td>
  </tr>
  <tr id="hitlimit">
    <td>hitLimit</td>
    <td></td>
    <td>int</td>
    <td>
      <p>
        <a href="#numeric">Numeric</a> operations support <code>hitLimit</code>.
        This is used for <em>capped range search</em>.
        An alternative to using negative and positive values for hitLimit is always using a positive number of hits
        (as a negative number of hits does not make much sense) and combine this with either of the
        <a href="#ascending">ascending</a> and <a href="#descending">descending</a> annotations (but not both).
        Example: <code>{hitLimit: 38, descending: true}</code> would be equivalent to setting it to -38,
        i.e. only populate with 38 hits and start from upper boundary, i.e. descending order.
      </p>
      <p>
        Note that hitLimit will limit the number of documents that are considered.
        It is dangerous to use if you have other filters too.
        This is a powerful optimisation that must be used with care.
        The set of documents to be considered will be limited upfront
        by only selecting the N best according to the range query and the hitLimit annotation,
        for further query evaluation.
      </p>
      <p>
        hitLimit is not exact, but "at least".
        In addition, it will only kick in if the attribute has <a href="schema-reference.html#attribute">fast-search</a>.
        It will look up the upper or lower bound in the range in the dictionary and scan in ascending or descending order
        and select entries until it has satisfied hitLimit.
        You will get all documents for all the dictionary entries selected.
      </p>
    </td>
  </tr>
  <tr id="hnsw-exploreadditionalhits">
    <td>hnsw.exploreAdditionalHits</td>
    <td></td>
    <td></td>
    <td>
      Used in <a href="#nearestneighbor">nearestNeighbor</a>.
      When using an <a href="schema-reference.html#index-hnsw">HNSW index</a>,
      the optional <code>hnsw.exploreAdditionalHits</code> annotation can be used to
      tune how many extra nodes in the graph (in addition to <code>targetHits</code>)
      should be explored before selecting the best hits.
      Using a greater number here gives better quality, but worse performance.
    </td>
  </tr>
  <tr id="id">
    <td>id</td>
    <td></td>
    <td>int</td>
    <td>Unique ID used for e.g. <a href="#connectivity">connectivity</a>.</td>
  </tr>
  <tr id="implicittransforms">
    <td>implicitTransforms</td>
    <td>true</td>
    <td>boolean</td>
    <td>Implicit term transformations (field defaults).
    If implicitTransforms is active, the settings for the field in the schema will be honored in term transforms,
    e.g. if the field has stemming, this term will be stemmed.
    If implicitTransforms are turned off,
    the search backend will receive the term exactly as written in the initial YQL expression.
    This is in other words a top level switch to turn off all other
    <a href="../linguistics.html#stemming">stemming</a>, accent removal, Unicode
    <a href="../linguistics.html#normalization">normalizations</a> and so on.</td>
  </tr>
  <tr id="label">
    <td>label</td>
    <td></td>
    <td>string</td>
    <td>
      Used by <a href="#geolocation">geoLocation</a>
      and <a href="#nearestneighbor">nearestNeighbor</a>.. <!-- ToDo: and probably others ... -->
      Label for referring to this term during ranking.
    </td>
  </tr>
  <tr id="language">
    <td>language</td>
    <td></td>
    <td>RFC 3066 language code</td>
    <td>Language setting for the linguistics handling of <a href="#userinput">userInput</a>,
      also see <a href="query-api-reference.html#model.language">model.language</a> in the query API reference.</td>
  </tr>
  <tr id="locale">
    <td>locale</td>
    <td></td>
    <td></td>
    <td>
      Used by the <a href="#function">UCA sort function</a>.
      An identifier following <a href="https://www.unicode.org/reports/tr35/#Unicode_Language_and_Locale_Identifiers">
      unicode locale identifiers</a>, e.g. <code>en_US</code>.
    </td>
  </tr>
  <tr id="nfkc">
    <td>nfkc</td>
    <td>true</td>
    <td>boolean</td>
    <td>NFKC <a href="../linguistics.html#normalization">normalization</a>.</td>
  </tr>
  <tr id="normalizecase">
    <td>normalizeCase</td>
    <td>true</td>
    <td>boolean</td>
    <td>Normalize casing of this term if it is the setting for this field.</td>
  </tr>
  <tr id="origin">
    <td>origin</td>
    <td></td>
    <td>map</td>
    <td>Map of <code>original: string, offset: int, length: int</code>.
      The (sub-)string which produced this term. Default unset. Example:
      <pre>origin: {original: "abc", offset: 1, length: 2}</pre>
    </td>
  </tr>
  <tr id="prefix">
    <td>prefix</td>
    <td>false</td>
    <td>boolean</td>
    <td>Do prefix matching for this word. ("Search for "word*".")</td>
  </tr>
  <tr id="ranked">
    <td>ranked</td>
    <td>true</td>
    <td>boolean</td>
    <td>Include this term for ranking calculation.
      <a href="../ranking-expressions-features.html#dumping-rank-features-for-specific-documents">Example</a></td>
  </tr>
  <tr id="scorethreshold">
    <td>scoreThreshold</td>
    <td></td>
    <td>double / integer</td>
    <td>
      Both <a href="#wand">wand</a> and <a href="#weakand">weakAnd</a> supports <code>scoreThreshold</code>,
      which is a double for <code>wand</code> and an integer for <code>weakAnd</code>.
      This threshold specifies the minimum rank score for hits to include.
      The <code>wand</code> / <code>weakAnd</code> operators will both expose candidates
      that were evaluated to the first-phase and not only the top-k.
    </td>
  </tr>
  <tr id="significance">
    <td>significance</td>
    <td></td>
    <td>double</td>
    <td>Significance value for ranking.</td>
  </tr>
  <tr id="startanchor">
    <td>startAnchor</td>
    <td>false</td>
    <td>boolean</td>
    <td>See <a href="#endanchor">endAnchor</a>.</td>
  </tr>
  <tr id="stem">
    <td>stem</td>
    <td>true</td>
    <td>boolean</td>
    <td>Stem this term if it is the setting for this field.</td>
  </tr>
  <tr id="strength">
    <td>strength</td>
    <td><code>PRIMARY</code></td>
    <td>
      <ul>
        <li><code>PRIMARY</code></li>
        <li><code>SECONDARY</code></li>
        <li><code>TERTIARY</code></li>
        <li><code>QUATERNARY</code></li>
        <li><code>IDENTICAL</code></li>
      </ul>
    </td>
    <td>
      Used by the <a href="#function">UCA sort function</a>.
      Default is <code>PRIMARY</code>, which only sorts on primary differentiating characteristics;
      this means that letters in uppercase/lowercase or with differences in accents only are considered equal.
    </td>
  </tr>
  <tr id="suffix">
    <td>suffix</td>
    <td>false</td>
    <td>boolean</td>
    <td>Do suffix matching for this word. ("Search for "*word".")</td>
  </tr>
  <tr id="targethits">
    <td>targetHits</td>
    <td>100</td>
    <td>int</td>
    <td>
      Used by <a href="#wand">wand</a>, <a href="#weakand">weakAnd</a>
      and <a href="#nearestneighbor">nearestNeighbor</a>.
      It sets the wanted number of hits exposed to the real first-phase ranking function per content node.
      If additional second phase ranking with rerank-count is used,
      do not set <code>targetHits</code> less than the configured rank-profile's
      <a href="schema-reference.html#rerank-count">rerank-count</a>.
      {% include note.html content="<code>targetHits</code> was previously named <code>targetNumHits</code> -
      targetNumHits still works for backwards compatibility until Vespa 8."%}
    </td>
  </tr>
  <tr id="usepositiondata">
    <td>usePositionData</td>
    <td>true</td>
    <td>boolean</td>
    <td>Use position data for ranking algorithm.
      This is <em>term</em> position, not to be confused with
      <a href="query-api-reference.html#geographical-searches">geo searches</a></td>
  </tr>
  <tr id="weight">
    <td>weight</td>
    <td>100</td>
    <td>int</td>
    <td>Term weight, used in some ranking calculations.
<pre class="urlunencode" oncopy="">
where%20title%20contains%20(%7Bweight%3A200%7D"heads")
</pre>
    </td>
  </tr>
  </tbody>
</table>


<h3 id="annotations-of-sub-expressions">Annotations of sub-expressions</h3>
<p>
  Consider the following query:
</p>
<pre class="urlunencode" oncopy="">
select%20%2A%20from%20sources%20%2A%20where%20%28%7Bstem%3A%20false%7D%28foo%20contains%20%22a%22%20and%20bar%20contains%20%22b%22%29%29%20or%20foo%20contains%20%7Bstem%3A%20false%7D%22c%22
</pre>
<p>
  The "stem" annotation controls whether a given term should be stemmed if its
  field is configured as a stemmed field (default is "true").
  The "AND" operator itself has no internal API for whether its operands should be stemmed or not,
  but we can still annotate as such,
  because when the value of a given annotation is determined,
  the expression tree is followed from the term in question and up through its ancestors.
  Traversing the tree stops when a value is found (or there is nothing more to traverse).
  In other words, none of the terms in this example will be stemmed.
</p>
<p>
  How annotations behave may be easier to understand of expressing a boolean query in the style of an S-expression:
</p>
<pre>
(AND term1 term2 (OR term3 term4) (OR term5 (AND term6 term7)))
</pre>
<p>
  The annotation scopes would then be as follows, i.e. annotations on
  which elements will be checked when determining the settings for a given term:
</p>
<table class="table">
  <thead></thead><tbody>
<tr><td>term1</td><td>term1 itself, and the first AND</td></tr>
<tr><td>term2</td><td>term2 itself, and the first AND</td></tr>
<tr><td>term3</td><td>term3 itself, the first OR and the first AND</td></tr>
<tr><td>term4</td><td>term4 itself, the first OR and the first AND</td></tr>
<tr><td>term5</td><td>term5 itself, the second OR and the first AND</td></tr>
<tr><td>term6</td><td>term6 itself, the second AND, the second OR and the first AND</td></tr>
<tr><td>term7</td><td>term7 itself, the second AND, the second OR and the first AND</td></tr>
</tbody>
</table>



<h2 id="query-properties">Query properties</h2>
<p>
  Use YQL variable syntax to initialize words in phrases and as single terms.
  This removes the need for caring about quoting a term in YQL, as well as URL quoting.
  The term will be used <em>exactly</em> as it is in the URL.
  As an example, look at a query with a YQL argument, and the properties
  <em>animal</em> and <em>syntaxExample</em>:
</p>
<pre class="urlunencode" oncopy="">
yql=select%20%2A%20from%20sources%20%2A%20where%20foo%20contains%20%40animal%20and%20foo%20contains%20phrase%28%40animal%2C%20%40syntaxExample%2C%20%40animal%29&amp;animal=panda&amp;syntaxExample=syntactic
</pre>
<p>
  This YQL expression will then access the query properties <em>animal</em> and
  <em>syntaxExample</em> and evaluate to:
</p>
<pre class="urlunencode" oncopy="">
select%20%2A%20from%20sources%20%2A%20where%20%28foo%20contains%20%22panda%22%20AND%20foo%20contains%20phrase%28%22panda%22%2C%20%22syntactic%22%2C%20%22panda%22%29%29
</pre>



<h2 id="yql-in-query-profiles">YQL in query profiles</h2>
<p>
  YQL requires quoting to be included in a URL.
  Since YQL is well suited to application logic, while not being intended for end users,
  a solution to this is storing the application's YQL queries into different
  <a href="../query-profiles.html">query profiles</a>.
  To add a default query profile, add <em>search/query-profiles/default.xml</em> to the
  <a href="../cloudconfig/application-packages.html">application package</a>:
</p>
<pre>
&lt;query-profile id="default"&gt;
    &lt;field name="yql"&gt;select * from sources * where default contains "latest" or userQuery()&lt;/field&gt;
&lt;/query-profile&gt;
</pre>
<p>
  This will add <em>latest</em> as an <em>OR term</em> to all queries not having an explicit query profile parameter.
  The important thing to note is how it is not necessary to URL-quote anything in the query profiles files.
  They operate independently of the HTTP parsing as such.
</p>



<h2 id="query-rewriting-in-searchers">Query rewriting in Searchers</h2>
<p>
  Searchers which modifies the textual YQL statement (not recommended)
  should be annotated with <code>@Before("ExternalYql")</code>.
  Searchers modifying query tree produced from an input YQL statement
  should annotate with <code>@After("ExternalYql")</code>.
</p>



<h2 id="grouping">Grouping</h2>
<p>
  Group / aggregate results by adding a grouping expression after a <code>|</code> -
  <a href="../grouping.html">read more</a>.
</p>
<pre class="urlunencode" oncopy="">
select%20*%20from%20sources%20*%20where%20sddocname%20contains%20%27purchase%27%20%7C%20all(group(customer)%20each(output(sum(price))))
</pre>

<script src="/js/copy_urlencoded.js"></script>
