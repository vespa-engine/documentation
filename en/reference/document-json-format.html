---
# Copyright Vespa.ai. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.
title: "Document JSON Format"
redirect_from:
- /documentation/reference/document-json-format.html
---

<p>
This document describes the JSON format used for sending document operations to Vespa.
Field types are defined in the
<a href="schema-reference.html#field">schema reference</a>.
This is a reference for:
</p>
<ul>
  <li>JSON representation of field types in Vespa documents</li>
  <li>JSON representation of document operations (put, get, remove, update)</li>
  <li>JSON representation of addressing fields for update, and update operations</li>
</ul>
<p>
Also refer to <a href="../troubleshooting-encoding.html">encoding troubleshooting</a>.
</p>



<h2 id="field-types">Field types</h2>
<table class="table">
  <tr>
    <th>string</th>
    <td>
      <p id="string"></p>
<pre>{% highlight json %}
"name": "Polly"
{% endhighlight %}</pre>
      <p>
      Feeding in an empty string ("") for a field will have the same effect as not
      feeding a value for that field, and the field will not be rendered in the
      document API and in document summaries.
      </p>
    </td>
  </tr><tr>
    <th>int</th>
    <td>
      <p id="int"></p>
<pre>{% highlight json %}
"age": 42
{% endhighlight %}</pre>
    </td>
  </tr><tr>
    <th>long</th>
    <td>
      <p id="long"></p>
<pre>{% highlight json %}
"age": 42
{% endhighlight %}</pre>
    </td>
  </tr><tr>
    <th>bool</th>
    <td>
      <p id="bool"><em>true</em> or <em>false</em>:</p>
<pre>{% highlight json %}
"alive": false
{% endhighlight %}</pre>
    </td>
  </tr><tr>
    <th>byte</th>
    <td>
      <p id="byte"></p>
<pre>{% highlight json %}
"tinynumber": 128
{% endhighlight %}</pre>
    </td>
  </tr><tr>
    <th>float</th>
    <td>
      <p id="float"></p>
<pre>{% highlight json %}
"weight": 123.4567
{% endhighlight %}</pre>
    </td>
  </tr><tr>
    <th>double</th>
    <td>
      <p id="double"></p>
<pre>{% highlight json %}
"weight": 123.4567
{% endhighlight %}</pre>
    </td>
  </tr><tr>
    <th>position</th>
    <td>
      <p id="position">A position is encoded as a lat/lng object:</p>
<pre>{% highlight json %}
"mypos": {
    "lat": 37.4181488,
    "lng": -122.0256157
}
{% endhighlight %}</pre>
      <p>See <a href="../geo-search.html">Geo Search</a> for details.</p>
    </td>
  </tr><tr>
    <th>predicate</th>
    <td>
      <p id="predicate">A <a href="../predicate-fields.html">predicate</a> is a string:</p>
<pre>{% highlight json %}
"predicate_field": "gender in [Female] and age in [20..30] and pos in [1..4]"
{% endhighlight %}</pre>
    </td>
  </tr><tr>
    <th>raw</th>
    <td>
      <p id="raw">
        The content of a <a href="schema-reference.html#raw">raw</a> field
        is represented as a base64-encoded string:
      </p>
<pre>{% highlight json %}
"raw_field": "VW5rbm93biBhcnRpc3QgZnJvbSB0aGUgbW9vbg=="
{% endhighlight %}</pre>
      <p>
        When used as <em>summary</em> field it will be rendered as a base64-encoded string.
      </p>
    </td>
  </tr><tr>
    <th>uri</th>
    <td>
      <p id="uri">A URI is a string:</p>
<pre>{% highlight json %}
"url": "https://www.yahoo.com/"
{% endhighlight %}</pre>
    </td>
  </tr><tr>
    <th>array</th>
    <td>
      <p id="array">Arrays are represented as JSON arrays.</p>
<pre>{% highlight json %}
"int_array_field": [
    123,
    456,
    789
]

"string_array_field": [
    "item 1",
    "item 2",
    "item 3"
]
{% endhighlight %}</pre>

      <p>An array of struct is represented as a JSON array of JSON objects matching the defined struct field:</p>
<pre>{% highlight json %}
"array_of_struct_field": [
   { "first_name": "Chris", "last_name": "Martin" },
   { "first_name": "James", "last_name": "Hetfield" },
   { "first_name": "Diana", "last_name": "Krall" }
]
{% endhighlight %}</pre>
      <p>
      Feeding in an empty array ([]) for a field will have the same effect as not
      feeding a value for that field, and the field will not be rendered in the
      document API and in document summaries.
      </p>
    </td>
  </tr><tr>
    <th>weightedset</th>
    <td>
      <p id="weightedset">
      Weighted sets are represented as maps where the value is the weight.
      Note, even if the key is not a string as such, it will be represented as a string in the JSON format.
      </p>
<pre>{% highlight json %}
"int_weighted_set": {
    "123": 2,
    "456": 78
}

"string_weighted_set": {
    "item 1": 143,
    "item 2": 6
}
{% endhighlight %}</pre>
      <p>
      Feeding in an empty weightedset ({}) for a field will have the same effect as not
      feeding a value for that field, and the field will not be rendered in the
      document API and in document summaries.
      </p>
    </td>
  </tr><tr>
    <th id="#tensor">tensor</th>
    <td>
      <p id="tensor"></p>
      <p id="tensor-short-form-indexed">
        <strong>Indexed tensors short form:</strong>
        An array where the values are ordered in the standard value order,
        where indexes of dimensions to the right are incremented before indexes to the left,
        where dimensions are ordered alphabetically
        (such that, e.g. with a tensor with dimensions x,y the "y" values for each value of "x" are adjacent):
      </p>
      <pre>{% highlight json %}
"tensorfield": [ 2.0, 3.0, 5.0, 7.0 ]
{% endhighlight %}</pre>
      <p>
        The cells array can optionally be nested in an object under the key "values".
        This is how tensor values are returned <a href="document-v1-api-reference.html#format.tensors">by default</a>,
        along with another key "type" containing the tensor type.
      </p>

      <p id="tensor-short-form-mapped">
        <strong>Short form for tensors with a single mapped dimension</strong>:
        A map with the dimension key as key and the value as value.
      </p>
      <pre>{% highlight json %}
"tensorfield": {
    "a": 2.0,
    "b": 3.0
}
{% endhighlight %}</pre>
      <p>
        The cells object can optionally be nested in an object under the key "cells".
        This is how tensor values are returned <a href="document-v1-api-reference.html#format.tensors">by default</a>,
        along with another key "type" containing the tensor type.
      </p>

      <p id="tensor-short-form-mixed">
        <strong>Mixed tensors short form:</strong>
        If the tensor has a single sparse dimension: A map where the key is the value of that dimension and the value
        is a nested array containing the values of the dense subspace within that key.<br/>
        If the tensor has multiple sparse dimensions: An array where the elements consist of a map with the keys
        "address" and "values", where "address" is a map with the sparse dimensions and their values (as in cells),
        and "values" is a nested array containing the values of the dense subspace within that address.
      </p>
      <p>Example - single sparse dimension:</p>
      <pre>{% highlight json %}
"tensorfield": {
    "x1":[2.0,3.0],
    "x2":[4.0,5.0]
}
{% endhighlight %}</pre>
      <p>Example - multiple sparse dimensions:</p>
      <pre>{% highlight json %}
"tensorfield": [
    {"address":{"x":"x1","y":"y2"},"values":[2.0,3.0]},
    {"address":{"x":"x2","y":"y2"},"values":[4.0,5.0]}
]
{% endhighlight %}</pre>
      <p>
        The values can optionally be nested in an object under the key "blocks".
        This is how tensor values are returned <a href="document-v1-api-reference.html#format.tensors">by default</a>,
        along with another key "type" containing the tensor type.
      </p>

      <p id="tensor-hex-dump">
        <strong>Short form for indexed tensors representing binary data</strong>
        (with <code>int8</code> cell value type):
        May use a string with a hex dump of the cell values:
      </p>
      <pre>{% highlight json %}
"tensorfield": "FF00118022FE"
{% endhighlight %}</pre>
      <p>can be used to represent the value <code>tensor&lt;int8&gt;(x[6]):[-1,0,17,-128,34,-2]</code>.</p>
      <p>The string object can optionally be nested in an object under the key "values".</p>

      <p>
        <strong>Verbose:</strong> <a href="../tensor-user-guide.html">Tensor</a> fields
        may be represented as an array of cells:
      </p>
      <pre>{% highlight json %}
"tensorfield": [
    { "address": { "x": "a", "y": "0" }, "value": 2.0 },
    { "address": { "x": "a", "y": "1" }, "value": 3.0 },
    { "address": { "x": "b", "y": "0" }, "value": 4.0 },
    { "address": { "x": "b", "y": "1" }, "value": 5.0 }
]
{% endhighlight %}</pre>
      <p>
        This works for any tensor but is verbose, so shorter forms specific to various tensor types are also supported.
        Use the shortest form applicable to your tensor type for the best possible performance.
      </p>
      <p>
        The cells array can optionally be nested in an object under the key "cells".
        This is how tensor values are returned <a href="document-v1-api-reference.html#format.tensors">by default</a>,
        along with another key "type" containing the tensor type.
      </p>
    </td>
  </tr>

  <tr>
    <th>struct</th>
    <td>
      <p id="struct"></p>
<pre>{% highlight json %}
"mystruct": {
    "intfield": 123,
    "stringfield": "foo"
}
{% endhighlight %}</pre>
    </td>
  </tr><tr>
    <th>map</th>
    <td>
      <p id="map">
      The JSON dictionary key must be a string,
      even if the map key type in the schema is not a string:
      </p>
<pre>{% highlight json %}
"int_to_string_map": {
    "123": "foo",
    "456": "bar",
    "789": "foobar"
}
{% endhighlight %}</pre>
      <p>
      Feeding in an empty map ({}) for a field will have the same effect as not
      feeding a value for that field, and the field will not be rendered in the
      document API and in document summaries.
      </p>
    </td>
  </tr><tr>
    <th>annotationreference</th>
    <td>
      <p id="annotationreference">
        <a href="../annotations.html">Annotation</a> references do not have a JSON representation
      </p>
    </td>
  </tr><tr>
    <th>reference</th>
    <td>
      <p id="reference">String with document ID referring to a <a href="../parent-child.html">parent document</a>:</p>
<pre>{% highlight json %}
"artist_ref": "id:mynamespace:artists::artist-1"
{% endhighlight %}</pre>
    </td>
  </tr><tr>
  </tr>
</table>


<h3 id="empty-fields">Empty fields</h3>
<p>
  In general, fields that have not received a value during feeding will be ignored
  when rendering the document. They are considered as empty fields.
  However, certain field types have some values which causes them to be considered empty.
  For instance, the empty string ("") is considered empty, as well as the empty array ([]).
  See the above table for more information for each type.reads-and-writes.html
</p>



<h2 id="document-operations">Document operations</h2>
<p>
Refer to <a href="../reads-and-writes.html">reads and writes</a> for details - alternatives:
</p>
<ul>
  <li>Use the <a href="../vespa-cli.html#documents">Vespa CLI</a>.</li>
  <li>
    <a href="document-v1-api-reference.html">/document/v1/</a>:
    This API accepts one operation per request, with the document ID encoded in the URL.
  </li>
  <li>
    <a href="../vespa-feed-client.html">Vespa feed client</a>:
    Java APIs / command line tool to feed document operations asynchronously to Vespa, over HTTP.
  </li>
</ul>


<h3 id="put">Put</h3>
<p>
  The "put" payload has a "put" operation and "fields"
  (<a href="../document-v1-api-guide.html#post">/document/v1/ example</a>):
</p>
<pre>{% highlight json %}
{
    "put": "id:music:music::123",
    "fields": {
        "title": "Best of Bob Dylan"
    }
}
{% endhighlight %}</pre>


<h3 id="get">Get</h3>
<p>
  "get" does not have a payload - the response has the same "field" object as in "put",
  and also "id" and "pathId" fields
  (<a href="../document-v1-api-guide.html#get">/document/v1/ example</a>):
</p>
<pre>{% highlight json %}
{
    "pathId": "/document/v1/music/music/docid/123",
    "id": "id:music:music::123",
    "fields": {
        "title": "Best of Bob Dylan"
    }
}
{% endhighlight %}</pre>


<h3 id="remove">Remove</h3>
<p>
  The "remove" payload has a "remove" operation
  (<a href="../document-v1-api-guide.html#delete">/document/v1/ example</a>):
</p>
<pre>{% highlight json %}
{
    "remove": "id:music:music::123"
}
{% endhighlight %}</pre>


<h3 id="update">Update</h3>
<p>
  The "update" payload has an "update" operation and "fields"
  (<a href="../document-v1-api-guide.html#put">/document/v1/ example</a>):
</p>
<pre>{% highlight json %}
{
    "update": "id:music:music::123",
    "fields": {
        "title": {
            "assign": "The best of Bob Dylan"
        }
    }
}
{% endhighlight %}</pre>



<h2 id="test-and-set">Test and set</h2>
<p>
An optional <em>condition</em> can be added to operations to specify a <em>test and set</em> condition -
see <a href="../document-v1-api-guide.html#conditional-writes">conditional writes</a>.
The value of the <em>condition</em> is a <a href="document-select-language.html">document selection</a>,
encoded as a string.
Example: Increment the <em>sales</em> field only if it is already equal to 999
  (<a href="../document-v1-api-guide.html#conditional-writes">/document/v1/ example</a>):
</p>
<pre>{% highlight json %}
{
    "update": "id:music:music::bob/BestOf",
    "condition": "music.sales==999",
    "fields": {
        "sales": {
            "increment": 1
        }
    }
}
{% endhighlight %}</pre>
{% include note.html content="Use <em>documenttype.fieldname</em> in the condition, not only <em>fieldname</em>."%}
<p>If the condition is not met, a 412 response code is returned.</p>
<!-- ToDo: There is a discussion whether to change to not return error,
           and instead return a <em>condition-not-met</em> in the response. -->



<h2 id="create">create (create if nonexistent)</h2>
<p>
<strong>Updates</strong> to nonexistent documents are supported using <em>create</em>.
(<a href="../document-v1-api-guide.html#create-if-nonexistent">/document/v1/ example</a>):
</p>
<pre>{% highlight json %}
{
    "update": "id:mynamespace:music::bob/BestOf",
    "create": true,
    "fields": {
        "title": {
            "assign": "The best of Bob Dylan"
        }
    }
}
{% endhighlight %}</pre>
<p>
  Since Vespa 8.178, <em>create</em> can also be used together with conditional <strong>Put</strong> operations
  (<a href="../document-v1-api-guide.html#conditional-updates-and-puts-with-create">/document/v1/ example</a>
  - review notes there before using):
</p>
<pre>{% highlight json%}
{
    "put": "id:music:music::123",
    "condition": "music.sales==999",
    "create": true,
    "fields": {
        "title": "Best of Bob Dylan"
    }
}
{% endhighlight %}</pre>



<h2 id="assign">assign</h2>
<p>
<code>assign</code> is used to replace the value of a field (or an element of a collection) with a new value.
When assigning, one can generally use the same syntax and structure
as when feeding that field's value in a <code>put</code> operation.
</p>


<h3 id="single-field-value">Single value field</h3>
<pre>
field title type string {
    indexing: summary
}
</pre>
<pre>{% highlight json %}
{
    "update": "id:mynamespace:music::example",
    "fields": {
        "title": {
            "assign": "The best of Bob Dylan"
        }
    }
}
{% endhighlight %}</pre>


<h3 id="tensor-field">Tensor field</h3>
<pre>
field tensorfield type tensor(x{},y{}) {
    indexing: attribute | summary
}
</pre>
<pre>{% highlight json %}
{
    "update": "id:mynamespace:tensordoctype::example",
    "fields": {
        "tensorfield": {
            "assign": {
                "cells": [
                    { "address": { "x": "a", "y": "b" }, "value": 2.0 },
                    { "address": { "x": "c", "y": "d" }, "value": 3.0 }
                ]
            }
        }
    }
}
{% endhighlight %}</pre>

<p>This will fully replace the entire tensor stored in this field.</p>


<h3 id="<struct-field">Struct field</h3>

<h4 id="replacing-all-fields-in-a-struct">Replacing all fields in a struct</h4>
<p>
  A full struct is replaced by assigning an object of struct key/value pairs.
</p>
<pre>
struct person {
    field first_name type string {}
    field last_name type string {}
}
field contact type person {
    indexing: summary
}
</pre>
<pre>{% highlight json %}
{
    "update": "id:mynamespace:workers::example",
    "fields": {
        "contact": {
            "assign": {
                "first_name": "Bob",
                "last_name": "The Plumber"
            }
        }
    }
}
{% endhighlight %}</pre>

<h4 id="individual-struct-fields">Individual struct fields</h4>
<p>
  Individual struct fields are updated using <a href="#fieldpath">field path</a> syntax.
  Refer to the <a href="schema-reference.html#struct-name">reference</a> for restrictions using structs.
</p>
<pre>{% highlight json %}
{
    "update": "id:mynamespace:workers::example",
    "fields": {
        "contact.first_name": {
            "assign": "Bob"
        },
        "contact.last_name": {
            "assign": "The Plumber"
        }
    }
}
{% endhighlight %}</pre>


<h3 id="assign-map-field">Map field</h3>
<p>
  Individual map entries can be updated using <a href="document-field-path.html">field path</a> syntax.
  The following declaration defines a <code>map</code> where the <code>key</code> is an Integer
  and the value is a <code>person</code> struct.
</p>
<pre>
struct person {
    field first_name type string {}
    field last_name type string {}
}
field contact type map&lt;int, person&gt; {
    indexing: summary
}
</pre>
<p>Example updating part of an entry in the <code>contact</code> map:</p>
<ul>
  <li><code>contact</code> is the name of the map field to be updated</li>
  <li><code>{0}</code> is the key that is going to be updated</li>
  <li><code>first_name</code> is the struct field to be updated inside the <code>person</code> struct</li>
</ul>
<pre>{% highlight json %}
{
    "update": "id:mynamespace:workers::example",
    "fields": {
        "contact{0}.first_name": {
            "assign": "John"
        }
    }
}
{% endhighlight %}</pre>
<p>
Assigning an element to a key in a map will insert the key/value mapping if it does not already exist,
or overwrite it with the new value if it does exist.
Refer to the <a href="schema-reference.html#map">reference</a> for restrictions using maps.
</p>

<h4 id="map-to-primitive-value">Map to primitive value</h4>
<pre>
field my_food_scores type map&lt;string, string&gt; {
    indexing: summary
}
</pre>
<pre>{% highlight json %}
{
    "update": "id:mynamespace:food::example",
    "fields": {
        "my_food_scores{Strawberries}": {
            "assign": "Delicious!"
        }
    }
}
{% endhighlight %}</pre>

<h4 id="map-to-struct">Map to struct</h4>
<pre>
struct contact_info {
    field phone_number type string {}
    field email type string {}
}
field contacts type map&lt;string, contact_info&gt; {
    indexing: summary
}
</pre>
<pre>{% highlight json %}
{
    "update": "id:mynamespace:people::d_duck",
    "fields": {
        "contacts{\"Uncle Scrooge\"}": {
            "assign": {
                "phone_number": "555-123-4567",
                "email": "number_one_dime_luvr1877@example.com"
            }
        }
    }
}
{% endhighlight %}</pre>


<h3 id="array-field">Array field</h3>

<h4 id="array-of-primitive-values">Array of primitive values</h4>
<pre>
field ingredients type array&lt;string&gt; {
    indexing: summary
}
</pre>
<p>Assign full array:</p>
<pre>{% highlight json %}
{
    "update": "id:mynamespace:cakes:tasty_chocolate_cake",
    "fields": {
        "ingredients": {
            "assign": [ "sugar", "butter", "vanilla", "flour" ]
        }
    }
}
{% endhighlight %}</pre>
<p>Assign existing elements in array:</p>
<pre>{% highlight json %}
{
    "update": "id:mynamespace:cakes:tasty_chocolate_cake",
    "fields": {
        "ingredients[3]": {
            "assign": "2 cups of flour (editor's update: NOT asbestos!)"
        }
    }
}
{% endhighlight %}</pre>
<p>Note that the index element 3 needs to exist. Alternative using match:</p>
<pre>{% highlight json %}
{
    "update": "id:mynamespace:cakes:tasty_chocolate_cake",
    "fields": {
        "ingredients": {
            "match": {
                "element": 3,
                "assign": "2 cups of flour (editor's update: NOT asbestos!)"
            }
        }
    }
}
{% endhighlight %}</pre>
<p>
  Individual array elements may be updated using <a href="document-field-path.html">field path</a>
  or <a href="#match">match</a> syntax.
</p>

<h4 id="array-of-struct">Array of struct</h4>
<p>
Refer to the reference for restrictions using
<a href="schema-reference.html#array">array of structs</a>.
</p>
<pre>
struct person {
    field first_name type string {}
    field last_name type string {}
}
field people type array&lt;person&gt; {
    indexing: summary
}
</pre>
<pre>{% highlight json %}
{
    "update": "id:mynamespace:students:example",
    "fields": {
        "people[34]": {
            "assign": {
                "first_name": "Bobby",
                "last_name": "Tables"
            }
        }
    }
}
{% endhighlight %}</pre>
<p>Note that the element index needs to exist. Use <a href="#add-array-elements">add</a> to add a new element.
Alternative syntax using match:</p>
<pre>{% highlight json %}
{
    "update": "id:mynamespace:students:example",
    "fields": {
        "people": {
            "match": {
                "element": 34,
                "assign": {
                     "first_name": "Bobby",
                     "last_name": "Tables"
                }
            }
        }
    }
}
{% endhighlight %}</pre>


<h3 id="weighted-set-field">Weighted set field</h3>
<p>
Adding new elements to a weighted set can be done using <a href="#add-weighted-set">add</a>, or
by assigning with <code>field{key}</code> syntax. Example of the latter:
</p>
<pre>
field int_weighted_set type weightedset&lt;int&gt; {
    indexing: summary
}
field string_weighted_set type weightedset&lt;string&gt; {
    indexing: summary
}
</pre>
<pre>{% highlight json %}
{
    "update":"id:weightedsetdoctype:weightedsetdoctype::example1",
    "fields": {
        "int_weighted_set{123}": {
            "assign": 123
        },
        "int_weighted_set{456}": {
            "assign": 100
        },
        "string_weighted_set{\"item 1\"}": {
            "assign": 144
        },
        "string_weighted_set{\"item 2\"}": {
            "assign": 7
        }
    }
}
{% endhighlight %}</pre>
<p>
Note that using the <code>field{key}</code> syntax for weighted sets <em>may</em> be
less efficient than using <a href="#add-weighted-set">add</a>.
</p>


<h3 id="clearing-a-field">Clearing a field</h3>
<p>To clear a field, assign a <code>null</code> value to it.</p>
<pre>{% highlight json %}
{
    "update": "id:mynamespace:music::example",
    "fields": {
        "title": {
            "assign": null
        }
    }
}
{% endhighlight %}</pre>



<h2 id="add">add</h2>
<p>
<code>add</code> is used to add entries to arrays, weighted sets or to the mapped dimensions of tensors.
</p>


<h3 id="add-array-elements">Adding array elements</h3>
<p>
The added entries are appended to the end of the array in the order specified.
</p>
<pre>
field tracks type array&lt;string&gt; {
    indexing: summary
}
</pre>
<pre>{% highlight json %}
{
    "update": "id:mynamespace:music::https://music.yahoo.com/bobdylan/BestOf",
    "fields": {
       "tracks": {
            "add": [
                "Lay Lady Lay",
                "Every Grain of Sand"
            ]
        }
    }
}
{% endhighlight %}</pre>


<h3 id="add-weighted-set">Add weighted set entries</h3>
<p>
Add weighted set elements by using a JSON key/value syntax,
where the value is the weight of the element.
</p>
<p>Adding a key/weight mapping that already exists will overwrite the existing weight with the new one.</p>
<pre>
field int_weighted_set type weightedset&lt;int&gt; {
    indexing: summary
}
field string_weighted_set type weightedset&lt;string&gt; {
    indexing: summary
}
</pre>
<pre>{% highlight json %}
{
    "update":"id:weightedsetdoctype:weightedsetdoctype::example1",
    "fields": {
        "int_weighted_set": {
            "add": {
                "123": 123,
                "456": 100
            }
        },
        "string_weighted_set": {
            "add": {
                "item 1": 144,
                "item 2": 7
            }
        }
    }
}
{% endhighlight %}</pre>


<h3 id="tensor-add">Add tensor cells</h3>
<p>
Add cells to mapped or mixed tensors. Invalid for tensors with only indexed
dimensions. Adding a cell that already exists will overwrite the cell value with the new value.
The address must be fully specified, but cells with bound indexed dimensions not specified
will receive the default value of <code>0.0</code>.
See system test
<a href="https://github.com/vespa-engine/system-test/tree/master/tests/search/tensor_feed/tensor_add_remove_update">tensor add update</a>
for more examples.
</p>
<pre>
field tensorfield type tensor(x{},y[3]) {
    indexing: attribute | summary
}
</pre>
<pre>{% highlight json %}
{
    "update": "id:mynamespace:tensordoctype::example",
    "fields": {
        "tensorfield": {
            "add": {
                "cells": [
                    { "address": { "x": "b", "y": "0" }, "value": 2.0 },
                    { "address": { "x": "b", "y": "1" }, "value": 3.0 }
                ]
            }
        }
    }
}
{% endhighlight %}</pre>
<p>In this example, cell <code>{"x":"b","y":"2"}</code> will implicitly be set to 0.0.</p>

<p>So if you started with the following tensor:</p>
<pre>
{
    {"x": "a", "y": "0"}: 0.2,
    {"x": "a", "y": "1"}: 0.3,
    {"x": "a", "y": "2"}: 0.5,
}</pre>

<p>You now end up with this tensor after the above add operation was applied:</p>
<pre>
{
    {"x": "a", "y": "0"}: 0.2,
    {"x": "a", "y": "1"}: 0.3,
    {"x": "a", "y": "2"}: 0.5,
    {"x": "b", "y": "0"}: 2.0,
    {"x": "b", "y": "1"}: 3.0,
    {"x": "b", "y": "2"}: 0.0,
}</pre>

<p>
  Prefer the <em>block short form</em> for mixed tensors instead.
  This also avoids the problem where cells with indexed dimensions are not specified:
</p>
<pre>{% highlight json %}
{
    "update": "id:mynamespace:tensordoctype::example",
    "fields": {
        "tensorfield": {
            "add": {
                "blocks": [
                    { "address": { "x": "b" }, "values": [2.0, 3.0, 5.0] }
                ]
            }
        }
    }
}
{% endhighlight %}</pre>



<h2 id="composite-remove">remove</h2>
<p>Remove elements from weighted sets, maps and tensors with <code>remove</code>.</p>

<h4 id="weighted-set-field-remove">Weighted set field</h4>
<pre>
field string_weighted_set type weightedset&lt;string&gt; {
    indexing: summary
}
</pre>
<pre>{% highlight json %}
{
    "update":"id:mynamespace:weightedsetdoctype::example1",
    "fields":  {
        "string_weighted_set": {
            "remove": {
                "item 2": 0
            }
        }
    }
}
{% endhighlight %}</pre>

<h4 id="map-field-remove">Map field</h4>
<pre>
field string_map type map&lt;string, string&gt; {
    indexing: summary
}
</pre>
<pre>{% highlight json %}
{
    "update":"id:mynamespace:mapdoctype::example1",
    "fields":  {
        "string_map{item 2}": {
            "remove": 0
        }
    }
}
{% endhighlight %}</pre>

<h4 id="tensor-remove">Tensor field</h4>
<p>
Removes cells from mapped or mixed tensors.
Invalid for tensors with only indexed dimensions.
Only mapped dimensions should be specified for tensors with both
mapped and indexed dimensions, as all indexed cells the mapped
dimensions point to will be removed implicitly.
See system test
<a href="https://github.com/vespa-engine/system-test/tree/master/tests/search/tensor_feed/tensor_add_remove_update">tensor remove update</a>
for more examples.
</p>
<pre>
field tensorfield type tensor(x{},y[2]) {
    indexing: attribute | summary
}
</pre>
<pre>{% highlight json %}
{
    "update": "id:mynamespace:tensordoctype::example",
    "fields": {
        "tensorfield": {
            "remove": {
                "addresses": [
                    {"x": "b"},
                    {"x": "c"}
                ]
            }
        }
    }
}
{% endhighlight %}</pre>
<p>In this example, cells <code>{x:b,y:0},{x:b,y:1},{x:c,y:0},{x:c,y:1}</code> will be removed.</p>
<p>
It is also supported to specify only a subset of the mapped dimensions in the addresses.
In that case, all cells that match the label values of the specified dimensions are removed.
In the given example, all cells having label <code>b</code> for dimension <code>x</code> are removed.
</p>
<pre>
field tensorfield type tensor(x{},y{},z[2]) {
    indexing: attribute | summary
}
</pre>
<pre>{% highlight json %}
{
    "update": "id:mynamespace:tensordoctype::example",
    "fields": {
        "tensorfield": {
            "remove": {
                "addresses": [
                    {"x": "b"}
                ]
            }
        }
    }
}
{% endhighlight %}</pre>



<h2 id="arithmetic">Arithmetic</h2>
<p>
The four arithmetic operators <code>increment</code>, <code>decrement</code>,
<code>multiply</code> and <code>divide</code> are used to modify <em>single
value</em> numeric values without having to look up the current
value before applying the update. Example:
</p>
<pre>
field sales type int {
    indexing: summary | attribute
}
</pre>
<pre>{% highlight json %}
{
    "update": "id:music:music::https://music.yahoo.com/bobdylan/BestOf",
    "fields": {
        "sales": {
            "increment": 1
        }
    }
}
{% endhighlight %}</pre>



<h2 id="match">match</h2>
<p>
If an arithmetic operation is to be done for a specific key
in a <em>weighted set or array</em>, use the <code>match</code> operation:
</p>
<pre>
field track_popularity type weightedset&lt;string&gt; {
    indexing: summary | attribute
}
</pre>
<pre>{% highlight json %}
{
    "update": "id:music:music::https://music.yahoo.com/bobdylan/BestOf",
    "fields": {
        "track_popularity": {
            "match": {
                "element": "Lay Lady Lay",
                "increment": 1
            }
        }
    }
}
{% endhighlight %}</pre>
<p>
In other words, for the weighted set "track_popularity",
<code>match</code> the element "Lay Lady Lay", then <code>increment</code> its weight by 1.
See the <a href="schema-reference.html#weightedset">reference</a> for how to auto-create keys.
</p>
<p>If the updated field is an array, the <code>element</code> value would be a positive integer.</p>
{% include note.html content='Only <span style="text-decoration: underline">one</span>
element can be matched per operation.' %}



<h2 id="tensor-modify">Modify tensors</h2>
<p>
Individual cells in tensors can be modified using the <code>modify</code> update.
The cells are modified according to the given operation:
</p>
<ul>
  <li><code>replace</code> - replaces a single cell value</li>
  <li><code>add</code> - adds a value to the existing cell value</li>
  <li><code>multiply</code> - multiples a value with the existing cell value</li>
</ul>
<p>
The addresses of cells must be fully specified. If the cell does not exist, the update for that cell will be ignored.
Use <code>"create": true</code> (see example below) to create non-existing cells before the modify update is applied.
See system test
<a href="https://github.com/vespa-engine/system-test/tree/master/tests/search/tensor_feed/tensor_modify_update">tensor modify update</a>
for more examples.
</p>
<pre>
field tensorfield type tensor(x[3]) {
    indexing: attribute | summary
}
</pre>
<pre>{% highlight json %}
{
    "update": "id:mynamespace:tensordoctype::example",
    "fields": {
        "tensorfield": {
            "modify": {
                "operation": "replace",
                "addresses": [
                    { "address": { "x": "1" }, "value": 7.0 },
                    { "address": { "x": "2" }, "value": 8.0 }
                ]
            }
        }
    }
}
{% endhighlight %}</pre>
<p>
In this example, cell <code>{"x":"1"}</code> is replaced with value 7.0 and <code>{"x":"2"}</code> with value 8.0.
If operation <code>add</code> or <code>multiply</code> was used instead,
7.0 and 8.0 would be added or multiplied to the current values of cells <code>{"x":"1"}</code> and <code>{"x":"2"}</code>.
</p>

<p>For tensors with a single mapped dimension the <em>cells short form</em> can also be used:</p>
<pre>
field tensorfield type tensor(x{}) {
    indexing: attribute | summary
}
</pre>
<pre>{% highlight json %}
{
    "update": "id:mynamespace:tensordoctype::example",
    "fields": {
        "tensorfield": {
            "modify": {
                "operation": "add",
                "create": true,
                "cells": {
                    "b": 5.0,
                    "c": 6.0
                }
            }
        }
    }
}
{% endhighlight %}</pre>
<p>
In this example, 5.0 is added to cell <code>{"x":"b"}</code> and 6.0 is added to cell <code>{"x":"c"}</code>.
With <code>"create": true</code> non-existing cells in the input tensor are created before applying the modify update.
The default cell value is 0.0 for <code>replace</code> and <code>add</code>, and 1.0 for <code>multiply</code>.
This means a non-existing cell ends up with the value specified in the operation.
</p>

<p>For mixed tensors the <em>block short form</em> can also be used to modify entire dense subspaces:</p>
<pre>
field tensorfield type tensor(x{},y[3]) {
    indexing: attribute | summary
}
</pre>
<pre>{% highlight json %}
{
    "update": "id:mynamespace:tensordoctype::example",
    "fields": {
        "tensorfield": {
            "modify": {
                "operation": "replace",
                "blocks": {
                    "a": [1,2,3],
                    "b": [4,5,6]
                }
            }
        }
    }
}
{% endhighlight %}</pre>



<h2 id="fieldpath">fieldpath</h2>
<p>
Fieldpath is for accessing fields within composite structures -
for structures that are not part of index or attribute,
it is possible to access elements directly using fieldpaths.
This is done by adding more information to the field value.
For map structures, specify the key (see <a href="#assign">example</a>).
</p>
<pre>
mymap{mykey}
</pre>
<p>
and then do operation on the element which is keyed by "mykey".
Arrays can be accessed as well (see <a href="#assign">details</a>).
</p>
<pre>
myarray[3]
</pre>
<p>
And this is also true for structs (see <a href="#assign">details</a>).
<strong>Note:</strong> Struct updates do not work for
<a href="services-content.html#document">index</a> mode:
</p>
<pre>
mystruct.value1
</pre>
<p>
This also works for nested structures,
e.g. a <code>map</code> of <code>map</code> to <code>array</code> of <code>struct</code>:
</p>
<pre>{% highlight json %}
{
    "update": "id:mynamespace:complexdoctype::foo",
    "fields": {
        "nested_structure{firstMapKey}{secondMapKey}[4].title": {
            "assign": "Look at me, mom! I'm hiding deep in a nested type!"
        }
    }
}
{% endhighlight %}</pre>
