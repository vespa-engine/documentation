---
# Copyright Vespa.ai. All rights reserved.
title: "Schemas"
redirect_from:
- /en/schema-inheritance.html
---

<p>This is an introduction to schemas in Vespa. You can find all the details in the
<a href="reference/schema-reference.html">schema reference</a>.</p>

<p>A schema defines a type of data and what we want to compute over it.
An application package can contain multiple schemas for different kinds of data.
Each content cluster specified in services.xml refers to the schemas that should be stored an indexed
in that cluster. Schemas can inherit other schemas to avoid repeating common content.</p>

<p>Schemas are placed in files named the same as the schema, with the ending ".sd" (for schema definition),
in the <code>schemas/</code> directory of the application package.</p>


<h2 id="document-fields">Document fields</h2>

<p>A schema contains a document type, which is a named collection of fields:</p>

<pre>
schema mySchema {

    document mySchema {

        field myField type string {
            indexing: summary | index
        }

        ... more fields

    }

}
</pre>

<p>Each field has a type, a way it should be processed and indexed, and optionally other settings.
The main decision you make is how the field should be used in queries, determined by the <code>indexing</code>
statement:</p>

<ul>
    <li><code>indexing: summary</code>: The field should be available in query responses
        (<a href="document-summaries.html">document summaries</a>).
    <li><code>indexing: index</code>: If a string: Create a full-text on-disk index.
        If a tensor: Create an HNSW vector index (requires <code>attribute</code> in addition).
    <li><code>indexing: attribute</code>: For any field type: Make the field value available for structured search
        (exact, range, regexp etc.), ranking, sorting, grouping, and aggregation in the
        <a href="attributes.html">in-memory column store</a>.
        Suitable for structured data.
    <li><code>indexing: attribute</code> and <code>attribute: fast-search</code>: As above, but in addition, create an index
        over this data to make it an efficient filter. Suitable for structured fields that are used as strong filters in queries.
</ul>

<p>The indexing statement can contain multiple expressions separated by a pipe character, and these can also preprocess the
value, so the pipe should be read as passing to the next expression, as on Unix. See the
<a href="https://docs.vespa.ai/en/reference/schema-reference.html#field">reference</a> for all the types and content of fields.</p>

<p>When a schema is defined and added to a content cluster, you can <a href="writing.html">write data</a>
according to it, and <a href="querying.html">query</a> using the attributes and indexed fields in it.
Indexing always happens automatically in real time.</p>


<h2 id="synthetic-fields">Synthetic fields</h2>

<p>The document type in the schema defines the fields that you can put and get (read and write) for that document type.
However, sometimes you want to take an input field and process it in some way before it is stored/indexed. To do that,
you can create additional synthetic fields outside the document in the schema:</p>

<pre>
schema mySchema {

    document mySchema {

        field myField type string {
            indexing: summary | index
        }

        ...

    }

    field mySyntheticField type tensor(x[386]) {
        indexing: input myField | <a href="embedding.html">embed</a> | attribute | index
    }

}
</pre>


<h2 id="rank-profiles">Rank profiles</h2>

<p>A <i>rank profile</i> specifies what should be computed over the data described by the schema,
and how the documents of it should be ranked to select the ones to return in a query response:</p>

<pre>
schema mySchema {

    ...

    rank-profile hybrid {

        first-phase {
            expression: 0.3 * bm25(myText) + 0.5 * closeness(myEmbedding) * 0.2 * attribute(popularity)
        }

    }

}
</pre>

<p>A schema can have any number of rank profiles for different use cases, experiments and so on,
and each can have multiple functions that compute some value to be returned or used in ranking.
In addition to simple math functions like the above these can also be machine-learned models.
See <a href="ranking.html">ranking</a> for more.</p>


<h2 id="working-with-schemas">Working with schemas</h2>

<p>Schemas may become thousands of lines, with inheritance, multiple rank functions calling each other and so on.
The most efficient way of working with them is to use an IDE and install the Vespa plugin to get syntax highlighting,
completions and navigation - see <a href="ide-support.html">IDE support</a>.

<p>What happens if you change the schema of a running application?


<ul>
    <li><b>Adding new fields</b>: No problem, the new field will be added and have no value until data is written to it.
    <li><b>Changing how a field is indexed</b>: This will automatically cause a background reindexing on Vespa Cloud,
    but in the meantime there may be inconsistency in how the field is used in queries and writes, so in production it
    is sometimes preferable to create a new field instead.
    <li><b>Removing a field:</b> Data and indexes are removed for the field.
    <li><b>Changing the type of a field:</b> Existing data and indexes are removed for the field. For this reason, it is
    often preferable to add a new field instead, populate it, switch usages to the new field, then remove the old.
</ul>

<p>You can find the details in <a href="reference/schema-reference.html#modifying-schemas">modifying schemas</a>.</p>
