---
# Copyright Yahoo. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.
title: "Linguistics in Vespa"
redirect_from:
- /documentation/linguistics.html
---

<p>
Vespa uses a <em>linguistics</em> module to process text in queries and documents during indexing and searching.
The goal of linguistic processing is to increase <em>recall</em> (how many documents are matched)
without hurting <em>precision</em> (the relevance of the documents matched) too much.
It consists of such operations as:
</p>
<ul>
  <li>tokenizing text into chunks of known types such as words and punctuation</li>
  <li>normalizing accents</li>
  <li>finding the base form of words (stemming or lemmatization)</li>
</ul>
<p>
These operations can be turned on or off per field in the <a href="schemas.html">schema</a>.
  See <a href="reference/query-language-reference.html#implicittransforms">implicitTransforms</a>
  for how to enable/disable transforms per query term.
</p><p>
The default linguistics module is <a href="https://opennlp.apache.org/">OpenNlp</a>.
</p><p>
See <a href="text-matching-ranking.html">Text Matching and Ranking</a>
for examples and how to experiment with data.
</p>



<h2 id="creating-a-custom-linguistics-implementation">Creating a custom linguistics implementation</h2>
<p>
A linguistics component is an implementation of
<a href="https://github.com/vespa-engine/vespa/blob/master/linguistics/src/main/java/com/yahoo/language/Linguistics.java">
    com.yahoo.language.Linguistics</a>. Refer to the
<a href="https://github.com/vespa-engine/vespa/blob/master/linguistics/src/main/java/com/yahoo/language/simple/SimpleLinguistics.java">
    com.yahoo.language.simple.SimpleLinguistics</a> implementation (which  can be subclassed for convenience).
</p><p>
SimpleLinguistics provides support for english stemming only.
Try loading the <code>com.yahoo.language.simple.SimpleLinguistics</code> module,
or providing another linguistics module.
</p><p>
The linguistics implementation must be configured as a component
in container clusters doing linguistics processing,
see <a href="jdisc/injecting-components.html">injecting components</a>.
</p><p>
As document processing for indexing is by default done by an autogenerated container cluster
which cannot be configured, specify a container cluster for indexing explicitly.
</p><p>
This example shows how to configure SimpleLinguistics for linguistics using the same cluster for both query and indexing processing
(if using different clusters, add the same linguistics component to all of them):
</p>
<pre>
&lt;services&gt;

  &lt;container version="1.0" id="mycontainer"&gt;
    <span class="pre-hilite">&lt;component id="com.yahoo.language.simple.SimpleLinguistics"/&gt;</span>
    &lt;document-processing/&gt;
    &lt;search/&gt;
    &lt;nodes ...&gt;
  &lt;/container&gt;

  &lt;content version="1.0"&gt;
    &lt;redundancy&gt;1&lt;/redundancy&gt;
    &lt;documents&gt;
      &lt;document type="mydocument" mode="index"/&gt;
      <span class="pre-hilite">&lt;document-processing cluster="mycontainer"/&gt;</span>
    &lt;/documents&gt;
    &lt;nodes ...&gt;
  &lt;/content&gt;

&lt;/services&gt;
</pre>
<p>
If changing the linguistics component of a live system,
recall can be reduced until all documents are re-written.
This because documents will still be stored with tokens generated by the previous linguistics module.
</p>



<h2 id="language-handling">Language handling</h2>
<p>
Vespa does <em>not</em> know the language of a document - this applies:
</p>
<ol>
  <li>The indexing processor is instructed on a per-field level what language to
use when calling the underlying linguistics library</li>
  <li>The query processor is instructed on a per-query level what language to use</li>
</ol>
<p>
If no language is explicitly set in a document or a query,
Vespa will run its configured language detector on the available text
(the full content of a document field, or the full <code>query=</code> parameter value).
</p><p>
A document that contains the exact same word as a query might not be recall-able
if the language of the document field is detected differently from the query.
Unless the query has explicitly declared a <a href="reference/query-api-reference.html#model.language">language</a>,
this can occur.
</p>


<h3 id="indexing-with-language">Indexing with language</h3>
<p>
The indexing process run by Vespa is a sequential execution
of the indexing script of every field in the input document.
At any point, the script may choose to set the language state of the processor
using <a href="reference/advanced-indexing-language.html#set_language">set_language</a>. Example:
</p>
<pre>
schema book {
    document book {
        field language type string {
            indexing: set_language
        }
        field title type string {
            indexing: index
        }
    }
}
</pre>
<p>
Indicating that every document in the input is expected to have its own language.
</p><p>
Because indexing scripts are executed in the order they are given in the schema,
and because the language state is never reset during the processing of a single document,
all indexed string fields following the <code>language</code> field
will be processed under the rules of that language.
</p><p>
The only thing that changes due to language is the output from
<code>normalize</code> and <code>tokenize</code>.
Now, because <code> indexing: index</code> implies <code>tokenize</code> for string fields,
the field <code>title</code> is affected.
</p><p>
If either <code>normalize</code> or <code>tokenize</code> is invoked prior to <code>set_language</code>,
the language detector is run on the input string.
</p><p>
The net result of this is that by calling <code>set_language</code> inside a document,
the terms that end up in a tokenized index are changed.
This means that at query-time, one must apply the same language settings before tokenizing the query terms
to be able to match what was stored in the index.
This also means that a single index may simultaneously contain terms of multiple languages.
</p><p>
Even if a document contains a string field used as input for the <code>set_language</code> indexing expression,
there is no automation in storing this language in an index.
To filter by language at some point, save this field as an attribute.
</p><p>
If all documents have the same language, hardcode it this way:
</p>
<pre>
schema doc {

    field language type string {
        indexing: "en" | set_language
    }

    document doc {
    ...
</pre>


<h3 id="querying-with-language">Querying with language</h3>
<p>
The content of an indexed string field is hence language-agnostic.
One must therefore apply a symmetric tokenization on the query terms in order to match the content of that field.
</p><p>
The query parser subscribes to configuration that tells it what fields are indexed strings,
and every query term that targets such a field are run through appropriate tokenization.
The <code>language</code> query parameter is what controls the language state of these calls.
</p><p>
Because an index may simultaneously contain terms in any number of languages,
one can have stemmed variants of one language match the stemmed variants of another.
To work around this, store the language of a document in a separate attribute,
and apply a filter against that attribute at query-time.
</p><p>
If no language parameter is given, the language detector is called to process the query string.
The detector is likely to be confused by field names and query syntax,
but it is a best-effort approach.
This matches the language resolution of the index pipeline.
</p><p>
By default, there is no knowledge anywhere that captures what
languages are used to generate the content of an index.
The language parameter only affects the transformation of query terms that hit tokenized indexes.
</p>


<h3 id="multiple-languages">Multiple languages</h3>
<p>
Approaches:
</p>
<ol>
    <li>
        Use semantic retrieval using a sentence encoder,
        which has been trained on multi-lingual corpus like the one used in
        <a href="semantic-qa-retrieval.html">Semantic QA retrieval</a>.
        Sentence-Bert is another. First phase matching is then done using approximate nearest neighbor:
        <a href="https://github.com/vespa-engine/vespa/issues/9747">#9747</a>.
        Query terms can also be passed down for fine-tuning of precision.
    </li><li>
        Stem and tokenize the query using the relevant languages,
        build a query tree using <a href="reference/query-language-reference.html#weakand">weakAnd</a> /
        <a href="reference/query-language-reference.html#or">or</a>
        and using <a href="reference/query-language-reference.html#equiv">equiv</a> per stem variant.
        This is easiest done in a custom <a href="searcher-development.html">Searcher</a> as mentioned in
        <a href="https://github.com/vespa-engine/vespa/issues/12154">#12154</a>.
    </li>
</ol>
<p>
Example:
</p><p>
<strong>lang=fr:</strong> machine learning =&gt; machin learn
</p><p>
<strong>lang=en:</strong> machine learning =&gt; machine learn
</p><p>
Using <em>weakAnd</em> here as example as that technique is already mentioned in #12154:
</p>
<pre>
select * from sources * where rank(weakAnd(default contains equiv("machin", "machine"), default contains "learn)), default contains "machine", default contains "learning")
</pre>
<p>
We now retrieve using all possible stems/base forms with <em>weakAnd</em>,
and use the <a href="reference/query-language-reference.html#rank">rank</a> operator
to pass in the original query form, so that ranking can rank literal matches (original) higher.
Benefit of <em>equiv</em> is that it allows multiple term variants to share the same position,
so that proximity ranking does not become broken by this approach.
</p>



<h2 id="tokenization">Tokenization</h2>
<p>
Tokenization removes any non-word characters,
and splits the string into <em>tokens</em> on each word boundary.
In addition, CJK tokens are split using a <em>segmentation</em> algorithm.
The resulting tokens are then searchable in the index.
</p><p>
To index strings as-is (that is, avoid tokenization),
use <code><a href="reference/schema-reference.html#indexing-rewrite">indexing-rewrite</a>: none</code>.
</p><p>
Also see <a href="reference/schema-reference.html#gram">N-gram matching</a>.
</p>



<h2 id="normalization">Normalization</h2>
<p> <!-- ToDo: write more here -->
An example normalization is Ã  &#x21D2; a.
Normalizing will cause accents and similar decorations which are often misspelled
to be normalized the same way both in documents and queries.
</p><p>
Vespa uses <a href="https://docs.oracle.com/javase/7/docs/api/java/text/Normalizer.html">java.text.Normalizer</a>
to normalize text, see
<a href="https://github.com/vespa-engine/vespa/blob/master/linguistics/src/main/java/com/yahoo/language/simple/SimpleTransformer.java">
SimpleTransformer.java</a>.
Normalization preserves case.
</p>
<p>
  Refer to the <a href="reference/query-language-reference.html#nfkc">nfkc</a> query term annotation.
  Also see the YQL <a href="reference/query-language-reference.html#accentdrop">accentDrop</a> annotation.
</p>



<h2 id="stemming">Stemming</h2>
<p>
Stemming means <em>translate a word to its base form</em>
(singular forms for nouns, infinitive for verbs),
using a <a href="https://en.wikipedia.org/wiki/Stemming">stemmer</a>.
Use of stemming increases search recall,
because the searcher is usually interested in documents containing query words
regardless of the word form used.
Stemming in Vespa is symmetric,
i.e. words are converted to stems both when indexing and searching.
</p><p>
Examples of this is when text is indexed,
the stemmer will convert the noun <em>reports</em> (plural) to <em>report</em>,
and the latter will be stored in the index.
Likewise, before searching, <em>reports</em> will be stemmed to <em>report</em>.
Another example is that <em>am</em>, <em>are</em> and <em>was</em>
will be stemmed to <em>be</em> both in queries and indexes.
</p><p>
When <a href="reference/schema-reference.html#bolding">bolding</a> is enabled,
all forms of the query term will be bolded.
I.e. when searching for <em>reports</em>,
both <em>report</em>, <em>reported</em> and <em>reports</em> will be bolded.
</p>
<p>
  See the <a href="reference/query-language-reference.html#stem">stem</a> query term annotation.
</p>


<h3 id="theory">Theory</h3>
<p>
From a matching point of view,
stemming takes all possible token strings and maps them into equivalence classes.
So in the example above, the set of tokens
{ <em>report</em>, <em>reports</em>, <em>reported</em> } are in an equivalence class.
To represent the class,
the linguistics library should pick the <span style="text-decoration: underline;">best</span> element in the class.
At query time, the text typed by a user will be tokenized,
and then each token should be mapped to the most likely equivalence class,
again represented by the shortest element that belongs to the class.
</p><p>
While the theory sounds pretty simple,
in practice it is not always possible to figure out which equivalence class a token should belong to.
A typical example is the string <em>number</em>.
In most cases we would guess this to mean a numerical entity of some kind,
and the equivalence class would be { <em>number</em>, <em>numbers</em> } - but it could also be a verb,
with a different equivalence class { <em>number</em>, <em>numbered</em>, <em>numbering</em> }.
These are of course closely related, and in practice they will be merged,
so we'll have a slightly larger equivalence class
{ <em>number</em>, <em>numbers</em>, <em>numbered</em>, <em>numbering</em> }
and be happy with that.
However, in a sentence such as <em>my legs keep getting number every day</em>,
the <em>number</em> token clearly does not have the semantics of a numerical entity,
but should be in the equivalence class
{ <em>numb</em>, <em>number</em>, <em>numbest</em>, <em>numbness</em> } instead.
But blindly assigning <em>number</em> to the equivalence class <em>numb</em> is clearly not right,
since the <em>more numb</em> meaning is much less likely than the <em>numerical entity</em> meaning.
</p><p>
The approach currently taken by the low-level linguistics library
will often lead to problems in the <em>number</em>-like cases as described above.
To give better recall, Vespa has implemented a <em>multiple</em> stemming option.
</p>


<h3 id="configuration">Configuration</h3>
<p>
By default, all words are stemmed to their <em>best</em> form.
Refer to the <a href="reference/schema-reference.html#stemming">
stemming reference</a> for other stemming types. To change type, add:
</p>
<pre>
stemming: [stemming-type]
</pre>
<p>
  Stemming can be set either for a field, a fieldset or as a default for all fields.
  Example: Disable stemming for the field <em>title</em>:
</p>
<pre>
field title type string {
    indexing: summary | index
    stemming: none
}
</pre>
<p>
  See <a href="reference/query-language-reference.html#andsegmenting">andSegmenting</a>
  for how to control re-segmenting when stemming.
</p>