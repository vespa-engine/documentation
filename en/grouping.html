---
# Copyright Yahoo. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.
title: "Grouping Information in Results"
redirect_from:
- /documentation/grouping.html
---

<script>
function showResult(elem) {
    openTab(encodeURI("https://doc-search.vespa.oath.cloud/search/?yql=select * from purchase where true | " +
        getGrouping(elem)));
}

function getGrouping(elem) {
    let e = elem.previousSibling;
    while(e && e.nodeType === Node.TEXT_NODE) {
        e = e.previousSibling;
    }
    return e.value;
}

function openTab(url) {
    const link = document.createElement('a');
    link.href = url;
    link.target = '_blank';
    document.body.appendChild(link);
    link.click();
    link.remove();
}
</script>
<p>
  Try running requests on the
  <a href="https://github.com/vespa-cloud/vespa-documentation-search#feed-grouping-examples">grouping example data</a>:
</p>
<div class="vespa-notification vespa-notification-query">
  <input type="text" value="all( group(customer) each(output(sum(price))) )"
         style="width: calc(100% - 155px); font-size: 1.6rem; color: #303030; font-family: 'Hind Madurai', sans-serif;"/>
  <button onclick="showResult(this)" class="button is-solid is-small"
          style="width: 150px; font-size: 1.6rem; font-family: 'Hind Madurai', sans-serif;">Run grouping</button>
</div>
<br/>

<p>
  The Vespa grouping language is a list processing language
  which describes how the query hits should be grouped, aggregated and presented in result sets.
  A grouping statement takes the list of all matches to a query as input and groups/aggregates
  it, possibly in multiple nested and parallel ways to produce the output.
  This is a logical specification, and does not indicate how it is executed,
  as instantiating the list of all matches to the query somewhere would be too expensive,
  and execution is distributed instead.
</p>
<p>
  Refer to the <a href="reference/query-api-reference.html#select">Query API reference</a>
  for how to set the <em>select</em> parameter,
  and the <a href="reference/grouping-syntax.html">Grouping reference</a> for details.
  Fields used in grouping must be defined as <a href="attributes.html">attribute</a> in the document schema.
  Grouping supports continuation objects for <a href="#pagination">pagination</a>.
</p>



<h2 id="the-grouping-language-structure">The grouping language structure</h2>
<p>
  The operations defining the structure of a grouping are:
</p>
<ul>
  <li><code>all(statement)</code>: Execute the nested statement once on the input list as a whole.</li>
  <li><code>each(statement)</code>: Execute the nested statement on each element of the input list.</li>
  <li><code>group(specification)</code>:
    Turn the input list into a list of list according to the grouping specification.</li>
  <li><code>output</code>: Output some value(s) at the current location in the structure.</li>
</ul>
<p>
  The parallel and nested collection of these operations defines both the structure of the computation
  and of the result it produces.
  For example, <code>all(group(customer) each(output(count())))</code>
  will take all matches, group them by customer id, and for each group output the count of hits in the group.
</p>
<p>
  Vespa distributes and executes the grouping program on content nodes, and merges results on container nodes -
  in multiple phases, as needed.
  As realizing such programs over a distributed data set requires more network round-trips than a regular search query,
  these queries may be more expensive than regular queries -
  see <code><a href="reference/query-api-reference.html#grouping.defaultmaxgroups">defaultMaxGroups</a></code> and the likes
  for how to control resource usage.
</p>



<h2 id="grouping-by-example">Grouping by example</h2>
<p>
For the entirety of this document, assume an index of engine part purchases:
</p>
<table class="table">
<thead>
<tr>
  <th>Date</th>
  <th>Price</th>
  <th>Tax</th>
  <th>Item</th>
  <th>Customer</th>
  </tr>
</thead>
<tbody>
<tr>
  <td>2006-09-06 09:00:00</td>
  <td>$1 000</td>
  <td>0.24</td>
  <td>Intake valve</td>
  <td>Smith</td>
  </tr>
<tr>
  <td>2006-09-07 10:00:00</td>
  <td>$1 000</td>
  <td>0.12</td>
  <td>Rocker arm</td>
  <td>Smith</td>
  </tr>
<tr>
  <td>2006-09-07 11:00:00</td>
  <td>$2 000</td>
  <td>0.24</td>
  <td>Spring</td>
  <td>Smith</td>
  </tr>
<tr>
  <td>2006-09-08 12:00:00</td>
  <td>$3 000</td>
  <td>0.12</td>
  <td>Valve cover</td>
  <td>Jones</td>
  </tr>
<tr>
  <td>2006-09-08 10:00:00</td>
  <td>$5 000</td>
  <td>0.24</td>
  <td>Intake port</td>
  <td>Jones</td>
  </tr>
<tr>
  <td>2006-09-08 11:00:00</td>
  <td>$8 000</td>
  <td>0.12</td>
  <td>Head</td>
  <td>Brown</td>
  </tr>
<tr>
  <td>2006-09-09 12:00:00</td>
  <td>$1 300</td>
  <td>0.24</td>
  <td>Coolant</td>
  <td>Smith</td>
  </tr>
<tr>
  <td>2006-09-09 10:00:00</td>
  <td>$2 100</td>
  <td>0.12</td>
  <td>Engine block</td>
  <td>Jones</td>
  </tr>
<tr>
  <td>2006-09-09 11:00:00</td>
  <td>$3 400</td>
  <td>0.24</td>
  <td>Oil pan</td>
  <td>Brown</td>
  </tr>
<tr>
  <td>2006-09-09 12:00:00</td>
  <td>$5 500</td>
  <td>0.12</td>
  <td>Oil sump</td>
  <td>Smith</td>
  </tr>
<tr>
  <td>2006-09-10 10:00:00</td>
  <td>$8 900</td>
  <td>0.24</td>
  <td>Camshaft</td>
  <td>Jones</td>
  </tr>
<tr>
  <td>2006-09-10 11:00:00</td>
  <td>$1 440</td>
  <td>0.12</td>
  <td>Exhaust valve</td>
  <td>Brown</td>
  </tr>
<tr>
  <td>2006-09-10 12:00:00</td>
  <td>$2 330</td>
  <td>0.24</td>
  <td>Rocker arm</td>
  <td>Brown</td>
  </tr>
<tr>
  <td>2006-09-10 10:00:00</td>
  <td>$3 770</td>
  <td>0.12</td>
  <td>Spring</td>
  <td>Brown</td>
  </tr>
<tr>
  <td>2006-09-10 11:00:00</td>
  <td>$6 100</td>
  <td>0.24</td>
  <td>Spark plug</td>
  <td>Smith</td>
  </tr>
<tr>
  <td>2006-09-11 12:00:00</td>
  <td>$9 870</td>
  <td>0.12</td>
  <td>Exhaust port</td>
  <td>Jones</td>
  </tr>
<tr>
  <td>2006-09-11 10:00:00</td>
  <td>$1 597</td>
  <td>0.24</td>
  <td>Piston</td>
  <td>Brown</td>
  </tr>
<tr>
  <td>2006-09-11 11:00:00</td>
  <td>$2 584</td>
  <td>0.12</td>
  <td>Connection rod</td>
  <td>Smith</td>
  </tr>
<tr>
  <td>2006-09-11 12:00:00</td>
  <td>$4 181</td>
  <td>0.24</td>
  <td>Rod bearing</td>
  <td>Jones</td>
  </tr>
<tr>
  <td>2006-09-11 13:00:00</td>
  <td>$6 765</td>
  <td>0.12</td>
  <td>Crankshaft</td>
  <td>Jones</td>
  </tr>
</tbody>
</table>



<h2 id="basic-grouping">Basic Grouping</h2>
<p>
Example: <em>Return the total sum of purchases per customer</em> - steps:
</p>
<ol>
  <li>
    Select all documents:
    <pre>/search/?yql=select * from sources * where true</pre>
  </li>
  <li>
    Take the list of all hits:
    <pre>all(...)</pre>
  </li>
  <li>
    Turn it into a list of lists of all hits having the same customer id:
    <pre>group(customer)</pre>
  </li>
  <li>
    For each of those lists of same-customer hits:
    each(...)
  </li>
  <li>
    Output the sum (an aggregator) of the price over all items in that list of hits:
    <pre>output(sum(price))</pre>
  </li>
</ol>
<p>
  Final query, producing the sum of the price of all purchases for each customer:
</p>
<p><a class="docsearch-x">select * from purchase where true limit 0 |
  all(
    group(customer)
    each(output(sum(price)))
  )</a></p>
<pre>
/search/?yql=select * from sources * where true limit 0 |
  all( group(customer) each(output(sum(price))) )
</pre>
<p>
  Here, limit is set to zero to get the grouping output only.
  URL encoded equivalent:
</p>
<pre>
/search/?yql=select%20%2A%20from%20sources%20%2A%20where%20true%20limit%200%20%7C%20
  all%28%20group%28customer%29%20each%28output%28sum%28price%29%29%29%20%29
</pre>
<p>Result:</p>
<table class="table">
<thead>
<tr>
  <th>GroupId</th>
  <th>Sum(price)</th>
  </tr>
</thead>
<tbody>
<tr>
  <td>Brown</td>
  <td>$20 537</td>
  </tr>
<tr>
  <td>Jones</td>
  <td>$39 816</td>
  </tr>
<tr>
  <td>Smith</td>
  <td>$19 484</td>
  </tr>
</tbody>
</table>
<p>
Example: <em>Sum price of purchases <a href="#time-and-date">per date</a>:</em>
</p>
<pre>
select (&hellip;) | all(group(time.date(date)) each(output(sum(price))))
</pre>
<table class="table">
<thead>
<tr>
  <th>GroupId</th>
  <th>Sum(price)</th>
  </tr>
</thead>
<tbody>
<tr>
  <td>2006-09-06</td>
  <td>$1 000</td>
  </tr>
<tr>
  <td>2006-09-07</td>
  <td>$3 000</td>
  </tr>
<tr>
  <td>2006-09-08</td>
  <td>$16 000</td>
  </tr>
<tr>
  <td>2006-09-09</td>
  <td>$12 300</td>
  </tr>
<tr>
  <td>2006-09-10</td>
  <td>$22 540</td>
  </tr>
<tr>
  <td>2006-09-11</td>
  <td>$24 997</td>
  </tr>
</tbody>
</table>
<p>
Note: in examples above, <em>all</em> documents are evaluated.
Modify the query to add filters (and thus cut latency), like (remember to URL encode):
</p>
<pre>/search/?yql=select * from sources * where customer contains "smith"</pre>




<h2 id="ordering-and-limiting-groups">Ordering and Limiting Groups</h2>
<p>
In many scenarios, a large collection of groups is produced, possibly too large to display or process.
This is handled by ordering groups, then limiting, the number of groups to return.
</p><p>
The <code>order</code> clause accepts a list of one or more expressions.
Each of the arguments to <code>order</code> is prefixed by either a plus/minus for ascending/descending order.
</p><p>
Limit the number of groups using <code>max</code> and <code>precision</code> -
the latter is the number of groups returned per content node to be merged to the global result.
Larger document distribution skews hence require a higher <code>precision</code> for accurate results.
</p>
<p>
  An implicit limit can be specified through the
  <code><a href="reference/query-api-reference.html#grouping.defaultmaxgroups">grouping.defaultMaxGroups</a></code> query parameter.
  This value will always be overridden if <code>max</code> explicitly specified in the query.
  Use <code>max(inf)</code> to retrieve all groups when the query parameter is set.
</p>
<p>
  If <code>precision</code> is not specified, it will default to a factor times <code>max</code>.
  This factor can be overridden through the
  <code><a href="reference/query-api-reference.html#grouping.defaultprecisionfactor">grouping.defaultPrecisionFactor</a></code>
  query parameter.
</p>
<p>
  Example: To find the 2 globally best groups, make an educated guess on how
  many samples are needed to fetch from each node in order to get the right groups.
  This is the <code>precision</code>.
  An initial factor of 3 has proven to be quite good in most usecases.
  If however the data for customer 'Jones' was spread on 3 different content nodes,
  'Jones' might be among the 2 best on only one node.
  But based on the distribution of the data,
  we have concluded by earlier tests that if we fetch 5.67 as many groups as we need to,
  we will have a correct answer with at least 99.999% confidence.
  So then we just use 6 times as many groups when doing the merge.
</p>
<p>
However there is one exception.
Without an <code>order</code> constraint, <code>precision</code> is not required.
Then local ordering will be the same as global ordering.
Ordering will not change after a merge operation.
</p>
<h3 id="ordering-and-limiting-groups-example">Example</h3>
<p>
  Example: <em>The two customers with most purchases, returning the sum for each:</em>
</p>
<pre>
select (&hellip;) | all(group(customer) max(2) precision(12) order(-count())
    each(output(sum(price))))
</pre>
<table class="table">
<thead>
<tr>
  <th>GroupId</th>
  <th>sum(price)</th>
  </tr>
</thead>
<tbody>
<tr>
  <td>Jones</td>
  <td>$39 816</td>
  </tr>
<tr>
  <td>Smith</td>
  <td>$19 484</td>
  </tr>
</tbody>
</table>



<h2 id="hits-per-group">Hits per Group</h2>
<p>
Use <code>summary</code> to print the fields for a hit,
and <code>max</code> to limit the number of hits per group.
</p>
<p>
  An implicit limit can be specified through the
  <code><a href="reference/query-api-reference.html#grouping.defaultmaxhits">grouping.defaultMaxHits</a></code> query parameter.
  This value will always be overridden if <code>max</code> explicitly specified in the query.
  Use <code>max(inf)</code> to retrieve all hits when the query parameter is set.
</p>

<h3 id="hits-per-group-example">Example</h3>
<p>
  Example: Return the three most expensive parts per customer:
</p>
<pre>
/search/?yql=select * from sources * where true |
             all(group(customer) each(max(3) each(output(summary()))))
        &amp;ranking=pricerank
</pre>
<table class="table">
<thead>
<tr>
  <th>GroupId</th>
  <th></th>
  <th></th>
  <th></th>
  <th></th>
  <th></th>
  </tr>
</thead>
<tbody>
<tr>
  <td>Brown</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  </tr>
<tr class="trx">
  <td></td>
  <th class="thx">Date</th>
  <th class="thx">Price</th>
  <th class="thx">Tax</th>
  <th class="thx">Item</th>
  <th class="thx">Customer</th>
  </tr>
<tr>
  <td></td>
  <td>2006-09-08 11:00</td>
  <td>$8 000</td>
  <td>0.12</td>
  <td>Head</td>
  <td>Brown</td>
  </tr>
<tr>
  <td></td>
  <td>2006-09-10 10:00</td>
  <td>$3 770</td>
  <td>0.12</td>
  <td>Spring</td>
  <td>Brown</td>
  </tr>
<tr>
  <td></td>
  <td>2006-09-09 11:00</td>
  <td>$3 400</td>
  <td>0.24</td>
  <td>Oil pan</td>
  <td>Brown</td>
  </tr>
<tr>
  <td>Jones</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  </tr>
<tr class="trx">
  <td></td>
  <th class="thx">Date</th>
  <th class="thx">Price</th>
  <th class="thx">Tax</th>
  <th class="thx">Item</th>
  <th class="thx">Customer</th>
</tr>
<tr>
  <td></td>
  <td>2006-09-11 12:00</td>
  <td>$9 870</td>
  <td>0.12</td>
  <td>Exhaust port</td>
  <td>Jones</td>
  </tr>
<tr>
  <td></td>
  <td>2006-09-10 10:00</td>
  <td>$8 900</td>
  <td>0.24</td>
  <td>Camshaft</td>
  <td>Jones</td>
  </tr>
<tr>
  <td></td>
  <td>2006-09-11 13:00</td>
  <td>$6 765</td>
  <td>0.12</td>
  <td>Crankshaft</td>
  <td>Jones</td>
  </tr>
<tr>
  <td>Smith</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  </tr>
<tr class="trx">
  <td></td>
  <th class="thx">Date</th>
  <th class="thx">Price</th>
  <th class="thx">Tax</th>
  <th class="thx">Item</th>
  <th class="thx">Customer</th>
</tr>
<tr>
  <td></td>
  <td>2006-09-10 11:00</td>
  <td>$6 100</td>
  <td>0.24</td>
  <td>Spark plug</td>
  <td>Smith</td>
  </tr>
<tr>
  <td></td>
  <td>2006-09-09 12:00</td>
  <td>$5 500</td>
  <td>0.12</td>
  <td>Oil sump</td>
  <td>Smith</td>
  </tr>
<tr>
  <td></td>
  <td>2006-09-11 11:00</td>
  <td>$2 584</td>
  <td>0.12</td>
  <td>Connection rod</td>
  <td>Smith</td>
  </tr>
</tbody>
</table>
<p>Notes on ordering in the example above:</p>
<ul>
<li>
    The <code>order</code> clause is a directive for <em>group</em> ordering, not <em>hit</em> ordering.
    Here, there is no order clause on the groups, so default ordering <code>-max(relevance())</code> is used. The <em>-</em>
    denotes the sorting order, <em>-</em> means descending (higher score first).
    In this case, the query is "all documents", so all groups are equally relevant and the group order is random.
</li><li>
    To order hits inside groups, use ranking. Add <code>ranking=pricerank</code> to the query
    to use the pricerank <a href="ranking.html">rank profile</a> to rank by price:
<pre>
rank-profile pricerank inherits default {
    first-phase {
        expression: attribute(price)
    }
}</pre>
</li>
</ul>

<h2 id="global-limit">Global limit for grouping queries</h2>
Use the <code><a href="reference/query-api-reference.html#grouping.globalmaxgroups">grouping.globalMaxGroups</a></code> query parameter
to restrict execution of queries that are potentially too expensive in terms of compute and bandwidth.
Queries that may return a result exceeding this threshold are failed preemptively.
This limit is compared against the total number of groups and hits that query could return at worst-case.

<h3 id="resource-control-example">Examples</h3>
<p>
  The following query may return 5 groups and 0 hits.
  It will be rejected when <code>grouping.globalMaxGroups &lt; 5</code>
</p>
<pre>
select (&hellip;) |
  all(group(a) max(5)
    each(output(count())))
</pre>

<p>
  The following query may return 5 groups and 35 hits.
  It will be rejected when <code>grouping.globalMaxGroups &lt; 5+5*7</code>.
</p>
<pre>
select (&hellip;) |
  all(group(a) max(5)
    each(output(count()) max(7)
      each(output(summary()))))
</pre>

<p>
  The following query may return 6 groups and 30 hits.
  It will be rejected when <code>grouping.globalMaxGroups &lt; 2*(3+3*5)</code>.
</p>
<pre>
select (&hellip;) |
  all(
    all(group(a) max(3)
      each(output(count()) max(5)
        each(output(summary()))))
    all(group(b) max(3)
      each(output(count()) max(5)
        each(output(summary())))))
</pre>

<h3 id="global-limit-combining">Combining with default limits for groups/hits</h3>
<p>
  The <code>grouping.globalMaxGroups</code> restriction will utilize the
  <code><a href="reference/query-api-reference.html#grouping.defaultmaxgroups">grouping.defaultMaxGroups</a></code>/
  <code><a href="reference/query-api-reference.html#grouping.defaultmaxhits">grouping.defaultMaxHits</a></code>
  values for grouping statements without a <code>max</code>. The two queries below are identical assuming
  <code>defaultMaxGroups=5</code> and <code>defaultMaxHits=7</code>, and both will be rejected when
  <code>globalMaxGroups &lt; 5+5*7</code>.
</p>
<pre>
select (&hellip;) |
  all(group(a) max(5)
    each(output(count()) max(7)
      each(output(summary()))))

select (&hellip;) |
  all(group(a)
    each(output(count())
      each(output(summary()))))
</pre>
<p>
  A grouping without <code>max</code> combined with <code>defaultMaxGroups=-1</code>/<code>defaultMaxHits=-1</code>
  will be rejected unless <code>globalMaxGroups=-1</code>. This is because the query produces an unbounded result,
  infinite number of groups if <code>defaultMaxGroups=-1</code> or infinite number of summaries if
  <code>defaultMaxHits=-1</code>.
  An unintentional DoS (Denial of Service) could be the utter consequence if a query returns thousands of groups and summaries.
  This is why setting <code>globalMaxGroups=-1</code> is risky.
</p>

<h3 id="global-limit-recommendation">Recommended settings</h3>
<p>
  The best practice is to always specify <code>max</code> in groupings,
  making it easy to reason about the worst-case cardinality of the query results. The performance will also benefit.
  Set <code>globalMaxGroups</code> to the overall worst-case result cardinality with some margin.
  The <code>defaultMaxGroups</code>/<code>defaultMaxHits</code>
  should be overridden in a query profile if some groupings do not use <code>max</code> and the default values are too low.
</p>

<pre>
  &lt;query-profile id="default"&gt;
    &lt;field name="grouping.defaultMaxGroups"&gt;20&lt;/field&gt;
    &lt;field name="grouping.defaultMaxHits"&gt;100&lt;/field&gt;
    &lt;field name="grouping.globalMaxGroups"&gt;8000&lt;/field&gt;
  &lt;/query-profile&gt;
</pre>

<h2 id="performance-and-correctness">Performance and Correctness</h2>
<p>
  Grouping is by default tuned to favour performance over correctness.
  Perfect correctness may not be achievable; result of queries using <a href="#ordering-and-limiting-groups">non-default ordering</a>
  can be approximate and correctness can only be partially achieved by a larger <code>precision</code> value that sacrifices performance.
</p>
<p>
  The <a href="reference/grouping-syntax.html#grouping-session-cache">grouping session cache</a> is enabled by default.
  Disabling it will improve correctness, especially for queries using <code>order</code> and <code>max</code>.
  The cost of multi-level grouping expressions will though increase.
</p>
<p>
  Consider increasing the <code><a href="#ordering-and-limiting-groups">precision</a></code> value when using <code>max</code> in combination with <code>order</code>.
  The default precision may not achieve the required correctness for your use-case.
</p>

<h2 id="nested-groups">Nested Groups</h2>
<p>
Groups can be nested. This offers great drilling capabilities,
as there are no limits to nesting depth or presented information on any level.
Example: How much each customer has spent per day by grouping on customer, then date:
</p>
<pre>
select (&hellip;) | all(group(customer) each(group(time.date(date)) each(output(sum(price)))))
</pre>
<table class="table">
<thead>
<tr>
  <th>GroupId</th>
  <th></th>
  <th></th>
  </tr>
</thead>
<tbody>
<tr>
  <td>Brown</td>
  <td></td>
  <td></td>
  </tr>
<tr class="trx">
  <td></td>
  <th class="thx">GroupId</th>
  <th class="thx">Sum(price)</th>
  </tr>
<tr>
  <td></td>
  <td>2006-09-08</td>
  <td>$8 000</td>
  </tr>
<tr>
  <td></td>
  <td>2006-09-09</td>
  <td>$3 400</td>
  </tr>
<tr>
  <td></td>
  <td>2006-09-10</td>
  <td>$7 540</td>
  </tr>
<tr>
  <td></td>
  <td>2006-09-11</td>
  <td>$1 597</td>
  </tr>
<tr>
  <td>Jones</td>
  <td></td>
  <td></td>
  </tr>
<tr class="trx">
  <td></td>
  <th class="thx">GroupId</th>
  <th class="thx">Sum(price)</th>
</tr>
<tr>
  <td></td>
  <td>2006-09-08</td>
  <td>$8 000</td>
  </tr>
<tr>
  <td></td>
  <td>2006-09-09</td>
  <td>$2 100</td>
  </tr>
<tr>
  <td></td>
  <td>2006-09-10</td>
  <td>$8 900</td>
  </tr>
<tr>
  <td></td>
  <td>2006-09-11</td>
  <td>$20 816</td>
  </tr>
<tr>
  <td>Smith</td>
  <td></td>
  <td></td>
  </tr>
<tr class="trx">
  <td></td>
  <th class="thx">GroupId</th>
  <th class="thx">Sum(price)</th>
</tr>
<tr>
  <td></td>
  <td>2006-09-06</td>
  <td>$1 000</td>
  </tr>
<tr>
  <td></td>
  <td>2006-09-07</td>
  <td>$3 000</td>
  </tr>
<tr>
  <td></td>
  <td>2006-09-09</td>
  <td>$6 800</td>
  </tr>
<tr>
  <td></td>
  <td>2006-09-10</td>
  <td>$6 100</td>
  </tr>
<tr>
  <td></td>
  <td>2006-09-11</td>
  <td>$2 584</td>
  </tr>
</tbody>
</table>
<p>
Use this to query for all items on a per-customer basis, displaying the most expensive hit for each customer,
with subgroups of purchases on a per-date basis.
Use the <code><a href="#hits-per-group">summary</a></code> clause
to show hits inside any group at any nesting level.
Include the sum price for each customer, both as a grand total and broken down on a per-day basis:
</p>
<pre>
/search/?yql=select * from sources * where true|
             all(group(customer)
                 each(max(1) output(sum(price)) each(output(summary())))
                      each(group(time.date(date))
                      each(max(10) output(sum(price)) each(output(summary())))))
        &amp;ranking=pricerank
</pre>
<table class="table">
<thead>
<tr>
  <th>GroupId</th>
  <th>sum(price)</th>
  <th></th>
  <th></th>
  <th></th>
  <th></th>
  <th></th>
  </tr>
</thead>
<tbody>
<tr>
  <td>Brown</td>
  <td>$20 537</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  </tr>
<tr class="trx">
  <td></td>
  <th class="thx">Date</th>
  <th class="thx">Price</th>
  <th class="thx">Tax</th>
  <th class="thx">Item</th>
  <th class="thx">Customer</th>
  <th></th>
  </tr>
<tr>
  <td></td>
  <td>2006-09-08 11:00</td>
  <td>$8 000</td>
  <td>0.12</td>
  <td>Head</td>
  <td>Brown</td>
  <td></td>
  </tr>
<tr class="trx">
  <td></td>
  <th class="thx">GroupId</th>
  <th class="thx">Sum(price)</th>
  <th></th>
  <th></th>
  <th></th>
  <th></th>
  </tr>
<tr>
  <td></td>
  <td>2006-09-08</td>
  <td>$8 000</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  </tr>
<tr class="trx">
  <td></td>
  <td></td>
  <th class="thx">Date</th>
  <th class="thx">Price</th>
  <th class="thx">Tax</th>
  <th class="thx">Item</th>
  <th class="thx">Customer</th>
  </tr>
<tr>
  <td></td>
  <td></td>
  <td>2006-09-08 11:00</td>
  <td>$8 000</td>
  <td>0.12</td>
  <td>Head</td>
  <td>Brown</td>
  </tr>
<tr>
  <td></td>
  <td>2006-09-09</td>
  <td>$3 400</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  </tr>
<tr class="trx">
  <td></td>
  <td></td>
  <th class="thx">Date</th>
  <th class="thx">Price</th>
  <th class="thx">Tax</th>
  <th class="thx">Item</th>
  <th class="thx">Customer</th>
  </tr>
<tr>
  <td></td>
  <td></td>
  <td>2006-09-09 11:00</td>
  <td>$3 400</td>
  <td>0.12</td>
  <td>Oil pan</td>
  <td>Brown</td>
  </tr>
<tr>
  <td></td>
  <td>2006-09-10</td>
  <td>$7 540</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  </tr>
<tr class="trx">
  <td></td>
  <td></td>
  <th class="thx">Date</th>
  <th class="thx">Price</th>
  <th class="thx">Tax</th>
  <th class="thx">Item</th>
  <th class="thx">Customer</th>
  </tr>
<tr>
  <td></td>
  <td></td>
  <td>2006-09-10 10:00</td>
  <td>$3 770</td>
  <td>0.12</td>
  <td>Spring</td>
  <td>Brown</td>
  </tr>
<tr>
  <td></td>
  <td></td>
  <td>2006-09-10 12:00</td>
  <td>$2 330</td>
  <td>0.24</td>
  <td>Rocker arm</td>
  <td>Brown</td>
  </tr>
<tr>
  <td></td>
  <td></td>
  <td>2006-09-10 11:00</td>
  <td>$1 440</td>
  <td>0.12</td>
  <td>Exhaust valve</td>
  <td>Brown</td>
  </tr>
<tr>
  <td></td>
  <td>2006-09-11</td>
  <td>$1 597</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  </tr>
<tr class="trx">
  <td></td>
  <td></td>
  <th class="thx">Date</th>
  <th class="thx">Price</th>
  <th class="thx">Tax</th>
  <th class="thx">Item</th>
  <th class="thx">Customer</th>
  </tr>
<tr>
  <td></td>
  <td></td>
  <td>2006-09-11 10:00</td>
  <td>$1 597</td>
  <td>0.24</td>
  <td>Piston</td>
  <td>Brown</td>
  </tr>
<tr>
  <td>Jones</td>
  <td>$39 816</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  </tr>
<tr class="trx">
  <td></td>
  <th class="thx">Date</th>
  <th class="thx">Price</th>
  <th class="thx">Tax</th>
  <th class="thx">Item</th>
  <th class="thx">Customer</th>
  <th></th>
  </tr>
<tr>
  <td></td>
  <td>2006-09-11 12:00</td>
  <td>$9 870</td>
  <td>0.12</td>
  <td>Exhaust port</td>
  <td>Jones</td>
  <td></td>
  </tr>
<tr class="trx">
  <td></td>
  <th class="thx">GroupId</th>
  <th class="thx">Sum(price)</th>
  <th></th>
  <th></th>
  <th></th>
  <th></th>
  </tr>
<tr>
  <td></td>
  <td>2006-09-08</td>
  <td>$8 000</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  </tr>
<tr class="trx">
  <td></td>
  <td></td>
  <th class="thx">Date</th>
  <th class="thx">Price</th>
  <th class="thx">Tax</th>
  <th class="thx">Item</th>
  <th class="thx">Customer</th>
  </tr>
<tr>
  <td></td>
  <td></td>
  <td>2006-09-08 10:00</td>
  <td>$5 000</td>
  <td>0.24</td>
  <td>Intake port</td>
  <td>Jones</td>
  </tr>
<tr>
  <td></td>
  <td></td>
  <td>2006-09-08 12:00</td>
  <td>$3 000</td>
  <td>0.12</td>
  <td>Valve cover</td>
  <td>Jones</td>
  </tr>
<tr>
  <td></td>
  <td>2006-09-09</td>
  <td>$2 100</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  </tr>
<tr class="trx">
  <td></td>
  <td></td>
  <th class="thx">Date</th>
  <th class="thx">Price</th>
  <th class="thx">Tax</th>
  <th class="thx">Item</th>
  <th class="thx">Customer</th>
  </tr>
<tr>
  <td></td>
  <td></td>
  <td>2006-09-09 10:00</td>
  <td>$2 100</td>
  <td>0,12</td>
  <td>Engine block</td>
  <td>Jones</td>
  </tr>
<tr>
  <td></td>
  <td>2006-09-10</td>
  <td>$8 900</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  </tr>
<tr class="trx">
  <td></td>
  <td></td>
  <th class="thx">Date</th>
  <th class="thx">Price</th>
  <th class="thx">Tax</th>
  <th class="thx">Item</th>
  <th class="thx">Customer</th>
  </tr>
<tr>
  <td></td>
  <td></td>
  <td>2006-09-10 10:00</td>
  <td>$8 900</td>
  <td>0.24</td>
  <td>Camshaft</td>
  <td>Jones</td>
  </tr>
<tr>
  <td></td>
  <td>2006-09-11</td>
  <td>$20 816</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  </tr>
<tr class="trx">
  <td></td>
  <td></td>
  <th class="thx">Date</th>
  <th class="thx">Price</th>
  <th class="thx">Tax</th>
  <th class="thx">Item</th>
  <th class="thx">Customer</th>
  </tr>
<tr>
  <td></td>
  <td></td>
  <td>2006-09-11 12:00</td>
  <td>$9 870</td>
  <td>0.12</td>
  <td>Exhaust port</td>
  <td>Jones</td>
  </tr>
<tr>
  <td></td>
  <td></td>
  <td>2006-09-11 13:00</td>
  <td>$6 765</td>
  <td>0.12</td>
  <td>Crankshaft</td>
  <td>Jones</td>
  </tr>
<tr>
  <td></td>
  <td></td>
  <td>2006-09-11 12:00</td>
  <td>$4 181</td>
  <td>0.24</td>
  <td>Rod bearing</td>
  <td>Jones</td>
  </tr>
<tr>
  <td>Smith</td>
  <td>$19 484</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  </tr>
<tr class="trx">
  <td></td>
  <th class="thx">Date</th>
  <th class="thx">Price</th>
  <th class="thx">Tax</th>
  <th class="thx">Item</th>
  <th class="thx">Customer</th>
  <th></th>
  </tr>
<tr>
  <td></td>
  <td>2006-09-10 11:00</td>
  <td>$6 100</td>
  <td>0.24</td>
  <td>Spark plug</td>
  <td>Smith</td>
  <td></td>
  </tr>
<tr class="trx">
  <td></td>
  <th class="thx">GroupId</th>
  <th class="thx">Sum(price)</th>
  <th></th>
  <th></th>
  <th></th>
  <th></th>
  </tr>
<tr>
  <td></td>
  <td>2006-09-06</td>
  <td>$1 000</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  </tr>
<tr class="trx">
  <td></td>
  <td></td>
  <th class="thx">Date</th>
  <th class="thx">Price</th>
  <th class="thx">Tax</th>
  <th class="thx">Item</th>
  <th class="thx">Customer</th>
  </tr>
<tr>
  <td></td>
  <td></td>
  <td>2006-09-06 09:00</td>
  <td>$1 000</td>
  <td>0.24</td>
  <td>Intake valve</td>
  <td>Smith</td>
  </tr>
<tr>
  <td></td>
  <td>2006-09-07</td>
  <td>$3 000</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  </tr>
<tr class="trx">
  <td></td>
  <td></td>
  <th class="thx">Date</th>
  <th class="thx">Price</th>
  <th class="thx">Tax</th>
  <th class="thx">Item</th>
  <th class="thx">Customer</th>
  </tr>
<tr>
  <td></td>
  <td></td>
  <td>2006-09-07 11:00</td>
  <td>$2 000</td>
  <td>0.24</td>
  <td>Spring</td>
  <td>Smith</td>
  </tr>
<tr>
  <td></td>
  <td></td>
  <td>2006-09-07 10:00</td>
  <td>$1 000</td>
  <td>0.12</td>
  <td>Rocker arm</td>
  <td>Smith</td>
  </tr>
<tr>
  <td></td>
  <td>2006-09-09</td>
  <td>$6 800</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  </tr>
<tr class="trx">
  <td></td>
  <td></td>
  <th class="thx">Date</th>
  <th class="thx">Price</th>
  <th class="thx">Tax</th>
  <th class="thx">Item</th>
  <th class="thx">Customer</th>
  </tr>
<tr>
  <td></td>
  <td></td>
  <td>2006-09-09 12:00</td>
  <td>$5 500</td>
  <td>0.12</td>
  <td>Oil sump</td>
  <td>Smith</td>
  </tr>
<tr>
  <td></td>
  <td></td>
  <td>2006-09-09 12:00</td>
  <td>$1 300</td>
  <td>0.24</td>
  <td>Coolant</td>
  <td>Smith</td>
  </tr>
<tr>
  <td></td>
  <td>2006-09-10</td>
  <td>$6 100</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  </tr>
<tr class="trx">
  <td></td>
  <td></td>
  <th class="thx">Date</th>
  <th class="thx">Price</th>
  <th class="thx">Tax</th>
  <th class="thx">Item</th>
  <th class="thx">Customer</th>
  </tr>
<tr>
  <td></td>
  <td></td>
  <td>2006-09-10 11:00</td>
  <td>$6 100</td>
  <td>0.24</td>
  <td>Spark plug</td>
  <td>Smith</td>
  </tr>
<tr>
  <td></td>
  <td>2006-09-11</td>
  <td>$2 584</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  </tr>
<tr class="trx">
  <td></td>
  <td></td>
  <th class="thx">Date</th>
  <th class="thx">Price</th>
  <th class="thx">Tax</th>
  <th class="thx">Item</th>
  <th class="thx">Customer</th>
  </tr>
<tr>
  <td></td>
  <td></td>
  <td>2006-09-11 11:00</td>
  <td>$2 584</td>
  <td>0.12</td>
  <td>Connection rod</td>
  <td>Smith</td>
  </tr>
</tbody>
</table>



<h2 id="range-grouping">Range grouping</h2>
<p>
In examples above, results are grouped on distinct values, like customer or date.
To group on price:
</p>
<pre>
select (&hellip;) | all(group(price) each(each(output(summary()))))
</pre>
<p>
This gives one group per price. To group on price <em>ranges</em>, one could compress the price range.
This gives prices in $0 - $999 in bucket 0, $1 000 - $2 000 in bucket 1 and so on:
</p>
<pre>
select (&hellip;) | all(group(price/1000) each(each(output(summary()))))
</pre>
<p>
An alternative is using <a href="reference/grouping-syntax.html#bucket-expressions">bucket expressions</a> -
think of a bucket as the range per group.
Group on price, make groups have a width of 1000:
</p>
<pre>
select (&hellip;) | all(group(fixedwidth(price,1000)) each(each(output(summary()))))
</pre>
<p>Use <code>predefined</code> to configure group sizes individually (the two below are equivalent):</p>
<pre>
select (&hellip;) | all(group(predefined(price, bucket(0,1000), bucket(1000,2000), bucket(2000,5000), bucket(5000,inf))) each(each(output(summary()))))
select (&hellip;) | all(group(predefined(price, bucket[0,1000&gt;, bucket[1000,2000&gt;, bucket[2000,5000&gt;, bucket[5000,inf&gt;)) each(each(output(summary()))))
</pre>
<p>This works with strings as well - put Jones and Smith in the second group:</p>
<pre>
select (&hellip;) | all(group(predefined(customer, bucket(-inf,"Jones"), bucket("Jones", inf))) each(each(output(summary()))))
</pre>
<p>... or have Jones in his own group:</p>
<pre>
select (&hellip;) | all(group(predefined(customer, bucket&lt;-inf,"Jones"&gt;, bucket["Jones"], bucket&lt;"Jones", inf&gt;)) each(each(output(summary()))))
</pre>
<p>Use decimal numbers in bucket definitions if the expression evaluates to a double or float:</p>
<pre>
select (&hellip;) | all(group(predefined(tax, bucket[0.0,0.2&gt;, bucket[0.2,0.5&gt;, bucket[0.5,inf&gt;)) each(each(output(summary()))))
</pre>

<h2 id="pagination">Pagination</h2>
<p>
  Grouping supports <a href="reference/grouping-syntax.html#continuations">continuation</a> objects
  that are passed as annotations to the grouping statement.
  The <code>continuations</code> annotation is a list of zero or more continuation strings,
  returned in the grouping result.
  For example, given the result:
</p>
<pre>{% highlight json %}
{
    "root": {
        "children": [
            {
                "children": [
                    {
                        "children": [
                            {
                                "fields": {
                                    "count()": 7
                                },
                                "value": "Jones",
                                "id": "group:string:Jones",
                                "relevance": 1.0
                            }
                        ],
                        "continuation": {
                            "next": "BGAAABEBEBC",
                            "prev": "BGAAABEABC"
                        },
                        "id": "grouplist:customer",
                        "label": "customer",
                        "relevance": 1.0
                    }
                ],
                "continuation": {
                    "this": "BGAAABEBCA"
                },
                "id": "group:root:0",
                "relevance": 1.0
            }
        ],
        "fields": {
            "totalCount": 20
        },
        "id": "toplevel",
        "relevance": 1.0
    }
}
{% endhighlight %}</pre>
<p>
reproduce the same result by passing the <em>this</em> continuation along the original select:
</p>
<pre>
select (&hellip;) | { 'continuations':['BGAAABEBCA'] }all(&hellip;)
</pre>
<p>
To display the next page of customers, pass the <em>this</em> continuation of the root
group, and the <em>next</em> continuation of the customer list:
</p>
<pre>
select (&hellip;) | { 'continuations':['BGAAABEBCA', 'BGAAABEBEBC'] }all(&hellip;)
</pre>
<p>
To display the previous page of customers, pass the <em>this</em>
continuation of the root group, and the <em>prev</em> continuation of the customer list:
</p>
<pre>
select (&hellip;) | { 'continuations':['BGAAABEBCA', 'BGAAABEABC'] }all(&hellip;)
</pre>
<p>
The <code>continuations</code> annotation is an ordered list of continuation strings.
These are combined by replacement,
so that a continuation given later will replace any shared state with a continuation given before.
Also, when using the <code>continuations</code> annotation, always pass the <em>this</em> continuation as its first element.
</p>
{% include note.html content="Continuations work best when the ordering of hits is stable -
which can be achieved by using <a href='ranking.html'>ranking</a> or
<a href='reference/grouping-syntax.html#order'>ordering</a>.
Adding a tie-breaker might be needed - like <a href='reference/rank-features.html#random'>random.match</a>
or a random double value stored in each document -
to keep the ordering stable in case of multiple documents that would otherwise get the same rank score,
or the same value used for ordering."%}



<h2 id="expressions">Expressions</h2>
<p>
Instead of just grouping on some attribute value,
the <code>group</code> clause may contain arbitrarily complex expressions -
see <code>group</code> in the
<a href="reference/grouping-syntax.html">grouping reference</a> for an exhaustive list.
Examples:
</p>
<ul>
    <li>Select the minimum or maximum of sub-expressions</li>
    <li>Addition, subtraction, multiplication, division, and even modulo of sub-expressions</li>
    <li>Bitwise operations on sub-expressions</li>
    <li>Concatenation of the results of sub-expressions</li>
</ul>
<p>
  Sum the prices of purchases on per-hour-of-day basis:
</p>
<pre>
select (&hellip;) | all(group(mod(div(date,mul(60,60)),24)) each(output(sum(price))))
</pre>
<table class="table">
<thead>
<tr>
  <th>GroupId</th>
  <th>sum(price)</th>
  </tr>
</thead>
<tbody>
<tr>
  <td>09:00</td>
  <td>$1 000</td>
  </tr>
<tr>
  <td>10:00</td>
  <td>$22 367</td>
  </tr>
<tr>
  <td>11:00</td>
  <td>$23 524</td>
  </tr>
<tr>
  <td>12:00</td>
  <td>$26 181</td>
  </tr>
<tr>
  <td>13:00</td>
  <td>$6 765</td>
  </tr>
</tbody>
</table>
<p>
These types of expressions may also be used inside <code>output</code> operations,
so instead of simply calculating the sum price of the grouped purchases,
calculate the sum income after taxes per customer:
</p>
<pre>
select (&hellip;) | all(group(customer) each(output(sum(mul(price,sub(1,tax))))))
</pre>
<table class="table">
<thead>
<tr>
  <th>GroupId</th>
  <th>sum(mul(price,sub(1,tax)))</th>
  </tr>
</thead>
<tbody>
<tr>
  <td>Brown</td>
  <td>$17 193</td>
  </tr>
<tr>
  <td>Jones</td>
  <td>$32 868</td>
  </tr>
<tr>
  <td>Smith</td>
  <td>$15 897</td>
  </tr>
</tbody>
</table>
<p>
Note that the validity of an expression depends on the current nesting level.
E.g. while <code>sum(price)</code> would be a valid expression for a group of hits, <code>price</code> would not.
As a general rule, each operator within an expression either applies to a single hit or aggregates values across a group.
</p>



<h2 id="search-container-api">Search Container API</h2>
<p>
As an alternative to a textual representation,
one can use the programmatic API to execute grouping requests.
This allows multiple grouping requests to run in parallel,
and does not collide with the <code>yql</code> parameter - example:
</p>
<pre>{% highlight java %}
@Override
public Result search(Query query, Execution execution) {
    // Create grouping request.
    GroupingRequest request = GroupingRequest.newInstance(query);
    request.setRootOperation(new AllOperation()
            .setGroupBy(new AttributeValue(&quot;foo&quot;))
            .addChild(new EachOperation()
                .addOutput(new CountAggregator().setLabel(&quot;count&quot;))));

    // Perform grouping request.
    Result result = execution.search(query);

    // Process grouping result.
    Group root = request.getResultGroup(result);
    GroupList foo = root.getGroupList(&quot;foo&quot;);
    for (Hit hit : foo) {
        Group group = (Group)hit;
        Long count = (Long)group.getField(&quot;count&quot;);
        // TODO: Process group and count.
    }

    // Pass results back to calling searcher.
    return result;
}
{% endhighlight %}</pre>
<p>
Refer to the
<a href="https://javadoc.io/doc/com.yahoo.vespa/container-search/latest/com/yahoo/search/grouping/package-summary.html">
API documentation</a> for the complete reference.
</p>



<h2 id="more-examples">More examples</h2>


<h3 id="topn-full-corpus">TopN / Full corpus</h3>
<p>
Simple grouping, count the number of documents in each group:
</p>
<pre>all( group(a) each(output(count())) )</pre>
<p>Two parallel groupings:</p>
<pre>all( all(group(a) each(output(count())))
     all(group(b) each(output(count()))) )</pre>
<p>Only the 1000 best hits will be grouped at each content node. Lower accuracy, but higher speed:</p>
<pre>all( max(1000) all(group(a) each(output(count()))) )</pre>


<h3 id="selecting-groups">Selecting groups</h3>
<p>Do a modulo 5 operation before selecting the group:</p>
<pre>all( group(a % 5) each(output(count())) )</pre>
<p>Do <code>a + b * c</code> before selecting the group:</p>
<pre>all( group(a + b * c) each(output(count())) )</pre>


<h3 id="ordering-groups">Ordering groups</h3>
<p>
Do a modulo 5 operation before selecting the group -
the groups are then ordered by their aggregated sum of attribute "b":
</p>
<pre>all( group(a % 5) order(sum(b)) each(output(count())) )</pre>
<p>
Do <code>a + b * c</code> before selecting the group.
Ordering is given by the maximum value of attribute "d" in each group:
</p>
<pre>all( group(a + b * c) order(max(d)) each(output(count())) )</pre>
<p>
  Take the average relevance of the groups and multiply it with
  the number of groups to get a cumulative count:
</p>
<pre>all( group(a) order(avg(relevance()) * count()) each(output(count())) )</pre>
<p>One can not directly reference an attribute in the order clause, as this:</p>
<pre>all(group(a) order(attr * count()) each(output(count())) )</pre>
<p>However, one can do this:</p>
<pre>all(group(a) order(max(attr) * count()) each(output(count())) )</pre>


<h3 id="collecting-aggregates">Collecting aggregates</h3>
<p>
Simple grouping to count number of documents in each group and return the best hit in each group:
</p>
<pre>all( group(a) each(max(1) each(output(summary()))) )</pre>
<p>Also return the sum of attribute "b":</p>
<pre>all( group(a) each(max(1) output(count(), sum(b)) each(output(summary()))) )</pre>
<p>
  Also return an XOR of the 64 most significant bits of an MD5
  over the concatenation of attributes "a", "b" and "c":
</p>
<pre>all(group(a) each(max(1) output(count(), sum(b), xor(md5(cat(a, b, c), 64)))
                  each(output(summary()))))</pre>


<h3 id="grouping">Grouping</h3>
<p>
  Single level grouping on "a" attribute, returning at most 5 groups with full hit count as well as the 69 best hits.
</p>
<pre>all( group(a) max(5) each(max(69) output(count()) each(output(summary()))) )</pre>
<p>Two level grouping on "a" and "b" attribute:</p>
<pre>all( group(a) max(5) each(output(count())
     all(group(b) max(5) each(max(69) output(count())
         each(output(summary()))))) )</pre>
<p>Three level grouping on "a", "b" and "c" attribute:</p>
<pre>all( group(a) max(5) each(output(count())
     all(group(b) max(5) each(output(count())
         all(group(c) max(5) each(max(69) output(count())
             each(output(summary()))))) )</pre>
<p>As above, but also collect best hit in level 2:</p>
<pre>all( group(a) max(5) each(output(count())
     all(group(b) max(5) each(output(count())
         all(max(1) each(output(summary())))
         all(group(c) max(5) each(max(69) output(count())
             each(output(summary()))))) )</pre>
<p>As above, but also collect best hit in level 1:</p>
<pre>all( group(a) max(5) each(output(count())
     all(max(1) each(output(summary())))
     all(group(b) max(5) each(output(count())
         all(max(1) each(output(summary())))
         all(group(c) max(5) each(max(69) output(count())
             each(output(summary()))))) )</pre>
<p>As above, but using different document summaries on each level:</p>
<pre>all( group(a) max(5) each(output(count())
     all(max(1) each(output(summary(complexsummary))))
     all(group(b) max(5) each(output(count())
         all(max(1) each(output(summary(simplesummary))))
         all(group(c) max(5) each(max(69) output(count())
             each(output(summary(fastsummary)))))) )</pre>
<p>Deep grouping with counting and hit collection on all levels:</p>
<pre>all( group(a) max(5) each(output(count())
     all(max(1) each(output(summary())))
     all(group(b) each(output(count())
         all(max(1) each(output(summary())))
         all(group(c) each(output(count())
             all(max(1) each(output(summary())))))))) )</pre>


<h3 id="time-and-date">Time and date</h3>
<p>
  The field (<code>a</code> below, but can have any name)
  must be a <a href="schema-reference.html#field-types">long</a>, with second resolution (unix timestamp/epoch).
  See the <a href="reference/grouping-syntax.html#time-expressions">reference</a> for all time-functions.
</p>
<p>Group by year:</p>
<pre>all( group(time.year(a)) each(output(count())) )</pre>
<p>Group by year, then by month:</p>
<pre>all( group(time.year(a)) each(output(count())
     all(group(time.month(a)) each(output(count())))) )</pre>
<p>Group by year, then by month, then day, then by hour:</p>
<pre>all( group(time.year(a)) each(output(count())
     all(group(time.monthofyear(a)) each(output(count())
         all(group(time.dayofmonth(a)) each(output(count())
             all(group(time.hourofday(a)) each(output(count())))))))) )</pre>
<p>
  Groups <em>today</em>, <em>yesterday</em>, <em>lastweek</em>, and <em>lastmonth</em>
  using <code>predefined</code> aggregator, and groups each day within each of these separately:
</p>
<pre>all( group(predefined((now() - a) / (60 * 60 * 24),
                      bucket(0,1), bucket(1,2), bucket(3,7), bucket(8,31)))
           each(output(count())
           all(max(2) each(output(summary())))
               all(group((now() - a) / (60 * 60 * 24)) each(output(count())
                   all(max(2) each(output(summary())))))) )</pre>


<h3 id="counting-unique-groups">Counting unique groups</h3>
<p>
  The <code>count</code> aggregator can be applied on list of groups to determine the number of unique groups
  without having to explicitly retrieve all groups.
  Note that this count is an estimate using HyperLogLog++ which is an algorithm for the count-distinct problem.
  To get an accurate count one needs to explicitly retrieve all groups
  and count them in a custom component or in the middle tier calling out to Vespa.
  This is network intensive and might not be feasible in cases with many unique groups.
</p>
<p>
  Another use case for this aggregator is counting the number of unique instances matching a given expression.
</p>
<p>
  Output an estimate of the number of groups, which is equivalent to the number of unique values for attribute "a":
</p>
<pre>all( group(a) output(count()) )</pre>
<p>Output an estimate of the number of unique string lengths for the attribute "name":</p>
<pre>all( group(strlen(name)) output(count()) )</pre>
<p>
  Output the sum of the "b" attribute for each group
  in addition to the accurate count of the overall number of unique groups
  as the inner each causes all groups to be returned.
</p>
<pre>all( group(a) output(count()) each(output(sum(b))) )</pre>
<p>
  The <code>max</code> clause is used to restrict the number of groups returned.
  The query outputs the sum for the 3 best groups.
  The <code>count</code> clause outputs the estimated number of groups (potentially &gt;3).
  The <code>count</code> becomes an estimate here as the number of groups is limited by max,
  while in the above example it's not limited by max:
</p>
<pre>all( group(a) max(3) output(count()) each(output(sum(b))) )</pre>
<p>
  Output the number of top level groups, and for the 10 best groups,
  output the number of unique values for attribute "b":
</p>
<pre>all( group(a) max(10) output(count()) each(group(b) output(count())) )</pre>


<h3 id="impression-forecasting">Impression forecasting</h3>
<p>
Using impression logs for a given user,
one can make a function that maps from rank score to the number of impressions an advertisement would get - example:
</p>
<pre>
Score   Integer (# impressions for this user)
0.200   0
0.210   1
0.220   2
0.240   3
0.320   4
0.420   5
0.560   6
0.700   7
0.800   8
0.880   9
0.920  10
0.940  11
0.950  12
</pre>
<p>
Storing just the first column (the rank scores, including a rank score for 0 impressions)
in an array attribute named <em>impressions</em>, the grouping operation
<code><a href="reference/grouping-syntax.html#interpolatedlookup">interpolatedlookup(impressions, relevance())</a></code>
can be used to figure out how many times a given advertisement would have been shown to this particular user.
</p><p>
So if the rank score is 0.420 for a specific user/ad/bid combination,
then <code>interpolatedlookup(impressions,relevance())</code> would return 5.0.
If the bid is increased so the rankscore gets to 0.490,
it would get 5.5 as the return value instead.
</p><p>
In this context a count of 5.5 isn't meaningful for the past of a single user,
but it gives more information that may be used as a forecast.
Summing this across more, different users may then be used to forecast
the total of future impressions for the advertisement.
</p>
