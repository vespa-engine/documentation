---
# Copyright Vespa.ai. All rights reserved.
title: Initial batch feed
category: cloud
redirect_from:
- /en/cloud/index-bootstrap.html
- /en/cloud/initial-batch-feed.html
---

<p>
  One of the first things you do when creating a Vespa application is deploying it to Vespa Cloud and batch feeding all your data.
  We assume you have made the first version of the schema file(s) and generated a set of Vespa feed files.
  You will face some of these questions:
</p>
<ul>
  <li>What is a good resource configuration for the content nodes holding the index?</li>
  <li>What happens when I change the node resource configuration?</li>
  <li>How many nodes are required to hold the full index?</li>
  <li>Is using autoscaling a good idea when batch feeding?</li>
  <li>How do I know what the feeding bottleneck is?</li>
  <li>What is the difference between a container and content cluster?</li>
</ul>
<p>
  Review the introduction section of the <a href="../learn/overview.html">Vespa overview</a> to understand
  the different between <em>container</em> and <em>content</em> clusters before continuing.
</p>
<p>
  The first thing to note is that changes to node resources (i.e., instance type)
  are <a href="../performance/node-resources">automated</a>.
  This makes it easy to just get started feeding, observe, change, and repeat.
</p>
<p>
  The next thing is, changing node resources takes some time to apply,
  as data and indexes are migrated to the node(s) with the new configuration - more details below.
  This also means, it is easier to change this with little data and few nodes deployed,
  like in the 1% step below.
  Therefore, do an iteration or two to get the disk/memory balance right
</p>
<p>
  Once the node resources configuration is about right, feed more data.
  This is potentially time-consuming.
  Make sure the bottleneck is the nodes in the content clusters (you should see at least one thread at 100%),
  It is a good idea to make sure that the <em>container</em> cluster with the feed endpoint is not at 100% CPU,
  add more nodes if so.
  <a href="../performance/sizing-feeding.html#feed-testing">More details</a>.
</p>
<p>
  Finally, we recommend in this phase to not use <a href="../operations/autoscaling.html">autoscaling</a>.
  Autoscaling is great for incremental changes, in <em>this</em> case, we feed from zero to full.
  Best practice is, once you have a rough idea based on the smaller feed batches,
  allocate 50-100% more content node capacity than your estimate, and feed to full.
  This will speed up the process with less wall-clock time and no delays due to
  <a href="feed-block.html">blocked feeding</a>.
  When the initial feed is done, it is easy to evaluate possible overcapacity and reduce node count.
</p>

<h2 id="summary">Summary</h2>
<p>
  When bootstrapping an index, one must consider node resource configuration and number of nodes.
  The strategy is to iterate:
</p>
<img src="/assets/img/index-bootstrap.svg" width="465" alt="Growing a Vespa cluster in steps"/>
<ol>
  <li>Feed smaller datasets</li>
  <li>Evaluate</li>
  <li>Deploy new node counts / node resource configuration</li>
  <li>Wait for data migration to complete</li>
  <li>Evaluate</li>
</ol>
<p>
  While doing this, ensure the cluster is <strong>not more than 50% full</strong> -
  this gives headroom to later increase/shrink the index
  and change schema configuration easily using automatic reindexing.
  It is easy to downscale resources after the bootstrap,
  and it saves a lot of time keeping the clusters within limits - hence max 50%.
</p>



<h2 id="preparations">Preparations</h2>
<p>
  The content node resource configuration should not have ranges for index bootstrap,
  as autoscaling will interfere with the evaluation in this step.
  This is a good starting point, <strong>make sure there are no ranges like [2,3]</strong>:
</p>
<pre>{% highlight xml %}
<nodes count="2">
    <resources vcpu="2.0" memory="8Gb" disk="50Gb" />
</nodes>
{% endhighlight %}</pre>
<p>
  To evaluate how full the content cluster is,
  use the "Metrics" view in the Vespa Cloud Console
  or <a href="../operations/monitoring.html">metrics</a> from content nodes - example:
</p>
<pre>
$ curl \
  --cert data-plane-public-cert.pem \
  --key  data-plane-private-key.pem \
  https://ab1f1234.b68a8765.z.vespa-app.cloud/prometheus/v1/values | \
  egrep 'disk.util|mem.util' | egrep 'clusterId="content/'
</pre>
<p>Once able to see the metrics above, you are ready to bootstrap the index.</p>



<h2 id="bootstrap">Bootstrap</h2>
<table class="table">
  <thead>
  <tr>
    <th>Step</th><th>Description</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td><strong>1% feed</strong></td>
    <td>
      <p>
        The purpose of this step is to feed a tiny chunk of the corpus to:
      </p>
      <ol>
        <li>Estimate the memory and disk resource configuration.</li>
        <li>Estimate the number of nodes required for the 10% step.</li>
      </ol>
      <p>
        Feed a small data set, using <code>vespa feed</code> as in <a href="../basics/deploy-an-application.html">getting started</a>.
        Observe the util metrics, stop no later than 50% memory/disk util.
        The resource configuration should be modified so disk is in the 50-80% range of memory.
        Example: if memory util is 50%, disk util should be 30-45%.
        The reasoning is that memory is a more expensive component than disk,
        better over-allocate on disk and just track memory usage.
      </p>
      <p>
        Look at memory util. Say the 1% feed caused a 15% memory util -
        this means that the 10% feed will take 150%, or 3X more than the 50% max.
        There are two options, either increase memory/disk or add more nodes.
        A good rule of thumb at this stage is that the final 100% feed could fit on 4 or more nodes,
        and there is a 2-node minimum for redundancy.
        The default configuration at the start of this document is quite small,
        so a 3X at this stage means triple the disk and memory,
        and add more nodes in later steps.
      </p>
      <p>
        Deploy changes (if needed).
        Whenever node count increases or resource configuration is modified, new nodes are added,
        and data is migrated to new nodes. Example: growing from 2 to 3 nodes means each of the 2 current nodes
        will migrate 33% of their data to the new node.
        Read more in <a href="../content/elasticity.html">elasticity</a>.
      </p>
      <p>
        It saves time to let the cluster finish data migration before feeding more data,
        and it lets you observe metrics before next steps.
        In this step it will be fast as the data volume is small, but nevertheless check the
        "Content Buckets Out Of Sync (%), per Cluster" panel in the Vespa Cloud Console Metrics view,
        or the <a href="../reference/distributor-metrics-reference.html#vds_idealstate_merge_bucket_pending">
        vds.idealstate.merge_bucket.pending.average</a> metric.
        Wait for 0 for all nodes - this means data migration is completed:
      </p>
<pre>
$ curl \
  --cert ~/.vespa/mytenant.myapp.default/data-plane-public-cert.pem \
  --key  ~/.vespa/mytenant.myapp.default/data-plane-private-key.pem \
  https://ab1f1234.b68a8765.z.vespa-app.cloud/prometheus/v1/values?consumer=Vespa | \
  egrep 'vds_idealstate_merge_bucket_pending_average'
</pre>
      <p>
        At this point, you can validate that both memory and disk util is less than 5%,
        so the 10% feed will fit.
      </p>
    </td>
  </tr>
  <tr>
    <td><strong>10% feed</strong></td>
    <td>
      <p>
        Feed the 10% corpus, still observing util metrics.
      </p>
      <p>
        As the content cluster capacity is increased,
        it is normal to eventually be CPU bound in the container or content cluster.
        Grep for <code>cpu_util</code> in metrics (like in the example above) to evaluate.
      </p>
      <p>
        A 10% feed is a great baseline for the full capacity requirements.
        Fine tune the resource config and number of hosts as needed.
        If you deploy changes, wait for the
        <code>vds.idealstate.merge_bucket.pending.average</code> metric to go to zero again.
        This now takes longer time as nodes are configured larger,
        it normally completes within a few hours.
      </p>
      <p>
        Again validate memory and disk util is less than 5% before the full feed.
      </p>
    </td>
  </tr>
  <tr>
    <td style="white-space: nowrap;"><strong>100% feed</strong></td>
    <td>
      <p>
        Feed the full data set, observing the metrics.
        You should be able to estimate timing by extrapolation, this is linear at this scale.
        At feed completion, observe the util metrics for the final fine-tuning.
      </p>
      <p>
        A great exercise at this point is to add a node then reduce a node, and take the time to completion
        (<code>vds.idealstate.merge_bucket.pending.average</code> to 0).
        This is useful information when the application is in production,
        as you know the time to add or shrink capacity in advance.
      </p>
      <p>
        It can be a good idea to reduce node count to get the memory util closer to 70% at this step,
        to optimize for cost.
        However, do not spend too much time optimizing in this step, next step is normally
        <a href="../performance/sizing-search.html">sizing for query load</a>.
        This will again possibly alter resource configuration and node counts / topology,
        but now you have a good grasp at how to easily bootstrap the index for these experiments.
      </p>
    </td>
  </tr>
  </tbody>
</table>



<h2 id="troubleshooting">Troubleshooting</h2>
<p>
  Make sure you are able to feed and access documents as the example in <a href="#preparations">preparations</a>.
  Read <a href="../security/guide">security guide</a> for cert/key usage.
</p>
<p>
  Feeding too much will cause a
  <a href="feed-block.html">feed blocked</a> state.
  Add a node to the full content cluster in services.xml, and wait for data migration to complete -
  i.e. wait for the <code>vds.idealstate.merge_bucket.pending.average</code> metric to go to zero.
  It is better to add a node than increasing node resources, as data migration is quicker.
</p>



<h2 id="further-reading">Further reading</h2>
<ul>
  <li><a href="reads-and-writes.html">Reads and Writes</a></li>
  <li><a href="../performance/sizing-feeding.html">Vespa Feed Sizing Guide</a></li>
  <li><a href="../performance/benchmarking-cloud.html">Vespa Cloud Benchmarking</a></li>
  <li><a href="../operations/monitoring.html">Monitoring</a></li>
</ul>
