---
# Copyright Vespa.ai. All rights reserved.
title: "Vespaの機能"
---

## Vespaとは何か？

Vespaはリアルタイムで巨大なデータセットに対して計算を実行・配信するためのエンジンです。
どのような量のデータでも書き込んで保存することができ、典型的には数十ミリ秒で完了するデータに対する膨大なクエリーを実行することができます。

データを選択するために、クエリーには構造化されたフィルタと構造化されていないテキスト検索の両方を指定することができます。
検索の関連度、レコメンデーション、ターゲティングやパーソナライズといった用途を実現するため、マッチしたすべてのデータはランキング関数（典型的には機械学習による）に従ってランキングされます。

マッチしたすべてのドキュメントはグループやサブグループに分けることもでき、このときデータはグラフ、タグクラウド、ナビゲーション・ツール、結果の多様性といった機能を実現するため各グループに集約されます。

クエリー、検索結果、書き込みを処理するアプリケーション固有の動作は、Javaコンポーネントをアプリケーション・パッケージに含めることで追加することができます。

Vespaはリアルタイムです。データの断片とコアに対してクエリーを同時実行することで、さらなるクエリー量には同じデータのたくさんのコピー（グループ）に対してクエリーを同時実行することで、どのような量のデータでも一定の応答時間を維持するよう設計されています。数十ミリ秒以内にレスポンスを返却できるよう最適化されています。データの書き込みは数ミリ秒で参照できるようになり、各ノードで秒あたり数千から数万のレートで扱うことができます。

Vespaを簡単にセットアップして運用できるようにするため多くの作業が費やされました。
どのようなVespaアプリケーション（単一ノードのシステムから複数のデータセンターにまたがる数百ノードを稼働させるシステムまで）も*アプリケーション・パッケージ*と呼ばれる単一のアーティファクトで完全に設定されます。ノードやプロセス、コンポーネントの低レベルな設定はアプリケーション・パッケージで指定された特性をもとに行われます。

Vespaはスケーラブルです。数百億のドキュメントを扱う数百ノードにもおよぶシステムは珍しいものではなく、単一ノードのシステムをセットアップして変更するのと大変さは変わりません。
すべてのシステム・コンポーネントは蓄積されたデータと同様に冗長性と自己修正のメカニズムを備えているため、ハードウェア故障は運用上の緊急事態ではなく、都合のよい時にキャパシティを再度追加することで対処できます。

Vespaは自己修復のメカニズムを備えておりダイナミックです。マシンが失われたり新しいものが追加されると、データの配信と書き込みは継続しながら、各マシンに自動的に再配布されます。
変更されたアプリケーション・パッケージをデプロイすることで、配信を継続しながら設定情報とJavaコンポーネントを変更することが可能です - ダウンタイムはなく、再起動も必要ありません。

## 機能

このセクションではVespaの主な機能の概要を説明します。
ドキュメンテーションの残りで詳しく説明します。

### データと書き込み
* Vespaのドキュメントは追加、置換、変更（1つのフィールドあるいは任意のサブセット）、削除することができます。* 書き込みは恒久的な状態になり、さらに（デフォルトでは）クエリーで参照できるようになるとクライアントに受信したことが通知されます。* 書き込みリクエストはクエリーに対する配信を継続しながら、毎ノード毎秒あたり数千から数万のボリュームを維持して発行することができます。* データは設定可能な冗長レベルでレプリケーションされます。* ノードが追加、削除あるいは意図せず失われると、設定された冗長レベルのデータの均等分散が維持されます。* データの破損は、破損していないデータのレプリカから自動的に修復されます。* データはシンプルなHTTP APIか、（大容量向けに）小さなスタンドアロンのJavaクライアントで書き込むことができます。* 一般的なプリミティブ型やコレクション、構造体、テンソルをドキュメントのデータ・スキーマのフィールドに指定することができます。* 同時にいくつものデータ・スキーマを使うことができます。* ドキュメントは相互に参照することができ、参照されているドキュメントのフィールドはパフォーマンスのペナルティなしでクエリーで指定することができます。* カスタムのJavaコンポーネントを追加することで、書き込み処理をプロセスすることができます。* データはバッチ再処理用にシステムからストリーミングすることができます。

### クエリー
* クエリーは構造化されたフィルターと構造化されていない検索演算子の任意の組み合わせを含むことができます。* クエリーは大きなテンソルとベクトルを（例えばユーザーを表現するために）含むことができます。* クエリーで検索結果がどのようにランキングされて、またオーガナイズされるべきかを指定します（以下のセクションを参照してください）。* カスタムのJavaコンポーネントを追加することで、クエリーと検索結果をプロセスすることができます - カスタムのリクエスト・ハンドラで任意のHTTPリクエストをクエリーに変換することもできます。* クエリーの応答時間は典型的には数十ミリ秒以内で、ハードウェアを追加することで負荷やデータサイズに対応できます。* 事前に設定されたドキュメントのグループ（例えば、ユーザーのドキュメント）に対してのみ*ストリーミング検索*モードを利用することができます。このモードでは各ノードで、短い応答時間を維持しながら数十億のドキュメントを保持して配信することができます。

### ランキング
* すべての結果は設定されたランキング関数でランキングされます。ランキング関数はクエリーで指定します。* ランキング関数にはスカラーまたはテンソル（多次元配列）の任意の数学関数を指定することができます。* スカラー関数にはビジネスロジックや決定木を表現するための "if" 関数が含まれます。* テンソル関数には深層ニューラルネットワークのようなもっとも進化した機械学習ランキング関数の表現が可能な原始関数と合成関数の強力なセットが含まれます。* 期待の持てる候補のランキングにより多くのCPUを割り当てられるように、複数フェーズのランキングがサポートされています。* ドキュメントでの位置情報を用いたテキストのランキング特徴量の強力なセットがすぐに使えます。* その他にも2次元の距離や鮮度といったランキング特徴量があります。

### 結果のオーガナイズとプレゼンテーション
* クエリーでの指定にしたがって、クエリーに対してマッチしたドキュメントをグルーピングしたり、集約したりすることができます。* 同時実行される複数台のマシンにまたがる場合であっても、すべてのマッチしたドキュメントが含まれます。* マッチしたドキュメントはユニークな値や数値的なバケットでグルーピングすることができます。* 任意のレベルのグループとサブグループがサポートされており、複数の並列グルーピングを1つのクエリーで指定することができます。* データは集約することができ（カウントする、平均をとるなど）、また各グループやサブグループ内で選択することができます。* ドキュメントからのいかなるデータ選択もクライアントに返却される最終的な検索結果に含めることができます。* マッチしたフィールドにおける検索エンジン・スタイルのキーワードのハイライトがサポートされています。

## 設定と運用
* VespaはRPMまたはDockerイメージとしてインストールすることができます。それは個人のラップトップでも、所有しているデータセンターでも、AWSでも可能です。* Vespaのアプリケーションは独立した構築可能なアーティファクトで完全に記述されます: それは*アプリケーション・パッケージ*で、個々のマシンやプロセスを個別に設定する必要はありません。* システムは任意の数のノードを含む各タイプ（ステートレスとステートフル）からなる複数のクラスタで構成することができます。* どのようなサイズのシステムもアプリケーション・パッケージの2つの短い設定ファイルで記述することができます。* ドキュメント・スキーマ、Javaコンポーネント、ランキング関数/モデルもアプリケーションパッケージで設定されます。* アプリケーションによって意図されたシステムを実現するため、アプリケーション・パッケージが単一のユニットとしてVespaにデプロイされます。* アプリケーションのたいていの変更（Javaコンポーネントの変更を含む）は変更されたアプリケーション・パッケージをデプロイすることで適用することができます。システムは配信と書き込みを維持しながら変更処理を管理します。* たいていのドキュメント・スキーマの変更（フィールド型の変更を除く）はシステムが稼働した状態で適用することができます。* アプリケーション・パッケージの変更は稼働中のシステムに対する破壊的な変更を防ぐため、デプロイ時にバリデーションされます。* Vespaには単一障害点がなく、自動でフェイルしたノードを迂回します。* システムのログはリアルタイムで中央サーバーに収集されます。* すべてのノードから、サードパーティーのメトリクス/アラートシステムに選択されたメトリクスを送信することができます。
